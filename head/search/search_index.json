{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Paladin","text":"<p>Paladin provides programmable privacy for EVM.</p> <p></p> <p>Paladin gives enterprises control of sensitive information without compromising transparency or scalability.</p> <p>READ THE LAUNCH BLOG</p> <p>Paladin is Apache 2.0 open source, with open governance through Linux Foundation Decentralized Trust.</p>"},{"location":"#programmable-privacy-for-evm","title":"Programmable privacy for EVM","text":"<p>The Ethereum Virtual Machine (EVM) powers over 80% of global blockchain projects, making it the 'de facto' runtime environment for both enterprise and permissionless networks.</p> <p>However, there are requirements for enterprise use cases that are not met by the core standard of EVM. The Paladin project brings latest generation of innovation in solving these requirements in the EVM ecosystem, and provides a comprehensive enterprise grade Apache 2.0 open source stack to deliver them.</p> <ul> <li>Anonymity for all parties involved in transactions</li> <li>Confidential transaction details</li> <li>Transaction history masking to prevent tracking</li> <li>Selective data sharing</li> <li>Confidential business logic</li> <li>Privacy preserving smart contracts</li> <li>Private token and asset management</li> <li>Atomic transactions across privacy domains</li> </ul>"},{"location":"faqs/","title":"Frequently Asked Questions","text":""},{"location":"faqs/#topic-1","title":"Topic 1","text":""},{"location":"faqs/#question-1-for-topic-1","title":"Question 1 for Topic 1","text":"<p>Answer</p>"},{"location":"faqs/#question-2-for-topic-1","title":"Question 2 for Topic 1","text":"<p>Answer</p>"},{"location":"faqs/#topic-2","title":"Topic 2","text":""},{"location":"faqs/#question-1-for-topic-2","title":"Question 1 for Topic 2","text":"<p>Answer</p>"},{"location":"faqs/#question-2-for-topic-2","title":"Question 2 for Topic 2","text":"<p>Answer</p>"},{"location":"glossary/","title":"Glossary","text":"term <p>definition</p> term <p>definition</p>"},{"location":"architecture/atomic_interop/","title":"Atomic Interop of Privacy Preserving Smart Contracts","text":"<p>Paladin allows different privacy preserving smart contracts, using different underlying technologies, to interoperate atomically on a single shared EVM ledger.</p> <p>The primary classes of privacy preserving smart contracts are:</p> <ul> <li>Token contracts verified via Zero-knowledge Proofs</li> <li>Learn more about Zeto</li> <li>Token contracts verified via Notary / Issuer pre-verification</li> <li>Learn more about Noto</li> <li>EVM Private Smart Contracts verified by Privacy Group endorsement</li> <li>Learn more about Pente</li> </ul> <p>TODO: Feel like a high-level diagram would be helpful here.</p>"},{"location":"architecture/atomic_interop/#dvp-pvp-and-other-use-cases","title":"DvP, PvP and other use cases","text":"<p>The ability to transact atomically on a single shared ledger is important to implement core use cases such as: - Delivery vs. Payment (DvP) - Payment vs. Payment (PvP)</p> <p>These categories of use case often require complex multi-party flows to setup, agree and execute a transaction across multiple fungible, non-fungible and other tokenized assets.</p> <p>Without a shared ledger supporting atomic transactions, it is necessary to use digital (time-lock based) or 3<sup>rd</sup> party escrow to manage counter-party risk at stages in the transaction flow where actions need to occur in separate atomic transactions in different ledgers/blockchains.</p>"},{"location":"architecture/atomic_interop/#tokens-and-programmability","title":"Tokens and programmability","text":"<p>Some features for atomic interop are built directly into the tokens themselves - the digital currencies and digital assets.</p> <p>However, if the functions of every possible business flow needed to be pre-built directly into the tokens themselves, then innovation would be very difficult for the ecosystem.</p> <p>So to make these tokens fully programmable there needs to be privacy preserving smart contract layer that allows ecosystem developer to create complex flows on top of the underlying token contracts.</p> <p>The Ethereum ecosystem has excelled in enabling this form of adoption - with countless use cases programmed in EVM, using the interoperability of public token interface standards such as ERC-20, ERC-721, ERC-1155 and others.</p> <p>The Ethereum ecosystem has also been the hub of innovation on privacy preserving approaches to build new tokens using advanced cryptography like Zero-knowledge proofs. These tokens cannot, by definition, implement the base public ERC standards directly, but they can provide similar privacy-preserving alternatives.</p> <p>Paladin brings these streams of innovation together by defining the interface standards both: - On-chain:    - To allow each privacy preserving smart contract to function very differently internally - Off-chain:    - To allow enterprises to transact at scale, across many token ecosystems, with a single runtime engine</p> <p>See the Programming Model section for more information on how individual privacy preserving smart contacts are built.</p>"},{"location":"architecture/atomic_interop/#approval-based-atomic-transactions","title":"Approval-based atomic transactions","text":"<p>The first type of atomic interop supported by Paladin is approval-based atomic transactions.</p> <p></p> <p>In the above example Bob and Sally are performing a DvP of some privacy preserving cash tokens, and some privacy preserving bond tokens, in coordination with a programmed EVM private smart contract that only Bob and Sally are party to.</p> <p>There are 4 ***base EVM** ledger smart contracts in this worked example:</p> <ol> <li>Privacy Group Maintenance Smart Contract</li> <li>This enforces the state transitions of the EVM smart contract private to Bob &amp; Sally</li> <li>Each private smart contract has it's own set of UTXO states</li> <li>There could be many thousands of different EVM smart contracts running independently and privately, backed by this one base EVM smart contract</li> <li>Learn more in Pente</li> <li>Fund Token Contract example - Notary Based</li> <li>Enforcing the issuance, transfer, registry and other functions of the digital asset</li> <li>Pre-verification by a trusted party is necessary for each transaction<ul> <li>The issuer, registrar, or transfer-agent has visibility of all transactions/data</li> </ul> </li> <li>Transactions are confidential and anonymous between token holding parties</li> <li>The token is maintained through UTXO states representing ownership</li> <li>All tokens are trusted by all parties, because they trust the issuer</li> <li>Learn more in Noto</li> <li>Cash Token Contract example - ZKP Based</li> <li>Enforcing total conservation of value for fungible cash tokens</li> <li>Transactions are confidential and anonymous to all</li> <li>Transfers require a zero-knowledge proof pre-calculated by the spender, to be verified on the base EVM ledger</li> <li>Swap Contract - pure public EVM</li> <li>Records the signature of an immutable set of pre-prepared transactions</li> <li>Records the right privacy preserving smart contract</li> <li>Has an unique smart contract account address to be authorized to complete the transaction (standard EVM swap semantics)</li> <li>Contains simple <code>execute()</code> function that invokes each smart contract in turn</li> <li>All smart contract sub-transactions must complete, or the transaction <code>reverts</code></li> </ol>"},{"location":"architecture/atomic_interop/#pre-approvalsetup-phase","title":"Pre-approval/setup phase","text":"<p>Before approval can happen:</p> <ul> <li>Some arbitrary number of EVM private smart contract transitions have occurred between Bob &amp; Sally that resulted in an agreed state</li> <li>This state is represented by the merkle tree root of one or more private smart contracts</li> <li>Each state transition up to that point was agreed by Bob &amp; Sally, because they were in the Privacy Group for the smart contract</li> <li>Bob has constructed a transaction that transfers some Fund tokens to Sally</li> <li>Sally has constructed a transaction that transfers some Cash tokens to Bob</li> </ul>"},{"location":"architecture/atomic_interop/#approvalprepare-phase","title":"Approval/prepare phase","text":"<p>The approval phase requires multiple transactions:</p> <ol> <li>One party gathers the pre-approval information for all transactions, and deploys the swap contract for this pre-approved list<ul> <li>This must happen before the approvals, so the smart contract account address is known</li> </ul> </li> <li>An approval transaction for each privacy preserving smart contract, is executed to approve the account of the swap contract to finalize each sub-transaction:<ul> <li>a) Private EVM - endorsed by Bob &amp; Sally based on the pre-execution done to generate the signature of the transaction in the pre-approval phase</li> <li>b) Fund - notarized by the issuer/transfer-agent of the fund</li> <li>c) Cash - by submitting a zero-knowledge proof</li> </ul> </li> </ol> <p>These are 4 separate EVM transactions (1, 2a, 2b, 2c), where parallelism is possible for the approval transactions (2a, 2b, 2c).</p> <p>Note that the execution transaction below can be automatically chained to the last of the approval transactions.</p>"},{"location":"architecture/atomic_interop/#executioncommit-phase","title":"Execution/commit phase","text":"<p>Once all of the approvals are in place, any party can submit a transaction to the <code>execute()</code> function on the swap mark contract to complete the transaction atomically.</p> <p>This phase actually spends the UTXO states inside of each of the privacy preserving smart contracts, and creates the new states.</p> <ul> <li>The Fund transfer happens - tokens move from Bob to Sally</li> <li>The Cash transfer happens - tokens move from Sally to Bob</li> <li>The Private EVM smart contract transition happens</li> </ul> <p>These happen as part of a single EVM transaction, so are atomic on the shared ledger.</p>"},{"location":"architecture/atomic_interop/#post-execution","title":"Post execution","text":"<p>The most important characteristic of this flow, is that after this atomic transaction is complete the rules of each privacy preserving smart contract have been obeyed without any special knowledge needed by other parties transacting in that domain.</p> <ul> <li>Sally can spend her fund tokens, without anyone knowing they came from Bob</li> <li>Except Bob, Sally and the notary for the fund</li> <li>Bob can spend his cash tokens, without anyone known they came from Sally</li> <li> <ul> <li>Except Bob and Sally</li> </ul> </li> <li>Bob &amp; Sally can continue to process new EVM transactions in their private smart contract</li> </ul>"},{"location":"architecture/data_and_registry/","title":"Data Transports and Registry","text":"<p>Each Paladin runtime needs to share data privately with other Paladins, based on the identities that are transacting.</p> <p>These message are frequent and occur as part of the Distributed transaction manager operation to coordinate the assembly and submission of transactions.</p> <p></p>"},{"location":"architecture/data_and_registry/#types-of-identity","title":"Types of identity","text":"<p>There are two fundamental types of identity involved in Paladin:</p>"},{"location":"architecture/data_and_registry/#account-signing-identities","title":"Account signing identities","text":"<p>These are able to sign transactions, and hold state/value.</p> <p>Some are used at the Base EVM Ledger layer to submit transactions, and others are used during ZKP proof generation, or endorsement/notarization flows.</p> <p>These live for a long time, and are very complex to change</p> <p>While Paladin supports many underlying technologies to manage the key materials and signing, there are some common attributes:</p> <ul> <li>A public key identifier</li> <li>A type of cryptography (sekp256k1, Baby Jubjub etc.)</li> <li>A logical association to an actual identifiable entity, which might or   might not be disclosed to others in the network</li> </ul> <p>A single Paladin runtime might manage thousands of these accounts, for different purposes. For example generating a new signing key to submit each traction to a blockchain for anonymous submission, or managing the keys for many different user accounts that all transact via that Paladin node.</p>"},{"location":"architecture/data_and_registry/#runtime-routing-identities","title":"Runtime routing identities","text":"<p>For private data to be able to move securely between Paladin runtimes, a different form of identity is required for the endpoints.</p> <p>These are used only for data-in-flight. These must be able to change as infrastructure updates, and keys rotate, and they are bound only to runtime infrastructure (not the transacting entities themselves)</p> <p>They provide transport-specific routing information:</p> <ul> <li>Transport support information</li> <li>IP addresses</li> <li>Hostnames</li> <li>Topic/queue names</li> <li>Transport encryption signing identities (PKI certificates)</li> </ul> <p>A single Paladin runtime might expose multiple external connection transports for other Paladin nodes to connect to. However, those remote nodes must be able to establish securely that they are encrypting and transferring data to the right node.</p>"},{"location":"architecture/data_and_registry/#routing-and-delivering-private-data","title":"Routing and delivering private data","text":"<p>When constructing a transaction the signing identities of multiple parties might be involved:</p> <ul> <li>Initiator of the transaction</li> <li>Old owner(s) of the values/states being transferred/spent</li> <li>New owner(s) of the values/states being transferred/minted</li> <li>Endorsers of the transaction (notary / privacy group)</li> <li>Base EVM submission identity</li> </ul> <p>For each of these parties there might be a need to:</p> <ul> <li>Route data to that party</li> <li>Request signing from that party</li> <li>Request submission from that party</li> </ul> <p>Some of this information is provided explicitly by the initiator of the transaction, and others are determined by the Paladin node interacting with the privacy preserving smart contract module to orchestrate the transaction.</p> <p>In each case the Paladin node needs to determine: - Which account signing identity is involved - Which runtime route to use to transfer the data</p>"},{"location":"architecture/data_and_registry/#account-routing-addresses","title":"Account &amp; Routing Addresses","text":"<p>Paladin solves this problem by requiring each specification of a target identity to include two parts:</p> <ol> <li>The <code>account identifier</code>: points to a signing account<ul> <li>An off-chain address book in each Paladin node allows mapping between arbitrary strings and the underlying address. This is covered in more detail in Key Management</li> </ul> </li> <li>The <code>routing identifier</code>: points to a Paladin runtime<ul> <li>This is passed into a <code>registry</code> plugin to determine the right transport, physical address, and encryption details to use</li> </ul> </li> </ol>"},{"location":"architecture/data_and_registry/#registry-plugin","title":"Registry plugin","text":"<p>TODO: Details to follow (Lead: Gabriel Indik)</p>"},{"location":"architecture/data_and_registry/#transports","title":"Transports","text":"<p>Some fundamental architecture principals are applied to our transports, to allow the rest of the Paladin engine to be agnostic to which transport is used:</p> <ol> <li>The transport interface is asynchronous event/message transfer</li> <li>This does not prevent synchronous protocols like HTTP being used, but the HTTP request must not block waiting for processing. Rather, responses arrive via a later HTTP request in the other direction.</li> <li>Resilience is encouraged, but not relied upon by Paladin</li> <li>All requests over the transport are idempotent in nature, and will be retried by the Paladin in the case of error</li> <li>Encryption must be end-to-end between Paladin runtimes</li> <li>Where a hub+spoke transport model exists, such a a central JMS/Kafka message bus, or a multi-hop gossip based peer to peer network, the data must be encrypted before it leaves Paladin, and not decrypted again until received by the final destination Paladin</li> </ol> <p>TODO: Details to follow (Lead: Sam May)</p>"},{"location":"architecture/domains/","title":"Domains","text":"<p>Work in progress page to provide more information on the above workflow.</p> <p>Please see the detailed comments on the Protobuf definitions in this file in the meantime:</p> <ul> <li>To domain - requests from Paladin to a domain</li> <li>From domain - callbacks from a domain to Paladin</li> </ul>"},{"location":"architecture/key_management/","title":"Key Management","text":"<p>Key management in Paladin is designed to meet a complex set of requirements for enterprise key management, spanning both the secure storage of key materials in advanced locations (HMS/SSM), and dynamic usage of keys for many different identities/wallets/one-time use cases.</p> <p>Paladin has the extra complexity over many Web3 technologies, that it doesn't just need to support a single algorithm (such as SECP256K1). Instead it must support multiple privacy-perserving approaches to signing - including the use of key materials directly during the formation of Zero Knowledge Proofs (ZKP).</p>"},{"location":"architecture/key_management/#choices-for-the-key-administrator","title":"Choices for the key administrator","text":"<p>This leads to some key decisions that must be made by the administrator responsible for the Paladin node on how keys are managed.</p>"},{"location":"architecture/key_management/#in-memory-vs-in-key-store-signing","title":"In-memory vs in-key-store signing","text":"<p>Advanced cryptographic storage systems such as Hardware Security Modules (HSM) and Software Security Modules (SSM) / Vault technologies, are built on one very important principal:</p> <p>The key materials never leave the store</p> <p>There are two challenges to this in the Web3 domain:</p> <ol> <li>Algorithm / ZKP support - HSM/SSM modules may not support all of the algorithms required    for signing, or the ability to execute ZKP circuit provers natively.</li> <li>Numeracy of keys - HSM/SSM modules are commonly optimized for high value keys, and    thus generating/storing millions of single-use keys for anonymous TX transaction submission    might be inefficient (on cost or performance)</li> </ol> <p>Paladin lets you choose use case by use case all within a single Paladin engine whether you delegate signing into your key store using its internal cryptography, or whether you allow the signing key to be loaded into the volatile memory of the <code>signing module</code> to perform the cryptography.</p>"},{"location":"architecture/key_management/#paladin-embedded-vs-remote-signing-modules","title":"Paladin-embedded vs. remote signing modules","text":"<p>Because there are going to be cases where you perform in-memory signing, or proof generation, you should be cautious about where the signing modules run that will hold those keys in volatile memory.</p> <ul> <li>You might choose to have that happen embedded into the Paladin node</li> <li>The shortest code path for performance</li> <li>The simplest deployment architecture</li> <li>You might choose to run them on a completely separate infrastructure</li> <li>In a more trusted network segment, with very limited secure key path for signing requests</li> <li>Maybe co-located with your HSM with a local PKCS#11 interface</li> <li>Maybe runtime-embedded into your SSM / Vault technology as a code-module</li> </ul> <p>Paladin packages the signing module for maximum flexibility. You will see the majority of the quick start setup guides, and kubernetes deployment samples, have it Paladin-embedded by default.</p> <p>However, the code is structured to make it very easy to run it remotely.</p> <p>You can extend it with code to support more key storage technologies, including proprietary technologies unique to your enterprise. The modular code design for extensibility, is combined with a set of options on remote connectivity:</p> <ul> <li>HTTPS+JSON</li> <li>gRPC+Protobuf</li> <li>Both with mutual-TLS and additional session/JWT credentials</li> </ul> <p>Multiple signing-modules are supported by a single Paladin node, so you can use a mixture of embedded and remote signing modules in one node</p> <p>Alternatively you can choose to leverage the plugin ecosystem of Paladin and bring-your-own signing module implementation that gives you the freedom to achieve all of the above. (Refer to the paladin example signing module plugin as a starting point).</p>"},{"location":"architecture/key_management/#direct-key-mapping-vs-key-derivation","title":"Direct key mapping vs. key derivation","text":"<p>We discussed earlier that the numeracy of keys used by Web3 technologies (particularly with anonymity), and speed of key generation, is a challenge for some HSM/SSM technologies.</p> <p>So for each use case you need to make an important choice between:</p>"},{"location":"architecture/key_management/#direct-key-mapping","title":"Direct key mapping","text":"<p>Here there is a 1:1 relationship between a resolved <code>key mapping</code> for a key stored in the Paladin database, and a record of a key (individual piece of cryptographic material) in your key storage technology.</p> <p>Paladin makes every effort to ensure this mapping is bidirectional.</p> <p>The identifier/name/label for your keys that make them unique within your key storage is bound to exactly one key mapping in your Paladin database that applications/users can use to reference that key.</p> <p>This means that either of the following result in the same outcome:</p> <ol> <li>An application requests usage of a key, which causes Paladin to <code>resolve</code> it in the backing    key storage system. A piece of key material is looked up or created in the key storage system    and the <code>key mapping</code> is stored in Paladin.</li> <li>A set of existing keys have been created by an administrator in the key storage system,    and Paladin is instructed to <code>discover</code> all of these keys. Multiple <code>key mappings</code> are created    in the Paladin database, each referring to a separate key in the key store.</li> </ol> <p>Both in-memory and in-key-store signing are possible with direct key mapping, depending on the capabilities of the backing key storage HSM/SSM.</p>"},{"location":"architecture/key_management/#key-derivation-bip32","title":"Key derivation (BIP32)","text":"<p>Here there is a many:1 relationship between a resolved <code>key mapping</code> for a key, and a <code>seed</code> piece of key material looked up or created at startup in the key storage system.</p> <p>This single seed is used to build a near-infinite supply of unique keys, structured in a hierarchy of parent/child keys that can be deterministically retrieved in a very efficient manner.</p> <p>This is commonly referred to as a Hierarchical Deterministic (HD) wallet.</p> <p>Only in-memory signing is possible when key derivation is performed within the signing module, as only the <code>seed</code> is stored inside the HSM/SSM key storage module.</p> <p>Paladin supports a well established set of standards for the operation of this key derivation:</p> <ul> <li>BIP-32 defines the fundamental operation of the   derivation algorithm for cryptographic keys</li> <li>BIP-39 allows mnemonic seed phrases to optionally   be used (instead of a 32 byte private key) as the <code>seed</code>, or root, of the key hierarchy</li> <li>BIP-44 provides a string semantic for expressing   a derivation path within a BIP-32 HD Wallet with a string pattern such as   <code>m / 44' / 60' / 0' / 1 / 2 / 3</code>. This syntax is used in the signing module configuration   for the prefix to use for keys, and as the way to refer uniquely to a key in the hierarchy.</li> </ul> <p>Some key storage systems internally use key derivation, similarly to that performed by the signing module. In these cases the signing module is configured for <code>direct</code> key mapping, and any key derivation is delegated down into the backing key store.</p>"},{"location":"architecture/key_management/#mixing-direct-and-derived-key-mapping","title":"Mixing direct and derived key mapping","text":"<p>You can use multiple signing modules in a single Paladin, including differently configured modules backed by the same key store. So you can use a mix of direct mapping and key derivation in a single Paladin node.</p>"},{"location":"architecture/key_management/#how-it-works-for-applications","title":"How it works for applications","text":"<p>The architecture has the following core concepts:</p>"},{"location":"architecture/key_management/#1-key-identifiers","title":"1. Key Identifiers","text":"<p>When applications and configuration refer to keys, they can do so via string identifiers.</p> <p>See Data &amp; Registry for details about the format of these identifiers and how they are resolved across separate Paladin runtimes.</p> <p>These identifiers can be human/application friendly strings describing the purpose of the key, rather than needing to be one of the public-key identifiers (like an Eth <code>address</code>) that represents that key with a particular signing algorithm (like <code>secp256k1</code>).</p> <p>Key identifiers can be organized into folders, using a <code>/</code> character within the identifier.</p> <p>This is useful for logical partitioning of keys owned by different entities, as well as being used by the signing module to influence grouping of keys. For example to influence the derivation path of keys in a BIP32 Hierarchical Deterministic (HD) Wallet.</p> <p>When submitting public transactions, the key may also be referred to using the Ethereum Address (Referred to in Paladin as a <code>Verifier</code>, described in detail in the Public Verifiers and Algorithms section below). To do this, the <code>from</code> string of a transaction must be prefixed with <code>eth_address:</code>, e.g. <code>\"from\": \"eth_address:0xf8f3fcf26a437cac6f8bdc92257f3b03e2f5c546</code>. The syntax is case sensitive, and Etherum Addresses are stored in lower case. Referring to keys by public verifier is not supported more widely as cross node reverse lookups may result in identifiers being leaked.</p> <p>Note that resolving a key in a backend key storage system by verifier (derived from the public key) is only possible in Paladin, after that verifier has been resolved at least once for the correct <code>algorithm</code> and <code>verifierType</code>. Otherwise Paladin does not have a reverse-lookup mapping stored in the database to be able to perform the resolution.</p>"},{"location":"architecture/key_management/#2-key-mappings","title":"2. Key Mappings","text":"<p>These are database persisted, and cached, records that the main Paladin runtime maintains that match a <code>key identifier</code> to the <code>key handle</code> of that key in the signing module.</p> <p>Key mappings have a reference to the folder they are in, which references its parent folder all the way up to a single root folder that is pre-created by the Paladin runtime.</p> <p>Key mappings also have <code>attributes</code> that can be specified when creating a key mapping explicitly over an API, and are passed to the signing module when resolving the key. This allows the behavior of the signing module when obtaining/creating key materials to be customized at runtime (within the constraints of that signing module).</p> <p>Every <code>key mapping</code> and <code>folder</code> gets two attributes automatically:</p> <ul> <li><code>name</code>: the part of the <code>key identifier</code> representing this key / folder</li> <li><code>index</code>: a numeric identifier, assured to be unique at this folder level</li> </ul>"},{"location":"architecture/key_management/#3-public-key-identifiers-or-verifiers-and-algorithms","title":"3. Public key identifiers (or \"verifiers\") and algorithms","text":"<p>Cryptographic keys use public/private cryptography, meaning every key can be identified publicly in a way that does not leak the key information itself.</p> <p>Any party can verify that a transaction was signed with a particular private key, by recovering the public key used to sign that transaction.</p> <p>However, to do this we need a standard way to represent a public key so that it can be verified in a standard way against a transaction. Each cryptographic ecosystem actually does this differently, even when using the same private key, and the same algorithm (such as SECP256K1).</p> <p>The most obvious example of this is the Ethereum address. This is a 20 byte compressed representation of a SECP256K1 public key, derived using a well documented algorithm. It looks like <code>0xfdcba455d748cb3e085472cc6f49b4ae86ee4d1f</code> in hex, and sometimes is represented in a case-sensitive way to provide a checksum and avoid copy/paste errors like <code>0xFdcBa455D748cB3e085472CC6F49B4AE86eE4d1F</code> per the EIP-55 standard.</p> <p>Paladin supports multiple of these \"verifiers\" to be calculated, and stored, for public keys. This is fully pluggable, so all the different types of cryptography used in Paladin.</p> <p>For example the IDEN3 standards for representing public keys with Baby JubJub are plugged in by the Zeto domain that implements signing proofs within zero-knowledge proof (ZKP) circuits.</p> <p>In Paladin transaction signing can be complex, requiring multiple signatures, using different algorithms, at different stages in the assembly, endorsement/proof and submission of the transaction to the base blockchain.</p> <p>An algorithm might be straight forward signing of a payload, such as <code>secp256k1</code> signing, and maybe can happen natively inside a HSM device.</p> <p>An algorithm might be domain specific, such as usage of a ZKP friendly cryptography inside of the proof generator of a specific circuit generated in a toolkit like Circom.</p> <p>Some of these algorithms have different ways to represent the same key materials, and require distribution of those public verifiers to multiple parties during the creation of endorsements/proofs of the transaction.</p> <p>So Paladin has a scheme for identification of the <code>algorithm</code> for a signing/proof generation request, and associating multiple <code>public verifiers</code> to the same key materials.</p>"},{"location":"architecture/key_management/#4-signing-modules","title":"4. Signing Modules","text":"<p>These are the engines that have direct or indirect access to key materials, and coordinate signing and ZKP proof generation.</p> <p>Note that the key materials themselves are stored outside the signing module, in one of a number of places supported by those signing modules - such as Local disk (for dev), Cloud Key Managers, Cloud HSMs, Software key managers, and HSMs (supporting PKCS#11)</p> <p>Paladin embeds a flexible implementation of the signing module into the runtime with convenient access to key materials and signing algorithms.</p> <p>Paladin provides this same code as a base implementation for running signing modules outside the core runtime connected of a mutual-TLS secure connection, supplemented with JWT credentials for each signing request that propagate context from the Paladin runtime on the context of the signing.</p> <p>Or it can achieve the same flexability as a pluggable component using Paladin's gRPC plugin framework.</p>"},{"location":"architecture/key_management/#5-key-resolution-and-creation-of-new-keys-on-demand","title":"5. Key resolution and creation of new keys on-demand","text":"<p>The resolution from a <code>key identifier</code> to a <code>key handle</code> happens dynamically, when a suitable <code>key mapping</code> is not already found in the Paladin database.</p> <p>The result of this resolution always ends up with a <code>key handle</code> that the signing module produces that uniquely identifies that key inside of the signing module's cryptographic storage (which is pluggable to many technologies).</p> <p>However, the resolution result might end up with many possible outcomes.</p> <p>For example:</p> <ul> <li>Returning the identifier of a key that already was pre-created in the cryptographic   storage system, thus establishing a new <code>key mapping</code> to an existing <code>key handle</code></li> <li>Instructing the cryptographic storage system to generate a brand new key, thus   on-demand creating a <code>key mapping</code> to a new unique key</li> <li>Allocating a unique derivation path in a Hierarchical Deterministic (HD) derivation   path scheme like BIP32, that references a new unique key backed by an existing   seed/mnemonic stored in the cryptographic storage system</li> </ul>"},{"location":"architecture/ledger_layers/","title":"Ledger Layers","text":"<p>When we consider the make up of a distributed ledger system that preserves privacy for those transacting on it, there are a necessary set of layers that are present in any implementation.</p> <p></p> <p>The Paladin project: - Provides an enterprise grade runtime within the these layers can come together    - So they can interoperate efficiently and thus a minimum viable ecosystem (MVE) can form - Adopts EVM as the base shared ledger layer    - Due to the amount of innovation already available from that ecosystem to build on    - Because programmability in the base shared ledger is what enables atomic interop - Brings in the latest approaches to privacy at the selective disclosure layer, for tokens    - Zero-knowledge proof based systems    - Notary/endorsement based systems - Allows EVM to be used as a programming model for atomic interop scenarios like DvP    - Combining the innovation of previous projects (e.g Tessera), with updated approaches to tokens</p> <p>Let's discuss the layers in a little more detail.</p>"},{"location":"architecture/ledger_layers/#shared-global-state-the-base-shared-ledger","title":"Shared Global State - the base shared ledger","text":"<p>This is the layer that is the most transformational component of Web3 technology, as it did not exist in the Web2 world.</p> <p>A mutually agreed sequence of transactions, written to a shared ledger, trusted by all parties because the maintenance of that ledger is shared across the parties validating that ledger.</p> <p>When sub-ledger privacy is implemented on top of this ledger, there is a limit to what data can be store directly at this layer.</p> <p>As such there are lots of different terms used in privacy-enabled Web3 stacks for this layer:</p> <ul> <li>Orderer - used in models when the only function of this layer is to order transactions pre-verified/endorsed by layers higher in the stack</li> <li>Synchronizer - used in models when the function of this layer is to collect endorsements that prepare a transaction, and record that finalization</li> <li>Blockchain - used in models where this layer is a fully programmable blockchain, where programmable transactions execute directly at this layer</li> </ul> <p>Note that in Orderer and Synchronizer based models, the amount of data/processing that happens in the shared ledger is quite limited. This has lead to many deployments of these models where these are centralized single-party infrastructure, running crash-fault-tolerant algorithms like RAFT or a traditional HA Database. Paladin does not take this approach.</p>"},{"location":"architecture/ledger_layers/#paladin-evm-native-approach-to-the-shared-base-ledger","title":"Paladin - EVM native approach to the shared / base ledger","text":"<p>Paladin is opinionated that the shared ledger should be: - Fully decentralized with a Byzantine Fault Tolerant (BFT) consensus algorithm     - So immutability, order and finality of transaction is trusted by all parties that use it as their shared ledger - Fully programmable via EVM     - So the different smart contracts can interoperate atomically     - So open/public EVM smart contracts (ERC-20, ERC-721, ERC-1155 etc.) can fully interoperate with privacy preserving smart contracts     - See Atomic Interop of Privacy Preserving Smart Contracts for more information - Unmodified EVM     - So that privacy preserving smart contracts can be deployed on top of any ledger that supports EVM     - To uphold good separation of concerns with projects like Hyperledger Besu, avoiding roadmap conflicts that limit innovation</p>"},{"location":"architecture/ledger_layers/#selective-disclosure-the-private-transaction-manager","title":"Selective Disclosure - the private transaction manager","text":"<p>By definition when not all of the data is available directly in the shared / base ledger, there must be a layer of technology that sits above the ledger and is run by all parties in order for them to transact.</p> <p>This layer has some core responsibilities: - Distributed transaction coordination across parties - Secure transfer of data - Secure storage &amp; retrieval of data that has been selectively disclosed - Supporting the programming model of privacy preserving smart contracts - Running the cryptography engines that generate the proofs/signatures needed by the base ledger layer</p> <p>This engine is part of the protocol runtime stack, but it runs above the underlying ledger.</p> <p>The Paladin project focusses on building an enterprise grade runtime for this layer, for the Enterprise EVM Stack.</p>"},{"location":"architecture/ledger_layers/#paladin-modular-and-atomically-interoperable-privacy-preserving-smart-contracts","title":"Paladin - modular and atomically interoperable privacy preserving smart contracts","text":"<p>Paladin takes a modular approach, instead of building around a single cryptographic engine, or implementing a high-level orchestration domain-specific language (DSL) for implementing orchestration and business logic.</p> <p>Some guiding principals that influence the runtime engine architecture include: - Supporting the current and future generations of Zero-knowledge Proof (ZKP) cryptography modules - Supporting notary/issuer based pre-verification approaches, with equal priority to ZKP based approaches - Supporting scalable tokens using a UTXO approach to managing fragmented private state - Supporting EVM as a programming model for private smart contracts - Supporting atomic interoperability between privacy preserving smart contracts of all types - Supporting multiple private data transports, with enterprise qualities of service</p> <p>Learn more about the Paladin Runtime Architecture.</p>"},{"location":"architecture/ledger_layers/#member-specific-state","title":"Member-specific state","text":"<p>All Decentralized Applications (DApps) in the enterprise space, require integration into security infrastructure, core systems, and core business processes.</p> <p>For this reason a significant traditional Web 2.0 infrastructure layer is needed in order for each enterprise to manage their own private participation, the the digital assets they own.</p> <p>This is a combination of application runtimes specific to individual DApps, and middleware that facilitates core system integration, bridging, asset modelling and other high level functions.</p> <p>Paladin does not implement this layer, but is designed to provide high performance enterprise friendly APIs, Event streams, and data query interfaces, to enable application code to be built rapidly, and middleware projects such as Paladin to build upon.</p>"},{"location":"architecture/noto/","title":"Noto - Notarized Tokens","text":"<p>The Noto domain provides confidential UTXO tokens which are managed by a single party, referred to as the notary. Each UTXO state (sometimes referred to as a \"coin\") encodes an owning address, an amount, and a randomly-chosen salt. The states are identified on the base ledger only by a hash of the state data, while the private state data is only exchanged via private channels.</p> <p>The base ledger provides deterministic ordering, double-spend protection, and provable linkage of state data to transactions. The private state data provides a record of ownership and value transfer.</p>"},{"location":"architecture/noto/#private-abi","title":"Private ABI","text":"<p>The private ABI of Noto is implemented in Go, and can be accessed by calling <code>ptx_sendTransaction</code> with <code>\"type\": \"private\"</code>.</p>"},{"location":"architecture/noto/#constructor","title":"constructor","text":"<p>Creates a new Noto token, with a new address on the base ledger.</p> <pre><code>{\n    \"name\": \"\",\n    \"type\": \"constructor\",\n    \"inputs\": [\n        {\"name\": \"notary\", \"type\": \"string\"},\n        {\"name\": \"notaryMode\", \"type\": \"string\"},\n        {\"name\": \"implementation\", \"type\": \"string\"},\n        {\"name\": \"options\", \"type\": \"tuple\", \"components\": [\n            {\"name\": \"basic\", \"type\": \"tuple\", \"components\": [\n                {\"name\": \"restrictMint\", \"type\": \"boolean\"},\n                {\"name\": \"allowBurn\", \"type\": \"boolean\"},\n                {\"name\": \"allowLock\", \"type\": \"boolean\"},\n            ]},\n            {\"name\": \"hooks\", \"type\": \"tuple\", \"components\": [\n                {\"name\": \"privateGroup\", \"type\": \"tuple\", \"components\": [\n                    {\"name\": \"salt\", \"type\": \"bytes32\"},\n                    {\"name\": \"members\", \"type\": \"string[]\"}\n                ]},\n                {\"name\": \"publicAddress\", \"type\": \"address\"},\n                {\"name\": \"privateAddress\", \"type\": \"address\"}\n            ]}\n        ]}\n    ]\n}\n</code></pre> <p>Inputs:</p> <ul> <li>notary - lookup string for the identity that will serve as the notary for this token instance. May be located at this node or another node</li> <li>notaryMode - choose the notary's mode of operation - must be \"basic\" or \"hooks\" (see Notary logic section below)</li> <li>implementation - (optional) the name of a non-default Noto implementation that has previously been registered</li> <li>options - options specific to the chosen notary mode (see Notary logic section below)</li> </ul>"},{"location":"architecture/noto/#mint","title":"mint","text":"<p>Mint new value. New UTXO state(s) will automatically be created to fulfill the requested mint.</p> <pre><code>{\n    \"name\": \"mint\",\n    \"type\": \"function\",\n    \"inputs\": [\n        {\"name\": \"to\", \"type\": \"string\"},\n        {\"name\": \"amount\", \"type\": \"uint256\"},\n        {\"name\": \"data\", \"type\": \"bytes\"}\n    ]\n}\n</code></pre> <p>Inputs:</p> <ul> <li>to - lookup string for the identity that will receive minted value</li> <li>amount - amount of new value to create</li> <li>data - user/application data to include with the transaction (will be accessible from an \"info\" state in the state receipt)</li> </ul>"},{"location":"architecture/noto/#transfer","title":"transfer","text":"<p>Transfer value from the sender to another recipient. Available UTXO states will be selected for spending, and new UTXO states will be created, in order to facilitate the requested transfer of value.</p> <pre><code>{\n    \"name\": \"transfer\",\n    \"type\": \"function\",\n    \"inputs\": [\n        {\"name\": \"to\", \"type\": \"string\"},\n        {\"name\": \"amount\", \"type\": \"uint256\"},\n        {\"name\": \"data\", \"type\": \"bytes\"}\n    ]\n}\n</code></pre> <p>Inputs:</p> <ul> <li>to - lookup string for the identity that will receive transferred value</li> <li>amount - amount of value to transfer</li> <li>data - user/application data to include with the transaction (will be accessible from an \"info\" state in the state receipt)</li> </ul>"},{"location":"architecture/noto/#approvetransfer","title":"approveTransfer","text":"<p>Approve a transfer to be executed by another party.</p> <p>When calling <code>ptx_prepareTransaction()</code> to prepare a private <code>transfer</code>, the <code>metadata</code> of the prepared transaction will include information on how to build a proper <code>approveTransfer</code> call. This allows preparing a transfer and then delegating it to another party for execution.</p> <pre><code>{\n    \"name\": \"approveTransfer\",\n    \"type\": \"function\",\n    \"inputs\": [\n        {\"name\": \"inputs\", \"type\": \"tuple[]\", \"components\": [\n            {\"name\": \"id\", \"type\": \"bytes\"},\n            {\"name\": \"schema\", \"type\": \"bytes32\"},\n            {\"name\": \"data\", \"type\": \"bytes\"}\n        ]},\n        {\"name\": \"outputs\", \"type\": \"tuple[]\", \"components\": [\n            {\"name\": \"id\", \"type\": \"bytes\"},\n            {\"name\": \"schema\", \"type\": \"bytes32\"},\n            {\"name\": \"data\", \"type\": \"bytes\"}\n        ]},\n        {\"name\": \"data\", \"type\": \"bytes\"},\n        {\"name\": \"delegate\", \"type\": \"address\"}\n    ]\n}\n</code></pre>"},{"location":"architecture/noto/#burn","title":"burn","text":"<p>Burn value from the sender. Available UTXO states will be selected for burning, and new UTXO states will be created for the remaining amount (if any).</p> <pre><code>{\n    \"name\": \"burn\",\n    \"type\": \"function\",\n    \"inputs\": [\n        {\"name\": \"amount\", \"type\": \"uint256\"},\n        {\"name\": \"data\", \"type\": \"bytes\"}\n    ]\n}\n</code></pre> <p>Inputs:</p> <ul> <li>amount - amount of value to burn</li> <li>data - user/application data to include with the transaction (will be accessible from an \"info\" state in the state receipt)</li> </ul> <p>Inputs:</p> <ul> <li>inputs - input states that will be spent</li> <li>outputs - output states that will be created</li> <li>data - encoded Paladin and/or user data</li> <li>delegate - address of the delegate party that will be able to execute this transaction once approved</li> </ul>"},{"location":"architecture/noto/#lock","title":"lock","text":"<p>Lock value from the sender and assign it a new lock ID. Available UTXO states will be selected for spending, and new locked UTXO states will be created.</p> <pre><code>{\n    \"name\": \"lock\",\n    \"type\": \"function\",\n    \"inputs\": [\n        {\"name\": \"amount\", \"type\": \"uint256\"},\n        {\"name\": \"data\", \"type\": \"bytes\"}\n    ]\n}\n</code></pre> <p>Inputs:</p> <ul> <li>amount - amount of value to lock</li> <li>data - user/application data to include with the transaction (will be accessible from an \"info\" state in the state receipt)</li> </ul>"},{"location":"architecture/noto/#unlock","title":"unlock","text":"<p>Unlock value that was previously locked, and send it to one or more recipients. Available UTXO states will be selected from the specified lock, and new unlocked UTXO states will be created for the recipients.</p> <pre><code>{\n    \"name\": \"unlock\",\n    \"type\": \"function\",\n    \"inputs\": [\n        {\"name\": \"lockId\", \"type\": \"bytes32\"},\n        {\"name\": \"from\", \"type\": \"string\"},\n        {\"name\": \"recipients\", \"type\": \"tuple[]\", \"components\": [\n            {\"name\": \"to\", \"type\": \"string\"},\n            {\"name\": \"amount\", \"type\": \"uint256\"}\n        ]},\n        {\"name\": \"data\", \"type\": \"bytes\"}\n    ]\n}\n</code></pre> <p>Inputs:</p> <ul> <li>lockId - the lock ID assigned when the value was locked (available from the domain receipt for the <code>lock</code> transaction)</li> <li>from - the lookup string for the owner of the locked value</li> <li>recipients - array of recipients to receive some of the value (the sum of the amounts must be less than or equal to the total locked amount)</li> <li>data - user/application data to include with the transaction (will be accessible from an \"info\" state in the state receipt)</li> </ul>"},{"location":"architecture/noto/#prepareunlock","title":"prepareUnlock","text":"<p>Prepare to unlock value that was previously locked. This method is identical to <code>unlock</code> except that it will not actually perform the unlock - it will only check that the unlock is valid, and will record a hash of the prepared unlock operation against the lock.</p> <p>When used in combination with <code>delegateLock</code>, this can allow any base ledger address (including other smart contracts) to finalize and execute an unlock that was already approved by the notary.</p> <pre><code>{\n    \"name\": \"prepareUnlock\",\n    \"type\": \"function\",\n    \"inputs\": [\n        {\"name\": \"lockId\", \"type\": \"bytes32\"},\n        {\"name\": \"from\", \"type\": \"string\"},\n        {\"name\": \"recipients\", \"type\": \"tuple[]\", \"components\": [\n            {\"name\": \"to\", \"type\": \"string\"},\n            {\"name\": \"amount\", \"type\": \"uint256\"}\n        ]},\n        {\"name\": \"data\", \"type\": \"bytes\"}\n    ]\n}\n</code></pre> <p>Inputs:</p> <ul> <li>lockId - the lock ID assigned when the value was locked (available from the domain receipt)</li> <li>from - the lookup string for the owner of the locked value</li> <li>recipients - array of recipients to receive some of the value (the sum of the amounts must be less than or equal to the total locked amount)</li> <li>data - user/application data to include with the transaction (will be accessible from an \"info\" state in the state receipt)</li> </ul>"},{"location":"architecture/noto/#delegatelock","title":"delegateLock","text":"<p>Appoint another address as the delegate that can execute a prepared unlock operation.</p> <p>Once the lock has been delegated, the notary and the lock creator can no longer interact with the locked states, until the delegate invokes the public ABI to either 1) trigger the unlock or 2) re-delegate the lock to a different address. Delegation can be cancelled if the current delegate re-delegates to the zero address.</p> <pre><code>{\n    \"name\": \"delegateLock\",\n    \"type\": \"function\",\n    \"inputs\": [\n        {\"name\": \"lockId\", \"type\": \"bytes32\"},\n        {\"name\": \"unlock\", \"type\": \"tuple\", \"components\": [\n            {\"name\": \"lockedInputs\", \"type\": \"bytes32[]\"},\n            {\"name\": \"lockedOutputs\", \"type\": \"bytes32[]\"},\n            {\"name\": \"outputs\", \"type\": \"bytes32[]\"},\n            {\"name\": \"signature\", \"type\": \"bytes\"},\n            {\"name\": \"data\", \"type\": \"bytes\"}\n        ]},\n        {\"name\": \"delegate\", \"type\": \"address\"},\n        {\"name\": \"data\", \"type\": \"bytes\"}\n    ]\n}\n</code></pre> <p>Inputs:</p> <ul> <li>lockId - the lock ID assigned when the value was locked (available from the domain receipt)</li> <li>unlock - the parameters for the public <code>unlock</code> transaction that was prepared and is now being delegated (available from the domain receipt for the <code>prepareUnlock</code> transaction)</li> <li>delegate - the address that will be allowed to trigger the prepared unlock</li> <li>data - user/application data to include with the transaction (will be accessible from an \"info\" state in the state receipt)</li> </ul>"},{"location":"architecture/noto/#public-abi","title":"Public ABI","text":"<p>The public ABI of Noto is implemented in Solidity by Noto.sol, and can be accessed by calling <code>ptx_sendTransaction</code> with <code>\"type\": \"public\"</code>. However, it is not often required to invoke the public ABI directly.</p>"},{"location":"architecture/noto/#mint_1","title":"mint","text":"<p>Mint new UTXO states. Generally should not be called directly.</p> <p>May only be invoked by the notary address.</p> <pre><code>{\n    \"name\": \"mint\",\n    \"type\": \"function\",\n    \"inputs\": [\n        {\"name\": \"outputs\", \"type\": \"bytes32[]\"},\n        {\"name\": \"signature\", \"type\": \"bytes\"},\n        {\"name\": \"data\", \"type\": \"bytes\"}\n    ]\n}\n</code></pre> <p>Inputs:</p> <ul> <li>outputs - output states that will be created</li> <li>signature - sender's signature (not verified on-chain, but can be verified by anyone with the private state data)</li> <li>data - encoded Paladin and/or user data</li> </ul>"},{"location":"architecture/noto/#transfer_1","title":"transfer","text":"<p>Spend some UTXO states and create new ones. Generally should not be called directly.</p> <p>May only be invoked by the notary address.</p> <pre><code>{\n    \"name\": \"transfer\",\n    \"type\": \"function\",\n    \"inputs\": [\n        {\"name\": \"inputs\", \"type\": \"bytes32[]\"},\n        {\"name\": \"outputs\", \"type\": \"bytes32[]\"},\n        {\"name\": \"signature\", \"type\": \"bytes\"},\n        {\"name\": \"data\", \"type\": \"bytes\"}\n    ]\n}\n</code></pre> <p>Inputs:</p> <ul> <li>inputs - input states that will be spent</li> <li>outputs - output states that will be created</li> <li>signature - sender's signature (not verified on-chain, but can be verified by anyone with the private state data)</li> <li>data - encoded Paladin and/or user data</li> </ul>"},{"location":"architecture/noto/#approvetransfer_1","title":"approveTransfer","text":"<p>Approve a specific <code>transfer</code> transaction to be executed by a specific <code>delegate</code> address. Generally should not be called directly.</p> <p>The <code>txhash</code> should be computed as the EIP-712 hash of the intended transfer, using type: <code>Transfer(bytes32[] inputs,bytes32[] outputs,bytes data)</code>.</p> <p>May only be invoked by the notary address.</p> <pre><code>{\n    \"name\": \"approveTransfer\",\n    \"type\": \"function\",\n    \"inputs\": [\n        {\"name\": \"delegate\", \"type\": \"address\"},\n        {\"name\": \"txhash\", \"type\": \"bytes32\"},\n        {\"name\": \"signature\", \"type\": \"bytes\"},\n        {\"name\": \"data\", \"type\": \"bytes\"}\n      ]\n}\n</code></pre> <p>Inputs:</p> <ul> <li>delegate - address of the delegate party that will be able to execute this transaction once approved</li> <li>txhash - EIP-712 hash of the intended transfer, using type <code>Transfer(bytes32[] inputs,bytes32[] outputs,bytes data)</code></li> <li>signature - sender's signature (not verified on-chain, but can be verified by anyone with the private state data)</li> <li>data - encoded Paladin and/or user data</li> </ul>"},{"location":"architecture/noto/#transferwithapproval","title":"transferWithApproval","text":"<p>Execute a transfer that was previously approved.</p> <p>The values of <code>inputs</code>, <code>outputs</code>, and <code>data</code> will be used to (re-)compute a <code>txhash</code>, which must exactly match a <code>txhash</code> that was previously delegated to the sender via <code>approveTransfer</code>.</p> <pre><code>{\n    \"name\": \"transferWithApproval\",\n    \"type\": \"function\",\n    \"inputs\": [\n        {\"name\": \"inputs\", \"type\": \"bytes32[]\"},\n        {\"name\": \"outputs\", \"type\": \"bytes32[]\"},\n        {\"name\": \"signature\", \"type\": \"bytes\"},\n        {\"name\": \"data\", \"type\": \"bytes\"}\n      ]\n}\n</code></pre> <p>Inputs:</p> <ul> <li>inputs - input states that will be spent</li> <li>outputs - output states that will be created</li> <li>signature - sender's signature (not verified on-chain, but can be verified by anyone with the private state data)</li> <li>data - encoded Paladin and/or user data</li> </ul>"},{"location":"architecture/noto/#lock_1","title":"lock","text":"<p>Lock some UTXO states. Generally should not be called directly.</p> <p>May only be invoked by the notary address.</p> <pre><code>{\n    \"name\": \"lock\",\n    \"type\": \"function\",\n    \"inputs\": [\n        {\"name\": \"inputs\", \"type\": \"bytes32[]\"},\n        {\"name\": \"outputs\", \"type\": \"bytes32[]\"},\n        {\"name\": \"lockedOutputs\", \"type\": \"bytes32[]\"},\n        {\"name\": \"signature\", \"type\": \"bytes\"},\n        {\"name\": \"data\", \"type\": \"bytes\"}\n    ]\n}\n</code></pre> <p>Inputs:</p> <ul> <li>inputs - input states that will be spent</li> <li>outputs - unlocked output states that will be created</li> <li>lockedOutputs - locked output states that will be created</li> <li>signature - sender's signature (not verified on-chain, but can be verified by anyone with the private state data)</li> <li>data - encoded Paladin and/or user data</li> </ul>"},{"location":"architecture/noto/#unlock_1","title":"unlock","text":"<p>Unlock some UTXO states. May be invoked by the notary in response to a private <code>unlock</code> transaction, but may also be called directly on the public ABI when an unlock operation has been prepared and delegated via <code>prepareUnlock</code> and <code>delegateLock</code>.</p> <pre><code>{\n    \"name\": \"unlock\",\n    \"type\": \"function\",\n    \"inputs\": [\n        {\"name\": \"lockedInputs\", \"type\": \"bytes32[]\"},\n        {\"name\": \"lockedOutputs\", \"type\": \"bytes32[]\"},\n        {\"name\": \"outputs\", \"type\": \"bytes32[]\"},\n        {\"name\": \"signature\", \"type\": \"bytes\"},\n        {\"name\": \"data\", \"type\": \"bytes\"}\n    ]\n}\n</code></pre> <p>Inputs:</p> <ul> <li>lockedInputs - locked input states that will be spent</li> <li>lockedOutputs - locked output states that will be created</li> <li>outputs - unlocked output states that will be created</li> <li>signature - sender's signature (not verified on-chain, but can be verified by anyone with the private state data)</li> <li>data - encoded Paladin and/or user data</li> </ul>"},{"location":"architecture/noto/#prepareunlock_1","title":"prepareUnlock","text":"<p>Record the hash of a prepared unlock operation. Generally should not be called directly.</p> <p>May only be invoked by the notary address.</p> <pre><code>{\n    \"name\": \"prepareUnlock\",\n    \"type\": \"function\",\n    \"inputs\": [\n        {\"name\": \"lockedInputs\", \"type\": \"bytes32[]\"},\n        {\"name\": \"unlockHash\", \"type\": \"bytes32\"},\n        {\"name\": \"signature\", \"type\": \"bytes\"},\n        {\"name\": \"data\", \"type\": \"bytes\"}\n    ]\n}\n</code></pre> <p>Inputs:</p> <ul> <li>lockedInputs - locked input states that will be spent</li> <li>unlockHash - EIP-712 hash of the intended unlock, using type <code>Unlock(bytes32[] lockedInputs,bytes32[] lockedOutputs,bytes32[] outputs,bytes data)</code></li> <li>signature - sender's signature (not verified on-chain, but can be verified by anyone with the private state data)</li> <li>data - encoded Paladin and/or user data</li> </ul>"},{"location":"architecture/noto/#delegatelock_1","title":"delegateLock","text":"<p>Appoint another address as the delegate that can execute a prepared unlock operation.</p> <p>May be invoked by the notary in response to a private <code>delegateLock</code> transaction for a lock that is not yet delegated. May also be called directly on the public ABI by the current delegate, to re-delegate to a new address. Delegation can be cancelled if the current delegate re-delegates to the zero address.</p> <pre><code>{\n    \"name\": \"delegateLock\",\n    \"type\": \"function\",\n    \"inputs\": [\n        {\"name\": \"unlockHash\", \"type\": \"bytes32\"},\n        {\"name\": \"delegate\", \"type\": \"address\"},\n        {\"name\": \"signature\", \"type\": \"bytes\"},\n        {\"name\": \"data\", \"type\": \"bytes\"}\n    ]\n}\n</code></pre> <p>Inputs:</p> <ul> <li>unlockHash - EIP-712 hash of the prepared unlock, using type <code>Unlock(bytes32[] lockedInputs,bytes32[] lockedOutputs,bytes32[] outputs,bytes data)</code></li> <li>delegate - address of the delegate party that will be able to execute the unlock</li> <li>signature - sender's signature (not verified on-chain, but can be verified by anyone with the private state data)</li> <li>data - encoded Paladin and/or user data</li> </ul>"},{"location":"architecture/noto/#balanceof","title":"balanceOf","text":"<p>Returns the balance information for a specified account. This function provides a quick balance check but is limited to processing up to 1000 states and is not intended to replace the role of a proper indexer for comprehensive balance tracking.</p> <pre><code>{\n  \"type\": \"function\",\n  \"name\": \"balanceOf\",\n  \"inputs\": [\n    {\n      \"name\": \"account\",\n      \"type\": \"string\"\n    }\n  ],\n  \"outputs\": [\n    {\n      \"name\": \"totalStates\",\n      \"type\": \"uint256\"\n    },\n    {\n      \"name\": \"totalBalance\",\n      \"type\": \"uint256\"\n    },\n    {\n      \"name\": \"overflow\",\n      \"type\": \"bool\"\n    }\n  ]\n}\n</code></pre> <p>Inputs:</p> <ul> <li>account - lookup string for the identity to query the balance for</li> </ul> <p>Outputs:</p> <ul> <li>totalStates - number of unspent UTXO states found for the account</li> <li>totalBalance - sum of all unspent UTXO values for the account</li> <li>overflow - indicates if there are at least 1000 states available (true means the returned balance may be incomplete)</li> </ul> <p>Note: This function is limited to querying up to 1000 states and should not be used as a replacement for proper indexing infrastructure.</p>"},{"location":"architecture/noto/#notary-logic","title":"Notary logic","text":"<p>The notary logic (implemented in the domain Go library) is responsible for validating and submitting all transactions to the base shared ledger.</p> <p>The notary will validate the following:</p> <ul> <li>Request Authenticity: Each request to the notary will be accompanied by an EIP-712 signature from the sender,   which is validated by the notary. This prevents any identity from impersonating another when submitting requests.</li> <li>State Validity: Each request will be accompanied by a proposed set of input and output UTXO states assembled   by the sending node. The notary checks that these states would be a valid expression of the requested operation -   for example, a \"transfer\" must be accompanied by inputs owned only by the \"from\" address, outputs owned by the   \"to\" address matching the desired transfer amount, and optionally some remainder outputs owned by the \"from\" address.   Note the distinction here of states that would be valid - as final validation of spent/unspent state IDs will   be provided by the base ledger.</li> <li>Conservation of Value: For most operations (other than mint and burn), the notary will ensure that the sum   of the inputs and of the outputs is equal.</li> </ul> <p>The above constraints cannot be altered without changing the library code. However, many other aspects of the notary logic can be easily configured as described below.</p>"},{"location":"architecture/noto/#notary-mode-basic","title":"Notary mode: basic","text":"<p>When a Noto contract is constructed with notary mode <code>basic</code>, the following notary behaviors can be configured:</p> Option Default Description restrictMint true True: only the notary may mintFalse: any party may mint allowBurn true True: token owners may burn their tokensFalse: tokens cannot be burned allowLock true True: token owners may lock tokens (for purposes such as preparing or delegating transfers)False: tokens cannot be locked (not recommended, as it restricts the ability to incorporate tokens into swaps and other workflows) <p>In addition, the following restrictions will always be enforced, and cannot be disabled in <code>basic</code> mode:</p> <ul> <li>Unlock: Only the creator of a lock may unlock it.</li> </ul>"},{"location":"architecture/noto/#notary-mode-hooks","title":"Notary mode: hooks","text":"<p>When a Noto contract is constructed with notary mode <code>hooks</code>, the address of a private Pente contract implementing INotoHooks must be provided. This contract may be deployed into a privacy group only visible to the notary, or into a group that includes other parties for observability.</p> <p>The relevant hook will be invoked for each Noto operation, allowing the contract to determine if the operation is allowed, and to trigger any additional custom policies and side-effects. Hooks can even be used to track Noto token movements in an alternate manner, such as representing them as a private ERC-20 or other Ethereum token.</p> <p>Each hook should have one of two outcomes:</p> <ul> <li>If the operation is allowed, the hook should emit <code>PenteExternalCall</code> with the prepared Noto transaction details,   to allow the Noto transaction to be confirmed.</li> <li>If the operation is not allowed, the hook should revert.</li> </ul> <p>Failure to trigger one of these two outcomes will result in undefined behavior.</p> <p>The <code>msg.sender</code> for each hook transaction will always be the resolved notary address, but each hook will also receive a <code>sender</code> parameter representing the resolved and verified party that sent the request to the notary.</p> <p>Important</p> <p>Note that none of the <code>basic</code> notary constraints described in the previous section will be active when hooks are configured. It is the responsibility of the hooks to enforce policies, such as which senders are allowed to mint, burn, lock, unlock, etc.</p>"},{"location":"architecture/noto/#transaction-walkthrough","title":"Transaction walkthrough","text":"<p>Walking through a simple token transfer scenario, where Party A has some fungible tokens, transfers some to Party B, who then transfers some to Party C.</p> <p>No information is leaked to Party C, that allows them to infer that Party A and Party B previously transacted.</p> <p></p> <ol> <li><code>Party A</code> has three existing private states in their wallet and proposes to the notary:<ul> <li>Spend states <code>S1</code>, <code>S2</code> &amp; <code>S3</code></li> <li>Create new state <code>S4</code> to retain some of the fungible value for themselves</li> <li>Create new state <code>S5</code> to transfer some of the fungible value to <code>Party B</code></li> </ul> </li> <li><code>Notary</code> receives the signed proposal from <code>Party A</code><ul> <li>Validates that the rules of the token ecosystem are fully adhered to</li> <li>Example: <code>sum(S1,S2,S3) == sum(S4,S5)</code></li> <li>Example: <code>Party B</code> is authorized to receive funds</li> <li>Example: The total balance of <code>Party A</code> will be above a threshold after the transaction</li> <li>Uses the notary account to submit <code>TX1</code> to the blockchain recording signature + hashes</li> </ul> </li> <li><code>Party B</code> processes the two parts of the transaction<ul> <li>a) Receives the private data for <code>#5</code> to allow it to store <code>S5</code> in its wallet</li> <li>b) Receives the confirmation from the blockchain that <code>TX1</code> created <code>#5</code></li> <li>Now <code>Party B</code> has <code>S5</code> confirmed in its wallet and ready to spend</li> </ul> </li> <li><code>Party B</code> proposes to the notary:<ul> <li>Spend state <code>S5</code></li> <li>Create new state <code>S6</code> to retain some of the fungible value for themselves</li> <li>Create new state <code>S7</code> to transfer some of the fungible value to <code>Party C</code></li> </ul> </li> <li><code>Notary</code> receives the signed proposal from <code>Party B</code><ul> <li>Validates that the rules of the token ecosystem are fully adhered to</li> <li>Uses the notary account to submit <code>TX2</code> to the blockchain recording signature + hashes</li> </ul> </li> <li><code>Party C</code> processes the two parts of the transaction<ul> <li>a) Receives the private data for <code>#7</code> to allow it to store <code>S7</code> in its wallet</li> <li>b) Receives the confirmation from the blockchain that <code>TX2</code> created <code>#7</code></li> <li>Now <code>Party C</code> has <code>S7</code> confirmed in its wallet and ready to spend</li> </ul> </li> </ol>"},{"location":"architecture/overview/","title":"Paladin","text":"<p>Paladin is a privacy preserving transaction manager for Ethereum.</p>"},{"location":"architecture/overview/#architecture-overview","title":"Architecture overview","text":"<ul> <li>Paladin is a sidecar process that runs alongside a Hyperledger Besu node<ul> <li>Learn more about Runtime Architecture</li> </ul> </li> <li>Paladin provides secure channels of communication to other Paladins over which it can selectively disclose private data<ul> <li>Learn more about Private Data Transports &amp; Endpoint Registry</li> </ul> </li> <li>Paladin supports Privacy Preserving Smart Contracts, and provides samples out-of-the-box<ul> <li>Each smart contract has a part of that runs as a EVM smart contract on an unmodified EVM blockchain, and a part that runs as part of Paladin</li> <li>Learn more about ledger layers</li> <li>Some implement <code>tokens backed by Zero-knowledge Proofs</code></li> <li>Learn more about Zeto</li> <li>Some implement <code>tokens backed by Notary Certificates</code> (issuer/signatory endorsed tokens)</li> <li>Learn more about Noto</li> <li>Some implement domains of <code>EVM Private Smart Contracts</code> running in <code>Privacy Groups</code> </li> <li>Learn more about Pente <p>Provides function similar to that provided by the Tessera project (successor to Constellation) with additional interoperability and other enhancements</p> </li> <li>All use the EVM base ledger as the source of truth for order and finality of transactions</li> <li>All are <code>atomically interoperable</code> via the base EVM ledger</li> <li>Learn more about Atomic interop of privacy preserving smart contracts</li> <li>All store state in the EVM base ledger in a securely masked format preserving<ul> <li>Confidentiality: the data is protected via cryptography, and selectively disclosed on a need to know basis</li> <li>Anonymity: the parties involved in a transaction, or set of transactions, cannot be determined without access to the confidential data</li> <li>Learn more about Privacy</li> </ul> </li> </ul> </li> <li>Paladin provides a high performance transaction manager that coordinates transaction assembly, submission and confirmation across Paladin runtimes<ul> <li>To any EVM smart contract directly on the base EVM ledger</li> <li>To EVM Private Smart Contracts in privacy groups, backed by privacy preserving smart contracts</li> <li>To Privacy Preserving Smart Contracts that use UTXO models for highly scalable private tokens</li> <li>For atomic swaps between privacy preserving smart contracts</li> <li>Learn more about Distributed transaction management </li> </ul> </li> <li>Paladin provides enterprise grade key management integration<ul> <li>Managing many keys/identities within a single Paladin runtime</li> <li>With modular integration of remote HSM-backed key management systems</li> <li>Supporting native Ethereum, EIP-712, and ZKP compatible cryptography</li> <li>Learn more about Signing and Key Management </li> </ul> </li> <li>Paladin provides a development, configuration, and deployment pipeline for privacy preserving smart contracts<ul> <li>Definition of the smart contract functions, inputs and events</li> <li>Supporting EVM programmable private smart contracts and UTXO based token models</li> <li>A set of gRPC code plug points for private lifecycle coordination and state management<ul> <li>Programming wallet functions - coin/state selection</li> <li>Programming endorsement coordination / signature collection / sequencer selection</li> <li>Programming transaction verification &amp; proof generation</li> </ul> </li> <li>Support for <code>Java</code> and <code>WebAssembly</code> high performance code modules</li> <li>Learn more about the Paladin programming model</li> </ul> </li> </ul>"},{"location":"architecture/pente/","title":"Pente - Private EVM Smart Contracts","text":"<p>EVM Smart Contracts are built in programming languages like Solidity and Vyper, and execute as code installed into an Ethereum <code>Account</code>.</p> <p>In an EVM base ledger blockchain, there is a single world state that all smart contracts are operating on. All state for all accounts exist in this one global state, at one global version.</p> <p>The world moves forwards block-by-block.</p> <p>Pente is a privacy preserving smart contract for Paladin, which provides a different model for Private EVM Smart Contracts, where many worlds can exist isolated from each other all validated by the same shared ledger.</p> <p>Each smart contract is its own world state.</p> <p></p> <ul> <li>Private smart contracts exists uniquely within a privacy group</li> <li>The transactions are confirmed by spending UTXO states on the base EVM ledger</li> <li>The data required for each transition is confidential</li> <li>These state transitions can be verified as part of atomic transactions with other tokens</li> </ul>"},{"location":"architecture/pente/#history-of-evm-private-smart-contracts","title":"History of EVM Private Smart Contracts","text":"<p>The concept of Private EVM Smart Contracts is not new.</p> <p>In Nov 2016 the first implementation was released called Constellation, attributed to Samer Falah, Patrick Mylund Nielsen and others at JP Morgan Chase.</p> <p>This combined a modified version of Go-ethereum (as part of the Quorum project) with a Haskell based private transaction manager.</p> <p>In this model specially identified (though modified <code>V</code> values) private transactions were recorded in-line with public transactions in the same blocks, after all parties that were included in the private transactions were previously notified of the inputs to those private transactions.</p> <p>When the block was confirmed by a node which already had the private input data, it would process the private transaction. Other nodes would skip the transaction, assuming they were not a party to it.</p> <p>This model was evolved through a number of updates over the years, most significantly:</p> <ul> <li>The re-building of the Constellation (Haskell) private state management runtime in Java:<ul> <li>Orion: Started in 2019, abandoned in Sep 2021</li> <li>Tessera: Started in 2018, deprecated in 2024</li> </ul> </li> <li>Support for private smart contract submission in Hyperledger Besu (additional to Quorum)<ul> <li>The modification to the base EVM was reduced, by avoiding modification of the <code>V</code> value of transactions, and rather using a special pre-compiled smart contract address</li> <li>A different approach to Private transaction nonce management was adopted in Besu, where a separate nonce is managed in each privacy group</li> </ul> </li> <li>Quorum added \"Private state validation\" (not supported in Besu)<ul> <li>Provides a validation mode that helps ensure that all transactions for a given private smart contract are always sent to the same participants</li> </ul> </li> </ul> <p>However, the model has not fundamentally changed in this time.</p> <p>Read here about the Private transaction lifecycle for Quorum and Besu when used with the Tessera private transaction manager.</p>"},{"location":"architecture/pente/#problems-with-the-previous-models","title":"Problems with the previous models","text":"<p>There are two closely related problems with the EVM Private Smart Contract model as implemented in these generations of the technology.</p> <ol> <li>When used correctly, state is locked inside of a Private Smart Contract<ul> <li>This is fundamental to the programming model of EVM. A Smart Contract holds a single and complete set of state, visible to all parties in the privacy group.</li> <li>Transacting across smart contracts is problematic</li> <li>Implementing something like an ERC-20/ERC-721 token does not make sense in many scenarios, as the token can never be traded outside of the privacy group (noting that private positions modelled with ERC-20 tokens are a good exception to this statement)</li> </ul> </li> <li>The system does not provide feedback when this model is broken, intentionally, or via an operational/system error<ul> <li>Because only the inputs are recorded to the blockchain for each transaction, via hash, and private smart contracts share a global address space, it is possible to have multiple overlapping sets of privacy groups transacting against the same smart contract</li> <li>This means the states diverge so there is no single source of truth of the state of the private smart contract. Different parties have different data. So the fundamental assurances of a Smart Contract of agreed computation are not net.</li> <li>The \"Private state validation\" feature (Quorum only) was a step towards solving this issue, by preventing mis-use of private smart contracts across different privacy groups.</li> <li>Read more about these challenges here</li> </ul> </li> </ol>"},{"location":"architecture/pente/#paladin-privacy-groups","title":"Paladin privacy groups","text":"<p>The Pente domain uses the state management engine of Paladin to improve upon the existing model.</p> <p>Pre-submission endorsement of the full transaction execution is performed, combined with on-chain signature verification of the commitments to the input and output states, and double-spend protection on the account states enforced on-chain.</p> <p></p>"},{"location":"architecture/pente/#on-chain-state-verification","title":"On-chain state verification","text":"<p>The guiding principals are:</p> <ul> <li>On-chain transactions on the base EVM are the source of truth<ul> <li>Every transaction execution is enforced on-chain, via threshold signature verification</li> <li>Pre-verification / endorsement of transactions happens off-chain prior to submission</li> <li>The exact signed transaction, inputs and outputs, are verified &amp; signed by endorsers</li> <li>The transaction and execution result are masked as <code>commitments</code> on-chain<ul> <li>Salted hashes of the signed input transaction, and input/output/read account states</li> </ul> </li> </ul> </li> <li>No modification to the base EVM<ul> <li>No <code>V</code> value changes</li> <li>No special execution during block execution / confirmation</li> <li>The base EVM ledger transaction is a pure EVM transaction</li> </ul> </li> <li>Each privacy group is a unique EVM smart contact on the base ledger<ul> <li>Private Smart Contract exists entirely within a privacy group</li> <li>A privacy group is just like a mini-blockchain, hosted inside of one smart contract</li> </ul> </li> <li>Submitter account and nonce management is managed within each privacy group<ul> <li>Accounts are UTXO states stored in this contract<ul> <li>Externally owned accounts (EOAs)</li> <li>Contract accounts</li> </ul> </li> <li>State/code/nonce transitions are all deterministic</li> <li>Endorsements of exact transitions are verified on-chain via EIP-712 signatures</li> </ul> </li> <li>Besu EVMs are used to pre-execute EVM transactions<ul> <li>Just the EVM is loaded as a Java code module, on-demand when required</li> <li>These \"ephemeral EVMs\" are executed in the Paladin runtime<ul> <li>There is no requirement for a local Besu runtime co-located with Paladin</li> </ul> </li> <li>State is managed via the UTXO state storage of Paladin<ul> <li>No use is made of the Bonsai/Forrest state store of Besu</li> </ul> </li> </ul> </li> <li>Private Smart Contract transactions are atomically interoperable via the Paladin framework<ul> <li>This is the single most important enhancement. Because Pente is just another privacy preserving smart contract in Paladin, it can atomically interoperate with Token smart contracts. </li> <li>See the Atomic Interop section for how this enables sophisticated DvP scenarios to be programmed via Private EVM</li> </ul> </li> </ul>"},{"location":"architecture/pente/#implementation","title":"Implementation","text":"<p>The Pente private domain is implemented in Java using the Besu EVM as a code module to start and run ephemeral in-memory EVMs.</p>"},{"location":"architecture/pente/#submitting-transactions","title":"Submitting transactions","text":"<p>The recommended way to submit transactions is to:</p> <ol> <li>Create a privacy group using the pgroup_createGroup JSON/RPC API<ul> <li>This distributes information about the privacy group off-chain to all members</li> <li>You can add properties to your privacy group to allow all members to find it (a business transaction identifier for example)</li> </ul> </li> <li>Wait for a receipt to the transaction returned in the PrivacyGroup<ul> <li>This means that the blockchain has confirmed creation of the privacy group</li> </ul> </li> <li>Submit transactions using the pgroup_sendTransaction JSON/RPC API<ul> <li>The PrivacyGroupEVMTXInput payload is as similar to a normal <code>eth_sendTransaction</code> payload as possible</li> <li>Deployment of smart contracts is performed by omitting the <code>to</code> address, and supplying <code>bytecode</code></li> </ul> </li> <li>Use WebSockets combined with TransactionReceiptListener to detect transaction completion<ul> <li>This is a reliable ordered delivery system</li> <li>Use <code>incompleteStateReceiptBehavior: \"block_contract</code> to ensure you receive receipts in order for each privacy group</li> </ul> </li> <li>Decode the receipts using ptx_getDomainReceipt<ul> <li>Decodes the full EVM receipt format with <code>logs</code> (EVM emitted events) from the private states of the transaction</li> </ul> </li> <li>Make calls to query data using pgroup_call JSON/RPC API<ul> <li>The PrivacyGroupEVMCall payload is as similar to a normal <code>eth_call</code> payload as possible</li> <li>The result is decoded for you against the ABI you supply</li> </ul> </li> </ol>"},{"location":"architecture/pente/#private-messaging","title":"Private messaging","text":"<p>Privacy groups also allow you to send private messages that are completely off-chain, to distribute information without the latency (and gas) overhead of mining a blockchain transaction.</p> <p>There are no ordering or non-repudiation guarantees when doing this, as the shared ordering context and transaction signature (+execution) verification of a full EVM blockchain transaction are bypassed.</p> <p>See pgroup_sendMessage for more details of sending messages.</p> <p>Use WebSockets combined with PrivacyGroupMessageListener to listen for messages.</p> <p>The lifecycle JSON/RPC APIs over the websocket are the same as TransactionReceiptListener</p>"},{"location":"architecture/pente/#raw-private-abi","title":"Raw Private ABI","text":"<p>When you look at the resulting private transactions submitted through the privacy group, you will see that the original inputs are wrapped to instruct the Pente privacy group what to do inside of the Private EVM.</p> <p>The <code>to</code> and <code>inputs</code> (as well as <code>gas</code>,<code>value</code> and <code>bytecode</code> if supplied) are nested inside of this containing ABI, as they will not be the same as the public transaction that is submitted to the containing (public/permissioned) EVM blockchain that backs the privacy group.</p> <pre><code>{\n    \"name\": \"&lt;variable - see below&gt;\",\n    \"type\": \"function\",\n    \"inputs\": [\n        {\"name\": \"group\", \"type\": \"tuple\", \"components\": [\n            {\"name\": \"salt\", \"type\": \"bytes32\"},\n            {\"name\": \"members\", \"type\": \"string[]\"}\n        ]},\n        {\"name\": \"to\", \"type\": \"address\"},\n        {\"name\": \"inputs\", \"type\": \"tuple\", \"components\": [\n            // variable - see below\n        ]}\n    ]\n    {\"name\": \"outputs\", \"type\": \"tuple\", \"components\": [\n        // variable - see below\n    ]}\n}\n</code></pre> <p>Inputs:</p> <ul> <li>group - group details, including member lookup strings and a randomly-chosen group salt (must exactly match what was passed at group creation, as stored inside of the genesis state of the PrivacyGroup)</li> <li>to - the address of the private contract</li> <li>inputs - ABI method inputs for the contract (must be filled in to match the contract)</li> </ul> <p>Other fields:</p> <ul> <li>name - name of the method to invoke on the contract, or the special <code>deploy</code> function for performing a deploy with <code>bytecode</code></li> <li>outputs - ABI method outputs for the contract (only valid for <code>ptx_call</code>, must be filled in to match the contract).</li> </ul>"},{"location":"architecture/pente/#public-abi","title":"Public ABI","text":"<p>The public ABI of Pente is implemented in Solidity by PentePrivacyGroup.sol, and can be accessed by calling <code>ptx_sendTransaction</code> with <code>\"type\": \"public\"</code>. However, it is not often required to invoke the public ABI directly.</p>"},{"location":"architecture/pente/#transition","title":"transition","text":"<p>Transition the world state of this privacy group. Generally should not be called directly.</p> <pre><code>{\n    \"name\": \"transition\",\n    \"type\": \"function\",\n    \"inputs\": [\n        {\"name\": \"txId\", \"type\": \"bytes32\"},\n        {\"name\": \"states\", \"type\": \"tuple\", \"components\": [\n            {\"name\": \"inputs\", \"type\": \"bytes32[]\"},\n            {\"name\": \"reads\", \"type\": \"bytes32[]\"},\n            {\"name\": \"outputs\", \"type\": \"bytes32[]\"},\n            {\"name\": \"info\", \"type\": \"bytes32[]\"}\n        ]},\n        {\"name\": \"externalCalls\", \"type\": \"tuple[]\", \"components\": [\n            {\"name\": \"contractAddress\", \"type\": \"address\"},\n            {\"name\": \"encodedCall\", \"type\": \"bytes\"}\n        ]},\n        {\"name\": \"signatures\", \"type\": \"bytes[]\"}\n    ]\n}\n</code></pre> <p>Inputs:</p> <ul> <li>txId - Paladin transaction identifier</li> <li>states - list of states (input states will be spent, output states will be created, read states will be verified to exist, and info states will not be checked)</li> <li>externalCalls - list of encoded EVM calls against other external contracts, which will be executed as a side-effect of the transition</li> <li>signatures - EIP-712 signatures from all parties in the privacy group to validate the state transition</li> </ul>"},{"location":"architecture/pente/#approvetransition","title":"approveTransition","text":"<p>Approve a specific <code>transition</code> transaction to be executed by a specific <code>delegate</code> address. Generally should not be called directly.</p> <pre><code>{\n    \"name\": \"approveTransition\",\n    \"type\": \"function\",\n    \"inputs\": [\n        {\"name\": \"txId\", \"type\": \"bytes32\"},\n        {\"name\": \"delegate\", \"type\": \"address\"},\n        {\"name\": \"transitionHash\", \"type\": \"bytes32\"},\n        {\"name\": \"signatures\", \"type\": \"bytes[]\"}\n    ]\n}\n</code></pre> <p>Inputs:</p> <ul> <li>txId - Paladin transaction identifier</li> <li>delegate - address of the delegate party that will be able to execute this transaction once approved</li> <li>transitionHash - EIP-712 hash of the intended transition, using types <code>Transition(bytes32[] inputs,bytes32[] reads,bytes32[] outputs,bytes32[] info,ExternalCall[] externalCalls)</code> and <code>ExternalCall(address contractAddress,bytes encodedCall)</code></li> <li>signatures - EIP-712 signatures from all parties in the privacy group to validate the state transition</li> </ul>"},{"location":"architecture/pente/#transitionwithapproval","title":"transitionWithApproval","text":"<p>Execute a transition that was previously approved.</p> <p>The values of <code>states</code> and <code>externalCalls</code> will be used to (re-)compute a <code>transitionHash</code>, which must exactly match a <code>transitionHash</code> that was previously delegated to the sender via <code>approveTransition</code>.</p> <pre><code>{\n    \"name\": \"transitionWithApproval\",\n    \"type\": \"function\",\n    \"inputs\": [\n        {\"name\": \"txId\", \"type\": \"bytes32\"},\n        {\"name\": \"states\", \"type\": \"tuple\", \"components\": [\n            {\"name\": \"inputs\", \"type\": \"bytes32[]\"},\n            {\"name\": \"reads\", \"type\": \"bytes32[]\"},\n            {\"name\": \"outputs\", \"type\": \"bytes32[]\"},\n            {\"name\": \"info\", \"type\": \"bytes32[]\"}\n        ]},\n        {\"name\": \"externalCalls\", \"type\": \"tuple[]\", \"components\": [\n            {\"name\": \"contractAddress\", \"type\": \"address\"},\n            {\"name\": \"encodedCall\", \"type\": \"bytes\"}\n        ]},\n      ]\n}\n</code></pre> <p>Inputs:</p> <ul> <li>txId - Paladin transaction identifier</li> <li>states - list of states (input states will be spent, output states will be created, read states will be verified to exist, and info states will not be checked)</li> <li>externalCalls - list of encoded EVM calls against other external contracts, which will be executed as a side-effect of the transition</li> </ul>"},{"location":"architecture/programming_model/","title":"Paladin programming model","text":"<p>There are three layers of programmability in Paladin for building privacy preserving smart contracts</p>"},{"location":"architecture/programming_model/#layer-a-base-evm-ledger","title":"Layer A: Base EVM Ledger","text":"<p>Every privacy preserving smart contract is backed by an EVM smart contract, deployed onto the base EVM ledger. The base EVM can be a Hyperledger Besu network, or any EVM compliant ledger (permissioned or public).</p> <p>The code that exists at this layer must not require access to the private data, while fulfilling fundamental responsibilities:</p> <ol> <li>Ensuring every state transition is only finalized by the blockchain if it is validated:<ul> <li>By verifying a zero-knowledge proof, and/or that the transaction was pre-verified</li> </ul> </li> <li>Enforcing double-spend protections<ul> <li>We discuss later how and why a UTXO model is most common in private transactions</li> </ul> </li> <li>Conforming to an interface that allows atomic interop with other smart contracts<ul> <li>Learn more in Atomic interop of privacy preserving smart contracts</li> </ul> </li> </ol>"},{"location":"architecture/programming_model/#zkp-verification-notary-and-endorsement-models","title":"ZKP verification, Notary and Endorsement models","text":"<p>Because the base ledger smart contract cannot access or leak the data involved in the transaction, there are two fundamental approaches to finalization of transactions.</p> <p></p> <ol> <li>The transaction is pre-verified off-chain before submission<ul> <li>The smart contract records the proof of the pre-verification, but cannot directly verify it</li> <li>The identity of the verifier(s) are known and trusted by the parties transacting on that contract</li> <li>The smart contract only allows spending by the authorized notary / endorsement-group</li> <li>Example 1: the issuer of a particular tokenized deposit / digital asset</li> <li>Example 2: the members of a privacy group signing off on every transaction (more on this later)</li> </ul> </li> <li>A zero-knowledge proof is verified during execution of the transaction<ul> <li>The smart contract uses advanced cryptography to verify the rules were obeyed</li> <li>Anyone can submit a transaction, as long as it comes with a suitable proof</li> <li>Example 1: a cash token with total conversation of value and ownership enforced via ZKP</li> <li>Example 2: a non-fungible token with uniqueness and ownership enforced via ZKP</li> </ul> </li> </ol> <p>There are strong reasons why both of these approaches exist - some related to efficiency/performance, and others related to fundamental characteristics of each model. The Paladin project embraces both approaches, and allows them coexist and interoperate atomically.</p> <p>The two approaches can be combined within a single smart contract, for example where simple transfers are allowed to be performed via ZKP alone, whereas onboarding/freezing trading identities, or minting, might require pre-verification.</p> <p>Learn more in the Privacy section.</p>"},{"location":"architecture/programming_model/#base-ledger-evm-development","title":"Base Ledger EVM development","text":"<p>You will need to develop/update EVM smart contracts at this layer, if you have requirements that are not met by existing EVM modules provided with the Paladin project.</p> <p>Examples include:</p> <ul> <li>Making changes to a ZKP based token that require a new or modified circuit design</li> <li>Using a mixture of approaches, such as ZKP for transfer, and notary certificates for issuance</li> <li>Adding a completely new cryptography module to the Paladin project</li> </ul> <p>The diagram below shows the fundamental anatomy of the EVM smart contract. There are a set of standard functions that Paladin uses to coordinate operations with your smart contract, and code that maps these down to EVM state and proof/signature verification functions.</p> <p>TODO: Provide link to detailed developer guidance / samples / instructions</p> <p></p>"},{"location":"architecture/programming_model/#layer-b-private-state-and-transaction-management","title":"Layer B: Private state and transaction management","text":"<p>Because the smart contract in the base ledger is privacy preserving, there must be code that runs outside of the blockchain that is tightly coupled to the EVM code.</p> <p>The two parts work in collaboration to implement the token.</p> <ul> <li>The off-chain part constructs and submits transactions, using private state</li> <li>Selecting valid states for the transaction from off-chain data stores (wallet function)</li> <li>Gathering endorsements / signatures</li> <li>Pre-executing full transaction logic against the full data</li> <li>Building proofs / notarization certificates as required</li> <li>The on-chain part finalizes transactions</li> <li>The EVM smart contract is the source of truth of which state is valid</li> <li>Double spend protection is performed with masked data / inclusion proofs</li> <li>A proof is verified on-chain, or notary certificate is recorded on-chain</li> </ul> <p>We discuss this in more detail in Ledger Layers.</p> <p>The off-chain part of a privacy preserving smart contract cannot assume that any transaction will be successful, until it is finalized by the base ledger.</p>"},{"location":"architecture/programming_model/#confidential-utxo-models","title":"Confidential UTXO models","text":"<p>By definition in a privacy preserving smart contract, the visibility/access to the data is fragmented - each party has a different visibility into the overall data being maintained on the ledger.</p> <p>For this reason globally maintained state (such as \"accounts\") are complex to maintain in the selective disclosure layer. Instead, there is a trend towards treating the data in this layer as lots of independent immutable records of state (fragments of the overall state) that can be salted+hashed to uniquely identify them without disclosing their contents.</p> <p>These states can encrypted and/or distributed selectively only to those parties with a right to see them, and spend them using an Unspent Transaction Output (UTXO) based execution model (built on top of EVM as a programmable ledger).</p> <p>The UTXO model works extremely well for tokens - both fungible value, and non-fungible records of uniqueness and ownership. Because each fragment of value, or unique entry, exists independently and can be constructed into a transaction in isolation, there are benefits to:</p> <ul> <li>Scale &amp; performance: Many transactions can be constructed concurrently by spending different values, without needing to lock/modify a single item (such as a target account balance)</li> <li>This parallelism does require some complexity of transaction and state management that Paladin provides solves in a re-usable across privacy technologies, including ZKP and Notary based approaches</li> <li>Programmability: Complex transactions can be orchestrated on UTXO values that are locked of many different types, backed by different privacy mechanism</li> <li>We will see in Layer C how EVM programmability can be layered back on top to aid complex stateful workflow on top of a C-UTXO model, for the token programmability layer required for token ecosystem use cases such as DvP</li> </ul> <p></p> <p>Note that projects do exist (such as Anonymous Zether) that implement tokens with an account model using advanced cryptography to protect global state. The Paladin architecture supports such models, although at time of writing no project has been onboarded.</p>"},{"location":"architecture/programming_model/#programming-interfaces-for-layer-b","title":"Programming interfaces for Layer B","text":"<p>Paladin provides a modular system for plugging in the off-chain half of your privacy preserving smart contract, if you are building a new one, or customizing one of the pre-built Paladin modules.</p> <p>For more information see the following architecture pages:</p> <ul> <li>UTXO State Store</li> <li>Distributed Transaction Manager</li> <li>Runtime Architecture</li> </ul>"},{"location":"architecture/programming_model/#layer-c-ecosystem-programmability-private-evm","title":"Layer C: Ecosystem programmability (Private EVM)","text":"<p>A special class of privacy preserving smart contract, is one that is designed to provide a layer of programmability between other privacy preserving smart contracts.</p> <p>What better programming model to enable for such programmability, than EVM itself: - Solidity and/or Vyper smart contracts, compiled to standard EVM without modification</p>"},{"location":"architecture/programming_model/#evm-blockchain-programming-model","title":"EVM blockchain programming model","text":"<p>If we recap on the fundamental programming model of an EVM based blockchain, we see it moves a single world state forwards in a set of blocks.</p> <p></p>"},{"location":"architecture/programming_model/#evm-private-smart-contracts-in-privacy-group","title":"EVM Private Smart Contracts in Privacy Group","text":"<p>The same programming model can be replicated many times in a privacy preserving way on a single base ledger, by having a chain of transactions shared within a privacy group.</p> <p></p> <p>As long as all parties of the privacy group pre-verify and endorse all transitions on a private smart contract (a simple 100% endorsement form of consensus) the transitions can be finalized by the blockchain using UTXO states.</p> <ul> <li>Private smart contracts exists uniquely within the privacy group</li> <li>The transactions are confirmed by spending UTXO states on the base EVM ledger</li> <li>The data required for each transition is confidential</li> <li>These state transitions can be verified as part of atomic transactions with other tokens</li> </ul> <p>This is an evolution of the model provided Tessera, and is described in more detail in the Pente architecture section. Including the modes of interaction between private smart contracts executing in the private EVM.</p>"},{"location":"architecture/programming_model/#putting-it-all-together-dvp-and-other-use-cases","title":"Putting it all together: DvP and other use cases","text":"<p>With these three layers of programmability, we now have the tools to provide EVM programming of DvP and other complex use cases, on top of tokens, on top of a single shared EVM ledger.</p> <p>This is because the most powerful aspect of an EVM based privacy stack is that different privacy preserving smart contracts of different types can interoperate atomically on a single shared EVM ledger.</p> <p>For example the following three different privacy preserving smart contracts can coordinate in a single atomic transaction: 1. A fungible ZKP verified token, such as a cash token    - All transactions trusted by all parties in the cash token ecosystem 2. A non-fungible notary verified token, such as a bond certificate    - All transactions trusted by all parties in the bond token ecosystem 3. A fully programmable EVM private smart contract    - Transactions only trusted by parties within the privacy group</p> <p>Each requires a different set of proofs/signatures to execute, but the finalization of all of these can happen in single transaction.</p> <p>Learn more in Atomic interop of privacy preserving smart contracts</p>"},{"location":"architecture/state_store/","title":"UXTO State Store","text":"<p>As discussed in Programming Model each of the privacy preserving smart contract domains of a Paladin runtime has a layer of code that must efficiently access private states.</p> <p>The nature of private states being selectively disclosed, means the model most commonly used to manage the relationships between these states is a the Unspent Transaction Output (UTXO) model.</p> <p>This includes domains like Pente that implement EVM programmability on top of these states, with each UTXO representing the current state of a private EVM smart contract</p> <p></p>"},{"location":"architecture/state_store/#guiding-architectural-principals","title":"Guiding architectural principals","text":"<p>The Paladin architecture is optimized to store and query these selectively disclosed UTXO states efficiently.</p> <p>Some guiding principles that underpin this architecture are as follows:</p> <ol> <li>Domains must be able to query the state store efficiently, and flexibly</li> <li>Data must be hashable in a way it can be attested to on the base blockchain and in zero knowledge proofs</li> <li>Each domain must be able to store completely different data in its private states</li> <li>Web3 solutions primarily use fixed-point arithmetic with large 256bit numbers, rather than floating point</li> <li>States must be self-contained so they can be transmitted between Paladin runtimes efficiently</li> <li>Private state storage must be very reliable, as (unlike the base blockchain) only one party might hold the state</li> <li>States are immutable - per UTXO semantics</li> <li>States might need to be persisted a long time before, or after, the blockchain transactions that confirm or spend them</li> </ol>"},{"location":"architecture/state_store/#architecture","title":"Architecture","text":"<p>Due to the fact that we cannot rely on the consensus algorithm and validators of the base ledger to retain backup copies of private data, Paladin is optimized for enterprise RDBMS systems that provide replicated data storage.</p> <p>Any SQL based RDBMS database is supported, and DDL migrations are provided for various databases. The architecture is flexible such that other fundamental types of storage can be added in the future (NoSQL / document based for example).</p> <p>These types of database provide indexing, sorting and querying facilities alongside resilience. This is important to allow sophisticated state / coin selection algorithms to be run in the domains.</p>"},{"location":"architecture/state_store/#dynamic-indexes-schemas-and-labels","title":"Dynamic indexes: Schemas and Labels","text":"<p>The storage is structured in the SQL layer, so that fast indexed <code>labels</code> can be dynamically applied to <code>states</code> without any change to the table layout in the RDBMS.</p> <p>However, for efficiency in the query system it is important that the list of possible labels, and their data types can be known ahead of time for each state that is stored.</p> <p>To do this a <code>schema</code> must be stored by a domain, before any <code>states</code> are stored.</p> <ul> <li>Schemas are isolated to a domain</li> <li>Schemas are identified by a hash (just like states)</li> <li>A matching schema must exist to receive a state into the Paladin engine</li> </ul>"},{"location":"architecture/state_store/#abi-type-system","title":"ABI Type System","text":"<p>Rather than inventing a new type system for Paladin, we incorporate the well established type system of the Ethereum ecosystem used in the Ethereum Application Binary Interface (ABI).</p> <p>Specifically we support the subset that the ERC-712 <code>TypedData</code> standard accommodates, as this standard fits the model of structured data very closely to what is required for our UTXO states.</p> <p>When creating a schema using an ABI definition (JSON) we: - Require a single type definition of type <code>tuple</code> (not an array, or a function definition) - Require the <code>\"internalType\": \"struct StructName</code> extension of ABI is used to define all <code>tuple</code> names - Use the <code>indexed</code> boolean parameter on the top level type to specify the <code>labels</code> </p> <p>The schema system is pluggable such that other schema types can be plugged in, for example if a domain wished to use JSON Schema with special annotations to describe the data schema and a different hashing.</p>"},{"location":"architecture/state_store/#supported-types","title":"Supported types","text":"<p>The following types can be used in structures, and also as <code>indexed</code> fields that  are available for searching and sorting.</p> <p>This includes supporting 256bit integers, as most coins are implemented using large whole numbers with a designated number of decimals (such as 18).</p> <p>The query syntax supports supplying the values in many different ways (decimal, hex, with/without <code>0x</code> prefix etc.). These are transformed to a standard format for efficient indexed filtering/sorting in the backing SQL database as follows.</p> Type Indexed in the database as <code>string</code> Text <code>bytes1</code> to <code>bytes32</code> Bytes (encoded as hex) <code>bytes</code> Bytes (encoded as hex) <code>uint8</code> to <code>uint63</code> 8 byte signed numbers (note <code>uint64</code> too large in SQL) <code>int8</code> to <code>int64</code> 8 byte signed numbers <code>uint64</code> to <code>uint256</code> 64 character fixed width big-endian hex <code>address</code> Identically to <code>uint160</code> <code>int65</code> to <code>int256</code> 65 character two's compliment hex strings with sign prefix <code>bool</code> The same as <code>int64(0)</code>/<code>int64(1)</code> for <code>false</code>/<code>true</code> <p>Performance tip: Use <code>int64</code> for all numbers that do not require 256bit precision, such as timestamps and whole values. Avoid using <code>uint64</code> - it is the same cost as <code>uint256</code></p>"},{"location":"architecture/state_store/#json-inputoutput","title":"JSON input/output","text":"<p>While we use the ABI type system, and schema definition language, the data itself can come in and out of the Paladin node in JSON format as the primary exchange format for that data.</p> <p>The data itself is stored directly into the database as a blob, so that when it is returned to the domain all values embedded are available - not just those that have been indexed for query.</p> <p>The system uses JSON in the database (mainly to make debugging easy vs. a binary format like ABI+RLP), but it re-serializes it according to the ABI schema. This means that:</p> <ol> <li>No fields that are not included in the <code>TypedData</code> are included</li> <li>Consistent formatting of values like numbers (strings in decimal) and bytes (hex with <code>0x</code> prefix)</li> </ol> <p>Domains can be coded to expect their JSON data to be standardized in this way, and do not need to worry about the various ways end-users might supply logically equivalent data.</p>"},{"location":"architecture/state_store/#hashing","title":"Hashing","text":"<p>In addition to following the ABI / EIP-712 type system, we also use the EIP-712 <code>hashStruct(message)</code> algorithm (specifically Version 4 of that algorithm) to deterministically generate a hash for the data.</p>"},{"location":"architecture/state_store/#query-language","title":"Query language","text":"<p>The query language is flexible, with access to the full power of the SQL query system.</p> <p>TODO: Provide some more detail on the semantics of this JSON - probably in a reference section, rather than architecture as this is externalized on JSON/RPC</p> <pre><code>{\n  \"gte\": [{\n    \"field\": \"amount\",\n    \"value\": \"12300000000000000000\"\n  }],\n  \"or\": [\n    { \"in\": [\n      {\n        \"field\": \"color\",\n        \"values\": [\"red\",\"blue\"]\n      }\n    ]},\n    { \"eq\": [\n      {\n        \"field\": \"isSpecial\",\n        \"value\": true\n      }\n    ]}\n  ],\n  \"sort\": [ \"amount ASC\", \".created DESC\" ]\n}\n</code></pre>"},{"location":"architecture/transaction_manager/","title":"Distributed Transaction Manager","text":"<p>The core function of the Paladin runtime, is to operate as a distributed transaction manager:</p> <ul> <li>Receiving API requests from applications to request new transaction submission</li> <li>Integrating with the privacy preserving smart contract code modules to orchestrate and assemble those transactions</li> <li>Communicating with other Paladin engines to notarize, endorse or submit those transactions</li> <li>Embedding a high performance state store for managing selectively disclosed private transaction state</li> <li>Integrating key management technology to sign transactions (ZKP proofs, EIP-712 signatures and Ethereum TXs)</li> <li>Processing confirmed blockchain transactions to update the state store</li> <li>Emitting streams of events to report status of submitted transactions</li> </ul>"},{"location":"architecture/transaction_manager/#component-flow","title":"Component flow","text":"<p>\u26a0 WORK IN PROGRESS \u26a0</p> <p></p> <p>The major components of the transaction manager are highlighted in this diagram. Key items are:</p> <ul> <li>Transaction assembly and submission: the flow that works in a distributed manor across Paladin runtimes to assemble and submit transactions<ul> <li>Assembly of a transaction in a UTXO model means selecting a set of states that can be spent, and spending them via the rules of the contract</li> <li>This is optimistic in nature - the blockchain is the source of truth for which transaction \"wins\" spending an individual state</li> <li>Collaboration between Paladin runtimes that know they might be contending to spend the same states, mitigates inefficiency</li> <li>Paladin can construct chains of multiple transactions that can be executed in a single block where there is contention on a single state</li> </ul> </li> <li>Smart contract API: the interface into a privacy preserving smart contract<ul> <li>The instructions to submit a privacy preserving smart contract are dependent on the contract itself</li> <li>For token contracts for example, the instructions are likely to be expressed as \"transfer\" operations</li> <li>For EVM Private Smart Contracts in Privacy Groups, the instructions are EVM contract deployments, and invocations</li> <li>The inputs need to be validated and processed by code specific to the privacy preserving smart contract</li> </ul> </li> <li>Transaction confirmation and events: transactions confirmed by the blockchain need to be processed against the private state view<ul> <li>Private data might arrive before or after a transaction is confirmed by the blockchain</li> <li>A party might only be entitled to see some of the data associated with a transaction</li> </ul> </li> <li>Privacy preserving smart contract plug points: each green box in the diagram is a code plug point<ul> <li>The specific technology used for each privacy preserving smart contract might be different - ZKP proofs, Private EVM processing etc.</li> <li>A standardized interface allows multiple out-of-the-box modules to work, as well as building new modules from scratch</li> <li>Configuration and customization is also supported</li> </ul> </li> </ul> <p>TODO: More detailed sequence flow diagrams need to be brought into this document as they evolve (Leads John Hosie &amp; Chengxuan Xing)</p>"},{"location":"architecture/transaction_manager/#key-design-principles","title":"Key design principles","text":"<p>In order to build an engine that works with asynchronous transaction stage update events. The Paladin transaction engine is design with the following principles: - Async stage based processing driven by events: To avoid memory &amp; CPU wasted by idle transaction tracking, an in-memory transaction stage processing pool is adopted to only track and progress pending transactions that has active actions to perform. Other pending transactions that are waiting for asynchronous responses are stored in database until the asynchronous response are detected. A stage contains one or more tasks. All transaction stage processes are trigger by one of the following events:   - User instructions: transaction engine ensures user instructions are validated before any transaction stage process is initiated. If there is already a transaction stage process running, the engine will ensure the instructions are rejected/queued appropriately.   - Peer messages: messages from other nodes in the joined privacy group will be pre-scanned by the transaction engine to ensure the corresponding transaction stage process is initiated at the right time. For example, if an event contains a transaction that attempts to spend a future state, the engine will only trigger the stage process when the future state is discovered.   - Base EVM ledger events: events from the tracked privacy preserving contracts drives the finalization of Paladin transactions. The engine will coordinate and trigger associated completion and rollbacks.</p> <p></p> <ul> <li>Efficient dependency checks: A single Paladin node will need to handle transactions from multiple privacy preserving contracts and multiple UTXO states within each privacy preserving contracts. Paladin transaction engine maintains core transaction status information that are discovered through handling transaction events and stage tasks to provide efficient dependency checks. The transaction engine is designed to be the gate for all transaction record updates so that it can maintain data integrity of the core tracking information.</li> </ul> <p></p> <ul> <li>Critical changes must be persisted between stage tasks: in the situations the transaction stage processor are switching between different stage tasks, any critical changes from the previous task must be persisted on-disk before the next task is triggered. This is to ensure the engine can resume transaction process with the correct context without losing critical information. The stage tasks themselves must be designed with idempotency in mind, so retries with persisted information do not cause unexpected behavior.</li> </ul>"},{"location":"architecture/transaction_manager/#stage-processor-development","title":"Stage processor development","text":"<p>Stage processors is the glue between the generic transaction engine &amp; orchestrators and the domain-specific logic of stage tasks.</p> <p>Responsibilities of the transaction engine:</p> <ul> <li>it will ensure any provided transaction record update will be persisted between stage tasks and stages.</li> <li>it invokes stage action at the right time (e.g. detect dependency satisfaction based on the stage logic).</li> <li>it filters out outdated transaction events based. </li> </ul> <p>Responsibilities of stage processors:</p> <ul> <li>it provides stage specific logic for the generic stage control functions that the transaction engines utilizes</li> <li>it generates transaction information that can be used by transaction engine to do dependency check and event filtering</li> <li>it uses instructions to communicate with the transaction engine for task and stage switch</li> <li>it divides a stage into multiple tasks and decide critical changes between tasks</li> <li>it ensures critical changes are always persisted before performing the affected tasks</li> </ul>"},{"location":"architecture/zeto/","title":"Zeto - Zero Knowledge Proof based tokens","text":"<p>Zeto is a UTXO based privacy-preserving token toolkit for EVM, using Zero Knowledge Proofs, implemented via Circom.</p> <p>The architecture documentations for Zeto is being managed in a separate Github repository here: https://github.com/kaleido-io/zeto</p> <p>Zeto is a growing collection of token implementations that enforce a wide variety of token transaction policies including, but not limited to, mass conservation (for fungible tokens), preservation of asset properties during ownership transfer (for non-fungible tokens), KYC with privacy, and non-repudiation compliance. Each policy is expressed in zeto knowledge proof circuits using Circom. The list of policies and their corresponding token implementations will continue to grow to meet the needs of enterprise use cases.</p>"},{"location":"architecture/zeto/#paladin-support","title":"Paladin Support","text":"<p>Zeto tokens are natively supported by Paladin, as a domain implementation called \"Zeto\". The foundational operations of Zeto tokens, <code>mint</code>, <code>transfer</code> are supported in the initial Paladin release. Support for other operations such as <code>deposit</code>, <code>withdraw</code> will be added later.</p> <p>As a client to Zeto tokens, Paladin has the following features built into the single runtime that runs alongside an Ethereum node:</p> <ul> <li>Tokens indexer: by the nature of a UTXO based design, an account's balance is not known by querying the smart contract, as is the case with ERC-20 tokens. Instead, the UTXOs must be indexed from confirmed onchain transactions in order for an account to know the balance, by adding together all the tokens that belong to that account.</li> <li>Token selector: when sending a transaction that transfers certain amount to another account, the transaction input is made up of a collection of UTXOs that will be spent. The UTXOs must be selected from the unspent UTXOs that the account holds. The selection process needs to take into account the intend transfer amount and the values of the available tokens.</li> <li>ZK proof generator: each Zeto transaction must be accompanied by a ZK proof to demonstrate the validity of the transaction proposal. This is accomplished by a proof generator that is able to use the secrets known only to the Paladin runtime hosting the account key, as private input to the ZKP circuit.</li> </ul>"},{"location":"architecture/zeto/#private-abi","title":"Private ABI","text":"<p>The private ABI of Zeto is implemented in Go, and can be accessed by calling <code>ptx_sendTransaction</code> with <code>\"type\": \"private\"</code>.</p>"},{"location":"architecture/zeto/#constructor","title":"constructor","text":"<p>Creates a new Zeto token contract, with a new address on the base ledger.</p> <pre><code>{\n  \"name\": \"\",\n  \"type\": \"constructor\",\n  \"inputs\": [{ \"name\": \"tokenName\", \"type\": \"string\" }]\n}\n</code></pre> <p>Inputs:</p> <ul> <li>tokenName - name of the Zeto token contract names. As of the current release, the following token contracts are supported:</li> <li>Zeto_Anon</li> <li>Zeto_AnonEnc</li> <li>Zeto_AnonNullifier</li> </ul>"},{"location":"architecture/zeto/#mint","title":"mint","text":"<p>Mint new value. New UTXO state(s) will automatically be created to fulfill the requested mint.</p> <pre><code>{\n  \"name\": \"mint\",\n  \"type\": \"function\",\n  \"inputs\": [\n    {\n      \"name\": \"mints\",\n      \"type\": \"tuple[]\",\n      \"components\": [\n        {\n          \"name\": \"to\",\n          \"type\": \"string\",\n          \"internalType\": \"string\"\n        },\n        {\n          \"name\": \"amount\",\n          \"type\": \"uint256\",\n          \"internalType\": \"uint256\"\n        }\n      ]\n    }\n  ]\n}\n</code></pre> <p>Inputs:</p> <ul> <li>mints - list of mints, each with a receiver name and amount</li> <li>to - lookup string for the identity that will receive minted value</li> <li>amount - amount of new value to create</li> </ul>"},{"location":"architecture/zeto/#transfer","title":"transfer","text":"<p>Transfer value from the sender to another recipient. Available UTXO states will be selected for spending, and new UTXO states will be created, in order to facilitate the requested transfer of value.</p> <pre><code>{\n  \"type\": \"function\",\n  \"name\": \"transfer\",\n  \"inputs\": [\n    {\n      \"name\": \"transfers\",\n      \"type\": \"tuple[]\",\n      \"components\": [\n        {\n          \"name\": \"to\",\n          \"type\": \"string\",\n          \"internalType\": \"string\"\n        },\n        {\n          \"name\": \"amount\",\n          \"type\": \"uint256\",\n          \"internalType\": \"uint256\"\n        }\n      ]\n    }\n  ],\n  \"outputs\": null\n}\n</code></pre> <p>Inputs:</p> <ul> <li>transfers - list of transfers, each with a receiver name and amount</li> <li>to - lookup string for the identity that will receive transferred value</li> <li>amount - amount of value to transfer</li> </ul>"},{"location":"architecture/zeto/#deposit","title":"deposit","text":"<p>The Zeto token implementations support interaction with an ERC20 token, to control the value supply publicly. With this paradigm, the token issuer, such as a central bank for digital currencies, can control the total supply in the ERC20 contract. This makes the supply of the tokens public.</p> <p>The Zeto token contract can be configured to allow balances from a designated ERC20 contract to be \"swapped\" for Zeto tokens, by calling the <code>deposit</code> API. This allows any accounts that have a balance in the ERC20 contract to swap them for Zeto tokens. The exchange rate between the ERC20 and Zeto tokens is 1:1. On successful deposit, the ERC20 balance is transferred to the Zeto contract.</p> <p>Typically in this paradigm, the <code>mint</code> API on the Zeto domain should be locked down (disabled) so that the only way to mint Zeto tokens is by depositing.</p> <pre><code>{\n  \"type\": \"function\",\n  \"name\": \"deposit\",\n  \"inputs\": [\n    {\n      \"name\": \"amount\",\n      \"type\": \"uint256\",\n      \"internalType\": \"uint256\"\n    }\n  ],\n  \"outputs\": null\n}\n</code></pre> <p>Inputs:</p> <ul> <li>amount - amount of value to deposit</li> </ul>"},{"location":"architecture/zeto/#withdraw","title":"withdraw","text":"<p>Opposite to the \"deposit\" operation, users can swap Zeto tokens back to ERC20 balances.</p> <p>On successful withdrawal, the ERC20 balance is released by the Zeto contract and transferred back to the user account.</p> <pre><code>{\n  \"type\": \"function\",\n  \"name\": \"withdraw\",\n  \"inputs\": [\n    {\n      \"name\": \"amount\",\n      \"type\": \"uint256\",\n      \"internalType\": \"uint256\"\n    }\n  ],\n  \"outputs\": null\n}\n</code></pre> <p>Inputs:</p> <ul> <li>amount - amount of value to withdraw</li> </ul>"},{"location":"architecture/zeto/#lockproof","title":"lockProof","text":"<p>This is a special purpose function used in coordinating multi-party transactions, such as Delivery-vs-Payment (DvP) contracts. When a party commits to the trade first by uploading the ZK proof to the orchestration contract, they must be protected from a malicious party seeing the proof and using it to unilaterally execute the token transfer. The <code>lockProof()</code> function allows an account, which can be a smart contract address, to designate the finaly submitter of the proof, thus protecting anybody else from abusing the proof outside of the atomic settlement of the multi-leg trade.</p> <pre><code>{\n  \"type\": \"function\",\n  \"name\": \"lockProof\",\n  \"inputs\": [\n    {\n      \"name\": \"delegate\",\n      \"type\": \"address\"\n    },\n    {\n      \"name\": \"call\",\n      \"type\": \"bytes\"\n    }\n  ],\n  \"outputs\": null\n}\n</code></pre> <p>Inputs:</p> <ul> <li>delegate - set to the Ethereum account, which can be an externally owned account or a smart contract address, that is allowed to submit the transaction to use the locked proof to execute the Zeto token transfer</li> <li>call - this is an abi encoded bytes from a call to the <code>transfer()</code> function of the target Zeto token smart contract. Refer to the PvP test case for an example of how to construct the encode call bytes</li> </ul>"},{"location":"architecture/zeto/#balanceof","title":"balanceOf","text":"<p>Returns the balance information for a specified account. This function provides a quick balance check but is limited to processing up to 1000 states and is not intended to replace the role of a proper indexer for comprehensive balance tracking.</p> <pre><code>{\n  \"type\": \"function\",\n  \"name\": \"balanceOf\",\n  \"inputs\": [\n    {\n      \"name\": \"account\",\n      \"type\": \"string\"\n    }\n  ],\n  \"outputs\": [\n    {\n      \"name\": \"totalStates\",\n      \"type\": \"uint256\"\n    },\n    {\n      \"name\": \"totalBalance\",\n      \"type\": \"uint256\"\n    },\n    {\n      \"name\": \"overflow\",\n      \"type\": \"bool\"\n    }\n  ]\n}\n</code></pre> <p>Inputs:</p> <ul> <li>account - lookup string for the identity to query the balance for</li> </ul> <p>Outputs:</p> <ul> <li>totalStates - number of unspent UTXO states found for the account</li> <li>totalBalance - sum of all unspent UTXO values for the account</li> <li>overflow - indicates if there are at least 1000 states available (true means the returned balance may be incomplete)</li> </ul> <p>Note: This function is limited to querying up to 1000 states and should not be used as a replacement for proper indexing infrastructure.</p>"},{"location":"concepts/advanced_crypto/","title":"Advanced Cryptography","text":"<p>There are two fundamental approaches to preserving privacy of participants in a token ecosystem, while ensuring that all parties can trust a token they receive.</p>"},{"location":"concepts/advanced_crypto/#issuer-backed-pre-verification","title":"Issuer-backed / pre-verification","text":"<p>Some amount of trust must be given to the one-or-more parties that can verify a transaction is valid, and attest to that verification.</p> <ul> <li>A signed attestation is provided by this party that they validated the transaction</li> <li>The attestation includes that authorization was provided by the sender, with a signature</li> <li>The working of this party can be checked by anyone who has access to the unmasked data</li> <li>The ledger cannot validate the data</li> <li>The ledger can perform double-spend protection of the token/value/states</li> </ul> <p>This mode of operation is very efficient in its use of the ledger, as it only requires minimal data to be written that allows verification of the transaction off-chain, and double-spend protection on-chain.</p> <p>Trust in a token received, is based on trust of the issuer/pre-verifier, as you are trusting not only that the current transaction you received the data for is valid, but that all previous transactions that could affect the uniqueness/value of your token are also valid.</p>"},{"location":"concepts/advanced_crypto/#potential-challenges-with-issuer-backed-model","title":"Potential challenges with issuer-backed model","text":"<ol> <li>Centralization of data/trust</li> <li>This is sometimes considered a significant benefit, rather than a challenge. Particularly if a party is required legally to maintain a record of every transaction. As regardless of the technology there is some centralization of trust in that party.</li> <li>Note that with Paladin it is possible for a pre-verification model to atomically interoperate with Private EVM state, and ZKP backed tokens in a single transaction. So trusting an issue for one token, does not mean they need to have access to all business data in a transaction</li> <li>Operational coupling</li> <li>Availability to transact, is based on availability of the pre-verifier infrastructure. Again this is sometimes considered a benefit, if the pre-verifier has a role that includes preventing transactions completing that do not conform to certain rules only it can enforce.</li> </ol>"},{"location":"concepts/advanced_crypto/#zero-knowledge-proofs-zkp","title":"Zero-knowledge proofs (ZKP)","text":"<p>The alternative approach is to use a ZKP circuit to cryptographically verify the business transaction conformed to the rules of the smart contract.</p> <p>This use of advanced cryptography has the following benefits:</p> <ul> <li>Fully decentralized - any party can generate a proof, and submit a transaction, as long as that transaction meets the rules of the contract</li> <li>Full enforcement on-chain - any transaction that does not conform is rejected directly via the base ledger</li> </ul>"},{"location":"concepts/advanced_crypto/#paladin-and-zeto","title":"Paladin and Zeto","text":"<p>Paladin has a sibling project zeto, which contains a set of ZKP circuits written in Circom, along with sample Solidity-based token implementations that make use of the ZKP verifiers. Zeto has been undergoing peer review for some time before the availability of Paladin itself.</p> <p>The following features are part of the Zeto project, and Paladin provides the client for these.</p>"},{"location":"concepts/advanced_crypto/#fungible-tokens","title":"Fungible tokens","text":"<p>Coin selection, proof generation and transfer of coins containing an owner and a numeric value.</p>"},{"location":"concepts/advanced_crypto/#non-fungible-tokens","title":"Non-fungible tokens","text":"<p>Uniqueness of an identifiable token within a smart contract, and the transfer of ownership of that token.</p>"},{"location":"concepts/advanced_crypto/#off-chain-encrypted-data-transfer","title":"Off-chain encrypted data transfer","text":"<p>The separation of the data from the proof submitted on-chain, requiring separate encrypted transfer (provided by Paladin) of the states.</p> <p>Off-chain transfer avoids the need to write data with a static encryption key immutably to a chain. A detailed discussion of protection of counter-party risk in DvP scenarios from non-disclosure of data using Pente Private EVM privacy groups is being prepared at the time of writing of this introduction.</p>"},{"location":"concepts/advanced_crypto/#on-chain-encryption-of-data","title":"On-chain encryption of data","text":"<p>Options using on-chain encryption are also provided. Encryptions are performed inside the ZKP circuit such that they are guaranteed to be decipherable by the receiver.</p>"},{"location":"concepts/advanced_crypto/#nullifiers-for-additional-anonymity","title":"Nullifiers for additional anonymity","text":"<p>Nullifiers mask the spending of a coin in a way that only the spender knows which coin was spent - providing increased levels of anonymity.</p> <p>Paladin supports the coordination required for generation of nullifiers for states by the owners of those states, as an advanced wallet and distributed state management function.</p>"},{"location":"concepts/advanced_crypto/#snark-friendly-encryption-and-hashing","title":"Snark friendly encryption and hashing","text":"<p>The Baby Jubjub curve is used for the public key cryptography. Public keys derived on this curve are used to represent ownership of the tokens. The hashing algorithm to construct onchain commitments and nullifiers is Poseidon.</p> <p>See the Key Management section of the Paladin architecture docs for details of how key materials are made available to the Zeto engine for use in nullifier and proof generation.</p>"},{"location":"concepts/advanced_crypto/#webassembly-execution-environment-for-proof-generation","title":"WebAssembly execution environment for proof generation","text":"<p>Paladin supports multiple different execution environments for components, all in a single process through its runtime architecture.</p> <p>Zeto circuits are compiled into WebAssembly modules (WASM) which are loaded by Paladin to calculate witnesses, which are then used in proof generations.</p>"},{"location":"concepts/advanced_crypto/#governance-requirements","title":"Governance requirements","text":"<p>The fully decentralized nature of a ZKP based solution can be a challenge for enterprise use cases, where KYC/AML checks might be required on trading participants, or other governance activities might be required that cannot be modelled directly in a ZKP circuit.</p> <p>Zeto provides an implementation of a ZKP backed KYC registry on-chain, requiring every transaction to come with a proof that the sender and receiver public keys are included in the on-chain registry.</p> <p>Zeto also demonstrates how a token can use a mixture of fully ZKP based logic, and issuer-backed logic for different functions. For example requiring specific authority to perform a <code>mint</code> operation, while allowing <code>transfer</code> operations to be fully decentralized.</p>"},{"location":"concepts/advanced_crypto/#utxo-based-state-model","title":"UTXO based state model","text":"<p>Paladin is an EVM native solution, using EVM smart contracts to back each of the types of private smart contract provided.</p> <p>Often EVM smart contracts are assumed to implement an account model for management of states, because the open standards on Etherum like ERC-20, ERC-721 are all based on an account model.</p> <p>However, the majority of privacy preserving projects that build on top of EVM utilize a UTXO model for state management because of the nature of the problem being solved.</p>"},{"location":"concepts/advanced_crypto/#unspent-transaction-outputs","title":"Unspent Transaction Outputs","text":"<p>In a UTXO model:</p> <ul> <li>State is never modified - only read, consumed, or produced</li> <li>Each state is self-consistent - making it more likely to be usable in isolation of other states</li> </ul> <p>These properties make a UTXO model a great fit for performing atomic operations in a privacy preserving environment.</p> <p>As such all of the tokens, and the Private EVM Privacy Groups, in Paladin are based on a UTXO state storage and distribution system, with confidentiality built in based on selectively disclosing those states only to those parties with a right to have access to them.</p> <p></p>"},{"location":"concepts/atomic_programmability/","title":"Atomic EVM Programmability","text":"<p>One of the questions asked about the Paladin project is \"Why EVM?\"</p> <p>We've discussed that a lot of technologies used in Paladin add layers of state management and advanced cryptography that diverge from the traditional programming paradigms of ERC-20 and ERC-721 contracts.</p> <p>Is it \"just\" the vibrancy of the EVM developer community and ecosystem? Or is there something unique about the programmable nature of the EVM ledger itself that is transformational in the solution, compared to using a bespoke DLT at the base?</p>"},{"location":"concepts/atomic_programmability/#the-power-of-the-evm-sandwich","title":"The power of the EVM sandwich","text":"<p>Let's zoom out an look at a use case, and see how it's made possible by the fact that there is a fully programmable EVM at both the bottom (fully open and decentralized) end, and the top (fully private and isolated) ends of the stack.</p> <p>In the diagram above, we see the use of three different technologies, developed independently by three different sets of developers working atomically together:</p> <ol> <li>An issuer-backed asset being transferred from User1 to User2<ul> <li>For example a bond or other regulated security</li> </ul> </li> <li>A fully decentralized ZKP-backed cash token being transferred from User2 to User1<ul> <li>For example some CBDC coins</li> </ul> </li> <li>An arbitrarily complex multi-step piece of logic being executed between User1 and User2<ul> <li>For example a DvP flow agreeing and settling a trade</li> </ul> </li> </ol> <p>Each of these three smart contracts is backed by an on-chain EVM smart contract on the base ledger. As a result, the EVM can be used to orchestrate a single atomic transaction across all three contracts.</p>"},{"location":"concepts/atomic_programmability/#ecosystem-programmability","title":"Ecosystem programmability","text":"<p>Even more important than the fact this atomicity is possible, is the fact that the development of the use case was decentralized in nature.</p> <ul> <li>The asset issuer built and issued their token<ul> <li>The did not need to know the private details of the trade</li> <li>They still ensured the rules of their token were obeyed </li> </ul> </li> <li>The cash issuer built their currency<ul> <li>They were not even involved in the trade - the ZKP enforced trading rules via proof</li> </ul> </li> <li>The users used a smart contract to settle their trade<ul> <li>Likely supported by an EVM innovator in the ecosystem</li> </ul> </li> </ul> <p>This ecosystem programmability is the true power of EVM, and the recipe for its success in fostering adoption of Web3 in the public community.</p>"},{"location":"concepts/atomic_programmability/#wheres-the-catch","title":"Where's the catch?","text":"<p>As with any Web3 swap, there are a couple of important pre-requisites to make this possible:</p> <ul> <li>Standard interfaces that support programmability<ul> <li>The ability to obtain a pre-approval for a transaction from a notary</li> <li>The ability to lock a proof for conditional execution</li> <li>The ability to trigger a base ledger transaction from an EVM Privacy Group</li> </ul> </li> <li>Multiple transactions are required to setup the trade for execution<ul> <li>True for most atomic swap operations in practice</li> <li>Does not change the fact the final execution is a single atomic transaction</li> </ul> </li> </ul>"},{"location":"concepts/cloud_native/","title":"Cloud Native Runtime","text":"<p>Paladin provides a single fast-starting runtime architecture ideal for packaging in to a microservice architecture alongside blockchain and application components. </p> <p>Internally it is componentized with gRPC boundaries between separate components (including Golang, Java and WebAssembly), allowing high scale deployments to individual scale components as microservices if required.</p> <p>Paladin runs completely independently to your blockchain nodes, and uses a Database for state storage. That database can be embedded for development, or a reliable HA deployment of PostgreSQL for production.</p>"},{"location":"concepts/cloud_native/#kubernetes-operator-and-quickstart","title":"Kubernetes operator and quickstart","text":"<p>As a cloud native OSS project, Paladin is supplied with a Kubernetes operator used throughout development and testing of the Paladin project itself.</p> <p></p> <p>The quickstart uses this operator along with Kind to build a complete 3-node network on your laptop, and to do this the operator also supports building a fully functional test blockchain network using another great project from the Linux Foundation Decentralized Trust family - Besu.</p> <p>The default operator sample configuration during startup orchestrates:</p> <ul> <li>Creating a Genesis config and Besu network<ul> <li>Builds a 3-node Besu network with all three nodes as QBFT validators</li> <li>100ms block time, with 10s empty block period (low latency for testing and development)</li> </ul> </li> <li>Creating three individual Paladin nodes<ul> <li>Creating a PostgreSQL database for each Paladin node (co-located as a sidecar for testing and development)</li> <li>Generating an MTLS certificate for each node using CertManager (self-signed - see registry below)</li> <li>Building a HD Wallet key store for each node, backed by a k8s secret</li> <li>Orchestrating the restart of the Paladin nodes as configuration changes during initialization</li> </ul> </li> <li>Deploying the Smart Contracts for three Privacy Domains<ul> <li><code>Pente</code> - factory contract for Private EVM Privacy Group contracts</li> <li><code>Noto</code> - factory contract for Notarized token contracts</li> <li><code>Zeto</code> - multiple (18 and counting) contracts with inter-dependencies managed to implement multiple ZKP token types</li> </ul> </li> <li>Deploying a registry and automating registration<ul> <li>Smart contract backed registry with simple operator model for root identities</li> <li>Node identities self-register their endpoint details</li> <li>Mutual TLS is automatically configured between nodes via registry publication</li> </ul> </li> </ul>"},{"location":"concepts/full_stack/","title":"Full Enterprise Privacy Stack","text":"<p>More than \u201ctoolkit\u201d or \u201cframework\u201d, Paladin is a fully functioning client for enterprise adoption of EVM with privacy.</p>"},{"location":"concepts/full_stack/#api","title":"API","text":"<p>From submission of transactions, through to reliably detecting events, the Paladin client provides a full service API that is simple and consumable for EVM developers.</p> <ul> <li>The methods are all available and documented using JSON/RPC over HTTP and WebSockets</li> <li>The input/output types are modelled using the Ethereum standards (inc. ABI type)</li> <li>The data is mapped to/from JSON for you without needing complex encoding</li> <li>Transactions are looked after reliably until they are complete</li> <li>Signing and wallet functions are integrated into the runtime</li> <li>Client bindings and type definitions for popular dev languages (Typescript, Java, Golang)</li> </ul>"},{"location":"concepts/full_stack/#embedded-ui","title":"Embedded UI","text":"<ul> <li>Quick access to transactions, block indexing, registry and more.</li> <li>Private EVM transaction decoding and visibility.</li> </ul>"},{"location":"concepts/full_stack/#transaction-engine","title":"Transaction engine","text":"<p>Event-driven engine for managing transactions through from submission to on-chain confirmation, with three major components.</p>"},{"location":"concepts/full_stack/#public-transaction-manager","title":"Public transaction manager","text":"<p>Latest generation, high performance, reliable submission engine for streaming transactions to the base ledger.</p> <p>Works for any EVM smart contract, not just privacy preserving smart contracts.</p> <ul> <li>ABI error decoding</li> <li>Full nonce management using a reliable database</li> <li>Confirmation and gas management for public chains</li> <li>Integrated with the signing engine</li> <li>Fully asynchronous and event driven engine, for maximum throughput</li> </ul>"},{"location":"concepts/full_stack/#private-transaction-manager","title":"Private transaction manager","text":"<p>The event-driven orchestration engine required to coordinate and submit privacy preserving transactions to the chain.</p> <ul> <li>Integrating multiple domains of privacy over an extensible pluggable interface</li> <li>Coordinating across nodes to gather the signatures and endorsements required to submit private transactions at scale</li> <li>Handling graphs of dependencies between UTXO input and output states, ahead of confirmation in blocks on-chain</li> <li>Reliably distributing new states to recipients of transaction outputs</li> </ul>"},{"location":"concepts/full_stack/#common-management","title":"Common management","text":"<p>Unified experience and orchestration across public and private transaction managers.</p> <ul> <li>Chaining private transaction assembly to the corresponding submission of a base ledger transaction</li> <li>Managing receipts, and rich query of current and historical transactions</li> <li>Storing prepared transactions, for use in atomic swap operations</li> </ul>"},{"location":"concepts/full_stack/#blockchain-indexer","title":"Blockchain indexer","text":"<p>High performance indexer for a sparse view of the entire chain, combined with reliable event streams used internally by domains and available for external subscription to EVM events.</p> <ul> <li>Blocks, Transactions and Event signatures for every transaction by default</li> <li>Confirmation management to only detect finalized events</li> <li>Reliable event streams with checkpoints for in-order delivery of events, including historical replay</li> </ul>"},{"location":"concepts/full_stack/#key-management","title":"Key Management","text":"<p>Enterprise optimized key management system built into the Paladin runtime, with remote signing module support.</p> <ul> <li>Key aliases and address book function, supporting rich multi-wallet folder based organization</li> <li>ZKP prover integration for in-memory assembly of proofs with signing keys</li> <li>HD Wallet derivation for high volume single use keys for anonymity</li> <li>1:1 static key mapping, master-key encryption and in-HSM signing for high value keys</li> <li>Pluggable key storage for integration of HSM/SSM solutions</li> <li>Remote-capable signing module for deployment separation of runtime and signing engines</li> </ul> <p>See Architecture docs for more detail</p>"},{"location":"concepts/full_stack/#private-state-store","title":"Private state store","text":"<p>A critical component for wallet functions in a privacy preserving client, as private states are not guaranteed to be recoverable by another party. Once lost, data (and value) might be lost forever.</p> <ul> <li>In-memory assembly of states for chains of transactions ahead of submission</li> <li>Schema based modelling of states for different privacy domains, including indexing and ABI data types</li> <li>Rich query interface with JSON syntax, and SDK clients</li> <li>Confirmation management for states coupled to domain-specific transaction indexing</li> <li>Nullifier support for fully anonymous ZKP domains</li> </ul> <p>See Architecture docs for more detail</p>"},{"location":"concepts/full_stack/#node-registry","title":"Node registry","text":"<p>Secure connectivity information for nodes must be managed in a private environment, and Paladin provides a pluggable registry with an event-driven EVM Smart backed implementation out of the box.</p> <ul> <li>Event-driven indexing model, extensible beyond just blockchain registries</li> <li>Multiple registries supported per Paladin node runtime, allowing overlapping private connectivity networks</li> <li>Rich query interface - supporting complex address book function, as well as node connectivity</li> <li>Manages off-chain transport connectivity endpoints, including transport specific security credentials</li> <li>Natively decentralized model allows private connectivity networks to build quickly and grow</li> </ul>"},{"location":"concepts/full_stack/#private-data-transports","title":"Private Data Transports","text":"<p>Connectivity between nodes for the transfer of private states is a core requirement for any privacy preserving solution.</p> <ul> <li>Code-pluggable transports</li> <li>MTLS direct HTTPS (gRPC) connectivity out of the box</li> <li>Extensible to hub+spoke models such as JMS clients (pure Java capable)</li> </ul>"},{"location":"concepts/full_stack/#pluggable-privacy-domains","title":"Pluggable privacy domains","text":"<p>Each of the token implementations, and the Private EVM implementation, confirm to a single lifecycle model for the assembly, coordination and submission of transactions through the private transaction lifecycle.</p> <p></p> <p>See Architecture docs for more detail.</p>"},{"location":"concepts/private_evm/","title":"Private EVM Smart Contracts","text":"<p>EVM smart contracts are established as the most popular programming model for writing digitally enforceable business logic.</p> <p>Almost every business transaction has some workflow involved, and as such being able to digitally enforce this workflow through EVM programmed logic is a critical part of designing an enterprise use case that gets value from Web3 technologies.</p>"},{"location":"concepts/private_evm/#evm-programming-model-in-a-nutshell","title":"EVM programming model in a nutshell","text":"<p>The EVM programming model is easy to understand conceptually, and there are great samples and expertise out there to build upon.</p> <ul> <li>Accounts can hold data, and participate in transactions</li> <li>Smart contracts are a special type of Account that has code</li> <li>Smart contracts expose functions that can be called by other accounts</li> <li>Smart contract functions update the data inside of the smart contact account</li> <li>Smart contracts can call other smart contracts</li> <li>A transaction is an atomic operation that updates one or more account</li> </ul> <p>This fantastic simplicity that is the greatest power of EVM, is also a challenge - it results a single world state across all accounts on a ledger.</p> <p>In use cases with privacy requirements, there are lots of different groups of parties, who all have access to different sets of data.</p>"},{"location":"concepts/private_evm/#one-approach-lots-of-isolated-chains","title":"One approach - lots of isolated chains","text":"<p>Creating lots of individual and isolated ledgers/blockchains for all those different groups is a very cumbersome activity (much experimentation has been done in earlier generations of ledger technologies on this approach).</p> <p>The biggest challenge with creating all those separate chains, is that you lose the ability to transact across them atomically. Complex escrow-based transactions (3<sup>rd</sup> party or time lock based) are required to transact across them, because fully atomic transactions cannot be performed.</p> <p>Note that the Paladin project does not assume that there will be \"one chain to rule them all\". A diversity of permissioned and public blockchains is an absolute reality, for scale, risk, jurisdictional integrity and many other reasons. The EVM ecosystems is inherently a multi-chain ecosystem. However, the ability to atomically transact between parties within a within a single chain is still necessary in practice for truly atomic transactions. This means some amount of sub-ledger privacy is always going to be necessary regardless of the number of chains that exist for Web3 to deliver the settlement finality it promises.</p>"},{"location":"concepts/private_evm/#privacy-groups","title":"Privacy groups","text":"<p>The concept of a EVM privacy group is a powerful lighter weight approach that separates the two responsibilities:</p> <ol> <li>The private \"world state\" associated with a set of private smart contracts<ul> <li>This is held only by those participating in the privacy group</li> </ul> </li> <li>The ledger that enforces the transitions of that private world state<ul> <li>This ledger is shared across many privacy groups, and public EVM transactions</li> </ul> </li> </ol> <p>By creating this separation, you can have as many privacy groups sharing a single ledger as you require.</p>"},{"location":"concepts/private_evm/#challenges-with-previous-generations-of-the-technology","title":"Challenges with previous generations of the technology","text":"<p>There are some key challenges that existed with previous generations of EVM privacy groups, that are addressed by the <code>Pente</code> implementation provided with Paladin:</p> <ol> <li>Ability for state divergence, due to lack of enforcement on the base ledger<ul> <li>Previous generations only wrote to the based ledger the inputs to transactions. This meant that the state had the potential to diverge between parties in the privacy group. Resulting in a stall in processing (bad) or diverged processing against different state (worse).</li> </ul> </li> <li>Inability to cause actions atomically across privacy groups and public EVM<ul> <li>Privacy groups have been well established for performing private transactions with a defined beginning, middle and end, with a defined set of parties. However, complex use cases as described in the Privacy Preserving Tokens section require workflows that use the inputs/outputs from one transaction as part of another transaction. Historically this has been impossible.</li> </ul> </li> <li>Modification of the base EVM ledger client<ul> <li>All previous generations of the technology required some modification of the base ledger technology itself. A special client that contained logic to coordinate the private transactions in the privacy group, with the block formation on the main ledger. As well as limiting the reach of the technology to permissioned ledgers, this has proven problematic for ongoing maintenance.</li> </ul> </li> </ol>"},{"location":"concepts/private_evm/#pente-feature-summary","title":"Pente feature summary","text":"<p>The Pente implementation of privacy groups provided with Paladin addresses all three of these challenges.</p>"},{"location":"concepts/private_evm/#off-chain-endorsement-backed-by-on-chain-enforcement","title":"Off-chain endorsement backed by on-chain enforcement","text":"<p>The flow in Pente to form each transaction is summarized as follows:</p> <ul> <li>The sender of the transaction prepares it<ul> <li>Signing the input payload</li> <li>Proposing the existing account states that will be read/updated</li> <li>Proposing the new account states that will be produced</li> </ul> </li> <li>Consensus is formed through endorsement signatures<ul> <li>Members of privacy group re-execute the signed transaction</li> <li>The same exact account states are used by every member who endorses</li> <li>A signature is only provided if the execution results are identical to the proposal</li> </ul> </li> <li>The base ledger enforces the transition<ul> <li>A masked record of every account state is held on-chain</li> <li>All account states that are modified/read in a transaction must exist</li> <li>Once executed, no other transaction can use any modified account state <ul> <li>This is a derivation of a UTXO model, where each account state is a UTXO</li> </ul> </li> </ul> </li> </ul> <p>In order to support multiple transactions per block, the Paladin engine performs consensus election of a coordinator that coordinates the preparation (or \"assembly\") of a graph of transactions.</p>"},{"location":"concepts/private_evm/#atomic-actions-on-the-base-ledger-as-endorsed-side-effects","title":"Atomic actions on the base ledger as endorsed side-effects","text":"<p>Each Pente privacy group, is backed by a unique smart contract on-chain. This means it has a unique contract identity on the base ledger, that can be authorized as an account against other smart contracts.</p> <p>Within the private EVM, a special event can be emitted that each endorsing party will validate to convert into a deterministically constructed function call payload on the base ledger. When the transaction is confirmed by the blockchain, this action will be performed atomically as part of that transaction.</p> <p>Thus an agreed smart contract transaction inside the private EVM, can be coordinated to have an atomic side effect outside of the private EVM.</p> <p>This is a very powerful feature of the Pente privacy group technology that allows some key use cases including:</p> <ul> <li>Using a private EVM smart contract as the notary function for a notarized token</li> <li>Coordinating the result of a DvP/PvP or other settlement activity inside of a smart contract, with another smart contract<ul> <li>For example settling a leg of a private transaction with a public ERC-20 token transfer</li> </ul> </li> </ul>"},{"location":"concepts/private_evm/#run-on-any-evm-base-ledger-with-ephemeral-besu-evm-instances","title":"Run on any EVM base ledger, with ephemeral Besu EVM instances","text":"<p>Pente is purely \"app layer\" technology from the perspective of the base ledger. No special functions are required - the EVM smart contract that backs the privacy group is completely normal EVM logic.</p> <p>Pente then operates by creating Besu EVM instances on-demand whenever a transaction requires one, running inside the Paladin engine (separate to the blockchain node).</p> <p>The account states that are needed to run the transaction are loaded on-demand as the transaction executes inside of the EVM, in order to prepare the transactions. The exact states that were loaded are recorded, and using a hash-based identifier that is based on the full account state at the time of execution.</p> <p>Then when endorsing the transaction, exactly those same account states are pre-loaded into the on-demand created EVM for endorsement - so no other data can be read during endorsement, that was not declared when preparing the transaction.</p> <p>Generating a receipt containing all the events from a transaction, or performing a <code>call</code> operation, work in similar ways to the above - hot loading an EVM in just to perform that one task.</p> <p>This approach allows for a huge scale of number of separate EVM privacy groups, each with a complete and independent \"world state\". These privacy groups might be extremely short lived, only spanning an individual business transaction. Or they might be long lived, but limited in their privacy scope - such as maintaining the private issuer state of an issuance of assets.</p>"},{"location":"concepts/tokens/","title":"Privacy Preserving Tokens","text":"<p>Tokens are the foundation on which blockchain and DLT use cases are built.</p> <p>A token is a digital record of the existence and ownership of something of value.</p> <p>The ability to refer to and transfer ownership of a token as part of an atomic transaction, is what makes Web3 (Blockchain and DLT) technologies fundamentally different to the API driven world of Web2.</p>"},{"location":"concepts/tokens/#tokens-standards-on-evm","title":"Tokens standards on EVM","text":"<p>EVM has established really important standards for interoperability of tokens.</p> <ul> <li>ERC-20 and related standards like ERC-777<ul> <li>These provide an interoperability standard for <code>fungible</code> tokens, where value is divisible and interchangeable within the pool of value represented by the token</li> </ul> </li> <li>ERC-721 and related standards like ERC-1155<ul> <li>These provide an interoperability standard for <code>non-fungible</code> tokens, representing a unique item with a unique identity</li> <li>In the case of ERC-1155 the ability to blur the lines between fungible and non-fungible use cases</li> </ul> </li> <li>ERC-1400 (ERC-14xx), ERC-3643 (T-Rex) and related standards<ul> <li>These provide various levels of reference and standardization for the more complex realities of business use cases</li> <li>Implementors might use these as an accelerator for building real-world enterprise uses cases using tokens, although none provide a one-size-fits-all solution</li> <li>Generally tokens still conform to ERC-20/ERC-721/ERC-1155 when encompassing more complex standards, as that is where the most interoperability and programmability comes from</li> </ul> </li> </ul> <p>None of these standards address privacy, because these tokens requires complete visibility into the transaction history to trust the value.</p>"},{"location":"concepts/tokens/#the-privacy-requirements","title":"The privacy requirements","text":"<p>To build enterprise use cases meaningfully that use tokens, the data must be segregated in a way that allows each party to see and be in control of an appropriate subset of data in the transaction.</p>"},{"location":"concepts/tokens/#the-token-itself","title":"The token itself","text":"<p>The token itself needs to have a wide reach, to be a provably unique record of ownership across the whole ledger/blockchain. This is what makes a token so powerful.</p> <p>In a privacy preserving use case, it is necessary to avoid the history of ownership of a token being directly or indirectly available to those with access to the chain. However, it must still be true that when I receive a token that I can trust the legitimacy of the token within the scope of the ledger.</p> <p>As such the existing open models of ERC-20 and ERC-721 derived standards to not fit a privacy preserving use cases, as these tokens require access to the token account state to validate the token, and this account state is a product of all previous transactions that occurred for that token. So I need complete historical visibility to trust the authenticity of any token I receive.</p> <p>Alternative approaches described below using issuer-private data, or zero-knowledge proofs, are required to protect the confidentiality and anonymity of the parties transacting. These approaches are of course not new to EVM, but they do not currently have the same standardization, programmability or interoperability of ERC-20 / ERC-721, and that is something the Paladin project aims to address.</p>"},{"location":"concepts/tokens/#token-and-token-holder-data","title":"Token and token holder data","text":"<p>There are often strong anonymity requirements that mean participants in the ecosystem cannot directly know, or indirectly infer through inspecting transaction patterns, who owns a token at any given point in time.</p> <p>Conversely, it is necessary for the holder of a token to be able to prove information about the token, and ownership of that token, when required to complete a transaction.</p> <p>The issuer of a token might need to hold data about every holder of a token, and prove they have performed KYC/AML checks against it. This data is usually subject to legal requirements on its retention, including the ability to delete it.</p>"},{"location":"concepts/tokens/#transaction-scoped-data","title":"Transaction scoped data","text":"<p>Data placed directly on a base ledger is immutable, and visible to all. Whereas the data involved in a transaction between parties is often scoped only to the execution of that one business transaction. There might be many steps involved, and those steps need to be enforced through a smart contact.</p> <p>This transaction scoped data is commonly also not allowed to be disclosed to the issuers of the tokens that are being exchanged.</p>"},{"location":"concepts/tokens/#the-paladin-approach","title":"The Paladin approach","text":"<p>Paladin is designed to combine technologies, allowing the partitioning of data to those with a right to have access to it, while allowing atomic settlement across overall business transactions where different parties have access to different subsets of the data.</p> <p>The EVM is uniquely powerful in supporting this form of interoperability, as the ledger itself is so programmable supporting layering of multiple technologies on top of it.</p>"},{"location":"concepts/tokens/#built-on-evm-and-providing-programmability-through-evm","title":"Built on EVM, and providing programmability through EVM","text":"<p>EVM is the place where the most innovation is happening on privacy technologies. EVM based ledgers provide all the tools needed to build layers of privacy on top, and most importantly to make those private worlds interoperable with other worlds on the same ledger.</p> <p>Paladin is designed to unleash the innovation and talent of the EVM ecosystem, for enterprise use cases that have a fundamental requirement for privacy.</p> <p>Paladin not only uses EVM as the base ledger it runs against (it is compatible with any EVM), but it allows programmability through EVM.</p>"},{"location":"concepts/tokens/#the-building-blocks","title":"The building blocks","text":"<p>Constructing a tokenization use case has historically meant choosing between three very different approaches to maintaining privacy:</p> <ol> <li>Zero-knowledge proof (ZKP) based tokens<ul> <li>These obey the purest principals of decentralization, where mathematics enforces the rules of the token. No individual party is required to be involved in any processing, and by the nature of that no party can prevent a valid transaction from executing.</li> <li>Cash tokens, including Central Bank Digital Currencies (CBDCs), are driving enterprise adoption of this form of token due to the simple mathematical nature of the tokens. Control points are often still required such as KYC/AML checks on the governance of parties authorized to trade, and activities that affect overall supply.</li> <li>The overhead of the cryptography is comparatively high with this set of technologies, so there is rapid evolution in the toolkits and approaches to reduce the overhead and increase efficiency.</li> </ul> </li> <li>Issuer-backed tokens / Private Oracles / Notarized tokens<ul> <li>These do not execute entirely in the open, but instead require some centralization of control - most commonly because the legal framework they operate in require it. The fact there is a single party means that anonymity and confidentiality between trading parties can be established by inclusion of the operator/issuer in each transaction, and trusting that operator to maintain the private date they are legally required to hold. That party controls what data is shared with whom.</li> <li>Regulated securities such as Bonds and Funds almost always fall into this category, where existing legal frameworks for the governance of ownership records mean that some set of legal entities must be involved in any transfer, and must have full details of that transfer.</li> </ul> </li> <li>Private smart contracts<ul> <li>The power of an smart contract, EVM or otherwise, is that every party involves knows the same logic is being executed against the same data, in the same order. Previous projects, including ones with significant adoption in the enterprise EVM community such as Tessera, have aimed to provide this same benefit within privacy groups sharing a common ledger.</li> <li>Because data inside a privacy group can only be proved to those within the privacy group, this has primarily been adopted for time-bound processing, or processing that is known to be very constrained to a specific set of parties. General use tokens do not fit \"inside\" a privacy group, because by their nature the tokens needs to be tradable and exchangeable across these privacy groups (or they are not really tokens).</li> </ul> </li> </ol>"},{"location":"concepts/tokens/#the-missing-link-programmability","title":"The missing link - programmability","text":"<p>Rather than picking any one of these approaches in isolation, Paladin embraces all of these approaches and the ability to program across them.</p> <p>This is based on the principal that the success of the EVM community, and existing ERC token standards, is the ability for use case to be programmed against them that are beyond the original design of the token itself.</p>"},{"location":"concepts/tokens/#paladin-tokens","title":"Paladin tokens","text":"<p>Paladin tackles deficiencies in previous generations of technology for tokens head on, by providing:</p> <ul> <li>EVM native, modern, robust implementations of each token type<ul> <li>ZKP backed tokens (Zeto)</li> <li>Notarized / issuer-backed tokens (Noto)</li> </ul> </li> <li>Programmability for the private transaction workflows between tokens<ul> <li>Private EVM execution in privacy groups (Pente)</li> </ul> </li> <li>The extensibility to add new implementations as technologies as they evolve<ul> <li>New cryptography</li> <li>New programmability</li> <li>New business requirements</li> </ul> </li> <li>Atomic programmability across all types of system<ul> <li>With true single-ledger, single-transaction atomicity</li> <li>Without the need for time-lock or 3<sup>rd</sup> party based escrow</li> <li>Bringing us towards a \"ZRC-20\" standard of interoperability</li> </ul> </li> </ul>"},{"location":"contributing/asking-a-question/","title":"Asking a Question","text":"<p>Tip</p> <ul> <li>check the FAQs to see if your question has already been asked.</li> <li>make sure you provide all relevant details.</li> <li>include information about what you have already tried.</li> <li>review How to Ask Technical Questions to Get Quality Answers prior to asking your question.</li> </ul>"},{"location":"contributing/asking-a-question/#chat","title":"Chat","text":"<p>Hyperledger\u2019s Discord server is the place to go for real-time chat about everything from quick help to involved discussions.</p> <p>For general Paladin discussions, join the Discord server and visit #PROJECT.</p>"},{"location":"contributing/asking-a-question/#mailing-lists","title":"Mailing Lists","text":"<p>The Paladin mailing list is hosted by the Hyperledger Foundation: https://lists.hyperledger.org. </p>"},{"location":"contributing/how-to-contribute/","title":"How to Contribute","text":""},{"location":"contributing/how-to-contribute/#ways-to-contribute","title":"Ways to Contribute","text":"<p>Contributions from the development community help improve the capabilities of Paladin. These contributions are the most effective way to make a positive impact on the project.</p> <p>Ways you can contribute:</p> <ul> <li>Bugs or issues: Report problems or defects found when working with the project (see Reporting a Bug)</li> <li>Core features and enhancements: Provide expanded capabilities or optimizations</li> <li>Documentation: Improve existing documentation or create new information</li> <li>Tests: Add functional, performance, or scalability tests</li> </ul> <p>Issues can be found in GitHub. Any unassigned items are probably still open. When in doubt, ask on Discord about a specific issue (see Asking a Question). We also use the #good-first-issue tag to represent issues that might be good for first timers.</p>"},{"location":"contributing/how-to-contribute/#the-commit-process","title":"The Commit Process","text":"<p>Paladin is Apache 2.0 licensed and accepts contributions via GitHub pull requests. When contributing code, please follow these guidelines:</p> <ul> <li>Fork the repository and make your changes in a feature branch</li> <li>Include unit and integration tests for any new features and updates to existing tests</li> <li>Ensure that the unit and integration tests run successfully prior to submitting the pull request.</li> </ul>"},{"location":"contributing/how-to-contribute/#pull-request-guidelines","title":"Pull Request Guidelines","text":"<p>A pull request can contain a single commit or multiple commits. The most important guideline is that a single commit should map to a single fix or enhancement. Here are some example scenarios:</p> <ul> <li>If a pull request adds a feature but also fixes two bugs, the pull request should have three commits: one commit for the feature change and two commits for the bug fixes.</li> <li>If a PR is opened with five commits that contain changes to fix a single issue, the PR should be rebased to a single commit.</li> <li>If a PR is opened with several commits, where the first commit fixes one issue and the rest fix a separate issue, the PR should be rebased to two commits (one for each issue).</li> </ul> <p>Important</p> <p>Your pull request should be rebased against the current master branch. Do not merge the current master branch in with your topic branch. Do not use the Update Branch button provided by GitHub on the pull request page.</p>"},{"location":"contributing/how-to-contribute/#commit-messages","title":"Commit Messages","text":"<p>Commit messages should follow common Git conventions, such as using the imperative mood, separate subject lines, and a line length of 72 characters.  These rules are well documented in Chris Beam's blog post.</p>"},{"location":"contributing/how-to-contribute/#signed-off-by","title":"Signed-off-by","text":"<p>Each commit must include a \"Signed-off-by\" line in the commit message (<code>git commit -s</code>). This sign-off indicates that you agree the commit satisfies the Developer Certificate of Origin (DCO).</p>"},{"location":"contributing/how-to-contribute/#commit-email-address","title":"Commit Email Address","text":"<p>Your commit email address must match your GitHub email address. For more information, see https://help.github.com/articles/setting-your-commit-email-address-in-git/</p>"},{"location":"contributing/how-to-contribute/#important-github-requirements","title":"Important GitHub Requirements","text":"<p>A pull request cannot merged until it has passed these status checks:</p> <ul> <li>The build must pass all checks</li> <li>The PR must be approved by at least two reviewers without any   outstanding requests for changes</li> </ul>"},{"location":"contributing/how-to-contribute/#inclusive-language","title":"Inclusive Language","text":"<ul> <li>Consider that users who will read the source code and documentation are from different background and cultures and that they have different preferences.</li> <li>Avoid potential offensive terms and, for instance, prefer \"allow list and deny list\" to \"white list and black list\".</li> <li>We believe that we all have a role to play to improve our world, and even if writing inclusive code and documentation might not look like a huge improvement, it's a first step in the right direction.</li> <li>We suggest to refer to Microsoft bias free writing guidelines and Google inclusive doc writing guide as starting points.</li> </ul>"},{"location":"contributing/how-to-contribute/#credits","title":"Credits","text":"<p>This document is based on Hyperledger Sawtooth's Contributing documentation.</p>"},{"location":"contributing/reporting-a-bug/","title":"Reporting a Bug","text":"<p>To report a bug, submit an issue in our public issue tracker.</p> <p>When reporting an issue, please provide as much detail as possible about how to reproduce it. If possible, explain how to reproduce the issue. Details are very helpful. Please include the following information:</p> <ul> <li>Operating system and version (if Mac, include the processor)</li> <li>Project version</li> <li>Environment details (virtual, physical, etc.)</li> <li>Steps to reproduce the issue</li> <li>Actual results</li> <li>Expected results</li> </ul>"},{"location":"contributing/requesting-a-change/","title":"Requesting a Change","text":"<p>Paladin is a powerful tool which serves a wide range of use cases. Put yourself in our shoes \u2013 with a project of this size, it can be challenging to maintain existing functionality while constantly adding new features at the same time. We highly value every idea or contribution from our community, and we kindly ask you to take the time to read the following guidelines before  submitting your change request in our public issue tracker. This will help us  better understand the proposed change, and how it will benefit the community.</p> <p>This guide is our best effort to explain the criteria and reasoning behind our decisions when evaluating change requests and considering them for implementation. </p>"},{"location":"contributing/requesting-a-change/#before-creating-an-issue","title":"Before creating an issue","text":"<p>Before you invest your time to fill out and submit a change request, we kindly ask you to do some preliminary work by answering some questions to determine if your idea is a good fit and matches the project's philosophy and tone.</p> <p>Please find answers to the following questions before creating an issue.</p>"},{"location":"contributing/requesting-a-change/#its-not-a-bug-its-a-feature","title":"It's not a bug, it's a feature","text":"<p>Change requests are intended for suggesting minor adjustments, ideas for new features, or to influence the project's direction and vision. It is important to note that change requests are not intended for reporting bugs, as they're missing essential information for debugging.</p> <p>If you want to report a bug, please refer to our bug reporting guide instead.</p>"},{"location":"contributing/requesting-a-change/#source-of-inspiration","title":"Source of inspiration","text":"<p>If you have seen your idea implemented in similar project, make sure to collect enough information on its implementation before submitting, as this allows us to evaluate potential fit more quickly. Explain what you like and dislike about the implementation.</p>"},{"location":"contributing/requesting-a-change/#benefit-for-the-community","title":"Benefit for the community","text":"<p>Our Discord server is the best place to connect with our community. When  evaluating new ideas, it's essential to seek input from other users and consider  alternative viewpoints. This approach helps to implement new features in a way that benefits a large number of users.</p>"},{"location":"contributing/requesting-a-change/#issue-template","title":"Issue template","text":"<p>Now that you have taken the time to do the necessary preliminary work and ensure  that your idea meets our requirements, you are invited to create a change request. The following guide will walk you through all necessary steps to help you submit a comprehensive and useful issue:</p> <ul> <li>Title</li> <li>Context optional</li> <li>Description</li> <li>Related links</li> <li>Use cases</li> <li>Visuals optional</li> <li>Checklist</li> </ul>"},{"location":"contributing/requesting-a-change/#title","title":"Title","text":"<p>A good title is short and descriptive. It should be a one-sentence executive summary of the idea, so the potential impact and benefit for the community can  be inferred from the title.</p>"},{"location":"contributing/requesting-a-change/#context","title":"Context optional","text":"<p>Before describing your idea, you can provide additional context for us to understand what you are trying to achieve. Explain the circumstances in which you're using Paladin, and what you think might be relevant. Don't write about the change request here.</p> <p>Why we need this</p> <p>Some ideas might only benefit specific settings, environments or edge cases. With a little context, change requests can be prioritized more accurately.</p>"},{"location":"contributing/requesting-a-change/#description","title":"Description","text":"<p>Next, provide a detailed and clear description of your idea. Explain why your  idea is relevant to Paladin and must be implemented here, and not in one of its dependencies.</p> <ul> <li> <p>Explain the what, not the why \u2013 don't explain     the benefits of your idea here, we're getting there.     Focus on describing the proposed change request as precisely as possible.</p> </li> <li> <p>Keep it short and concise \u2013 be brief and to the point when describing      your idea, there is no need to over-describe it. Maintainers and future     users will be grateful for having to read less.</p> </li> <li> <p>One idea at a time \u2013 if you have multiple ideas that don't belong  together, please open separate change requests for each of those ideas.</p> </li> <li> <p> Stretch goal \u2013 if you have a customization or another way to add the proposed change, you can help other users by sharing it here before we maintainers can add it to our code base.</p> </li> </ul> <p>Why we need this</p> <p>To understand and evaluate your proposed change, we need to have a clear understanding of your idea. By providing a detailed and precise description, you can help save you and us time spent discussing further clarification of your idea in the comments.</p>"},{"location":"contributing/requesting-a-change/#related-links","title":"Related links","text":"<p>Please provide any relevant links to issues, discussions, or documentation  sections related to your change request. If you (or someone else) already discussed this idea with the community on our discussion board, please include  the link to the discussion as well.</p> <p>Why we need this</p> <p>Related links help us gain a comprehensive understanding of your change request by providing additional context. Additionally, linking to previous issues and discussions allows us to quickly evaluate the feedback and input already provided by the community.</p>"},{"location":"contributing/requesting-a-change/#use-cases","title":"Use cases","text":"<p>Explain how your change request would work from a user's perspective \u2013 what's the expected impact and why does it not only benefit you, but other users? How many of them? Furthermore, would it potentially break existing functionality?</p> <p>Why we need this</p> <p>Understanding the use cases and benefits of an idea is crucial in evaluating its potential impact and usefulness for the project and its users. This information helps us to understand the expected value of the idea and how it aligns with the goals of the project.</p>"},{"location":"contributing/requesting-a-change/#visuals","title":"Visuals optional","text":"<p>We now have a clear and detailed description of your idea, including information  on its potential use cases and relevant links for context. If you have any  visuals, such as sketches, screenshots, mockups, or external assets, you may  present them in this section.</p> <p>Tip</p> <p>You can drag and drop the files here or include links to external assets.</p> <p>Additionally, if you have seen this change, feature, or improvement used  elsewhere, please provide an example by showcasing  it and describing how it was implemented and incorporated.</p> <p>Why we need this</p> <p>Illustrations and visuals can help us maintainers better understand and envision your idea. Screenshots, sketches, or mockups can create an additional level of detail and clarity that text alone may not be able to convey. Also, seeing how your idea has been implemented in other projects can help us understand its potential impact and feasibility in Paladin, which helps us maintainers evaluate and triage change requests.</p>"},{"location":"contributing/requesting-a-change/#checklist","title":"Checklist","text":"<p>Thanks for following the change request guide and creating a high-quality  change request. This section ensures that you have read this guide and have worked to your best knowledge to provide us with every piece of information to  review your idea for Paladin.</p> <p>We'll take it from here.</p>"},{"location":"contributing/requesting-a-change/#credits","title":"Credits","text":"<p>This document is based on Material for MkDocs Requesting a Change.</p>"},{"location":"getting-started/installation-advanced/","title":"Paladin Advanced Installation Guide","text":"<p>This guide covers advanced installation options for deploying Paladin using Helm, providing detailed control over various configuration options for different deployment scenarios.</p>"},{"location":"getting-started/installation-advanced/#installation-modes","title":"Installation Modes","text":"<ol> <li>devnet (default) \u2014 Sandbox/demo network, ideal for a quick start and getting a first taste of Paladin.</li> <li>customnet \u2014 Full control: explicitly configure each Paladin node and its settings.</li> <li>attach \u2014 Connect to an existing Paladin network and reuse deployed contracts.</li> <li>operator-only \u2014 Install only the operator, then apply CRs manually.</li> </ol>"},{"location":"getting-started/installation-advanced/#mode-devnet-default","title":"Mode: <code>devnet</code> (default)","text":"<p>Deploys a complete, ready-to-use Paladin network including domains and smart contract resources with default settings (3 nodes).</p> <p>Default installation:</p> <pre><code>helm install paladin paladin/paladin-operator -n paladin --create-namespace\n</code></pre> <p>Refer to the provided <code>values.yaml</code> for additional configurable options, including: <code>Number of nodes</code>, <code>node name prefixes</code>, <code>ports</code>, <code>images</code>, <code>environment variables</code>, etc.</p> <p>Example custom installation:</p> <pre><code>helm install paladin paladin/paladin-operator -n paladin --create-namespace \\\n  --set nodeCount=5 \\\n  --set paladin.nodeNamePrefix=worker \\\n  --set besu.nodeNamePrefix=evm\n</code></pre>"},{"location":"getting-started/installation-advanced/#mode-customnet","title":"Mode: <code>customnet</code>","text":"<p>The <code>customnet</code> mode offers maximum flexibility, allowing detailed customization of <code>Paladin</code>, <code>Registry</code>, and <code>PaladinDomain</code> CRs. It is ideal for advanced use cases, such as integration with external blockchain nodes.</p> <p>Declare each node explicitly for setups:</p> <p>Example <code>values-customnet.yaml</code>:</p> <pre><code>mode: customnet\npaladinNodes:\n  - name: central-bank\n    baseLedgerEndpoint:\n      type: endpoint       # or \"local\" for built-in Besu\n      endpoint:\n        jsonrpc: https://mychain.rpc\n        ws:    wss://mychain.ws\n        auth:\n          enabled: false    # set true + secretName if basic auth\n          secretName: creds\n    domains:\n      - noto\n      - zeto\n      - pente\n    registries:\n      - evm-reg\n    transports:\n      - name: grpc\n        plugin:\n          type: c-shared\n          library: /app/transports/libgrpc.so\n        config:\n          port: 9000\n          address: 0.0.0.0\n        ports:\n          transportGrpc:\n            port: 9000\n            targetPort: 9000\n    service:\n      type: NodePort    # change service type if needed\n      ports:\n        rpcHttp:\n          port: 8548\n          nodePort: 31748   # Do not set nodePort in case the service.type is not NodePort\n        rpcWs:\n          port: 8549\n          nodePort: 31749   # Do not set nodePort in case the service.type is not NodePort\n    database:\n      mode: sidecarPostgres\n      migrationMode: auto\n      # pvcTemplate:         # Optional - Set a custom PVC for the DB\n      #   storageClassName: \"my-storage\"\n      #   accessModes:\n      #   - ReadWriteOnce\n      #   capacity:\n      #     storage: 10Gi\n    secretBackedSigners:\n      - name: signer-auto-wallet\n        secret: central-bank.keys\n        type: autoHDWallet  # or preConfigured. in case of preConfigured you must create the secret with the seed\n        keySelector: \".*\"\n    paladinRegistration:\n      registryAdminNode: central-bank  # The admin node that manages the registry\n      registryAdminKey: registry.operator\n      registry: evm-registry\n    config: |\n      log:\n        level: debug  # Log levels: debug, info, warn, error\n      publicTxManager:\n        gasLimit:\n          gasEstimateFactor: 2.0\n</code></pre> <p>Run:</p> <pre><code>helm install paladin paladin/paladin-operator -n paladin --create-namespace \\\n  -f values-customnet.yaml\n</code></pre> <p>This will deploy one Paladin node named <code>bank</code>. Add more entries under <code>paladinNodes</code> to scale horizontally.</p> <p>Refer to the provided <code>values-customnet.yaml</code> for additional configurable options.</p>"},{"location":"getting-started/installation-advanced/#options","title":"Options","text":"<p>Here are some customizations that you will most likely make when in stalling with <code>customnet</code> mode.</p>"},{"location":"getting-started/installation-advanced/#baseledgerendpoint","title":"<code>baseLedgerEndpoint</code>","text":"<p>Configure the JSON RPC and websocket endpoints for the blockchain node you wish this Paladin node to connect to. If the blockchain node is secured with basic auth, you may specify a secret that contains the username and password: <pre><code>apiVersion: v1\nkind: Secret\nmetadata:\n  name: central-bank-auth\n  namespace: paladin\ndata:\n  password: ...\n  username: ...\ntype: Opaque\n</code></pre></p>"},{"location":"getting-started/installation-advanced/#transportsconfigexternalhostname","title":"<code>transports.config.externalHostname</code>","text":"<p><code>externalHostname</code> - this can be set if the Paladin node needs to be accessible from outside the cluster. The value will depend on how ingress in configured, which is outside the scope of the Paladin project. If not set it defaults to the internal hostname, which is adequate if all Paladin nodes are running in the same cluster</p>"},{"location":"getting-started/installation-advanced/#secretbackedsigners","title":"<code>secretBackedSigners</code>","text":"<p>Set <code>autoHDWallet</code> or <code>preConfigured</code> (must supply <code>keys.yaml</code>). To use a HD wallet with a seed phrase generated by the Paladin operator, set <code>type: autoHDWallet</code> and provide the name of a secret you wish the seed phrase to be stored into, but which doesn't exist yet.</p> <pre><code>secretBackedSigners:\n- keySelector: .*\n  name: signer-1\n  secret: central-bank.keys\n  type: autoHDWallet\n</code></pre> <p>If you wish to use an existing seed phrase, store a file containing this seed phrase in a secret, and reference it in the signer configuration.</p> <pre><code>seed:\n  inline: manual rabbit frost hero squeeze adjust link crystal filter purchase fruit border coin able tennis until endless crisp scout figure wage finish aisle rabbit\n</code></pre> <pre><code>kubectl create secret generic &lt;secret name&gt; --from-file=keys.yaml=&lt;file name&gt;\n</code></pre> <pre><code>secretBackedSigners:\n- keySelector: .*\n  name: signer-1\n  secret: central-bank.keys\n</code></pre>"},{"location":"getting-started/installation-advanced/#mode-attach","title":"Mode: <code>attach</code>","text":"<p>Set <code>mode=attach</code> when you have an existing blockchain network and previously deployed smart contracts that you want Paladin to reuse. This mode will tipacly be in use after you already installed Paladin in <code>customnet</code> mode and now you want to run another paladin node in a different namespace/cluster and attach it to the already existing blockchain and paladin network.</p>"},{"location":"getting-started/installation-advanced/#retrieving-contract-addresses","title":"Retrieving Contract Addresses","text":"<p>First, get the registries addresses and paladinDomain addresses:</p> <pre><code>kubectl -n paladin get paladindomains,paladinregistries\n</code></pre> <p>Example output:</p> <pre><code>NAME                                  STATUS      DOMAIN_REGISTRY                              DEPLOYMENT      LIBRARY\npaladindomain.core.paladin.io/noto    Available   0xd93630936d854fb718b89537cce4acc97fd50463   noto-factory    /app/domains/libnoto.so\npaladindomain.core.paladin.io/pente   Available   0x48c11bbb7caa77329d53b89235fec64733a24ca1   pente-factory   /app/domains/pente.jar\npaladindomain.core.paladin.io/zeto    Available   0xc29ed8a902ff787445bdabee9ae5e2380089959d   zeto-factory    /app/domains/libzeto.so\n\nNAME                                           TYPE   STATUS      CONTRACT\npaladinregistry.core.paladin.io/evm-registry   evm    Available   0x07f73d1d358fe9f178b0b8a749a99bf08e4e4140\n</code></pre> <p>and past it to the values file:</p> <pre><code>smartContractsReferences:\n  notoFactory:\n    address: \"0xd93630936d854fb718b89537cce4acc97fd50463\"\n  zetoFactory:\n    address: \"0xc29ed8a902ff787445bdabee9ae5e2380089959d\"\n  penteFactory:\n    address: \"0x48c11bbb7caa77329d53b89235fec64733a24ca1\"\n  registry:\n    address: \"0x4456307ef3f119dac17a5e974d2640f714e6edb0\"\n</code></pre> <p>Also, make sure you configure the <code>paladinRegistration.registryAdminNode</code> so it will be the admin node (the node that deployed the smart contracts), like this: <pre><code>paladinRegistration:\n  registryAdminNode: central-bank # the node name that deployed the smart contracts\n  registryAdminKey:  ...\n  registry:         ...\n</code></pre></p>"},{"location":"getting-started/installation-advanced/#example-values-attachyaml","title":"Example <code>values-attach.yaml</code>:","text":"<p>Here is a full example of the <code>values-attach.yaml</code>:</p> <pre><code>mode: attach\nsmartContractsReferences:\n  notoFactory:\n    address: \"0xd93630936d854fb718b89537cce4acc97fd50463\"\n  zetoFactory:\n    address: \"0xc29ed8a902ff787445bdabee9ae5e2380089959d\"\n  penteFactory:\n    address: \"0x48c11bbb7caa77329d53b89235fec64733a24ca1\"\n  registry:\n    address: \"0x4456307ef3f119dac17a5e974d2640f714e6edb0\"\n\npaladinNodes:\npaladinNodes:\n- name: bank-a\n  baseLedgerEndpoint:\n    type: endpoint\n    endpoint:\n      jsonrpc: https://mychain.rpc\n      ws:    wss://mychain.ws\n      auth:\n        enabled: false    # set true + secretName if basic auth\n        secretName: creds\n  domains:\n    - noto\n    - zeto\n    - pente\n  registries:\n    - evm-reg\n  transports:\n    - name: grpc\n      plugin:\n        type: c-shared\n        library: /app/transports/libgrpc.so\n      config:\n        port: 9000\n        address: 0.0.0.0\n      ports:\n        transportGrpc:\n          port: 9000\n          targetPort: 9000\n  service:\n    type: NodePort    # change service type if needed\n    ports:\n      rpcHttp:\n        port: 8548\n        nodePort: 31748  # Do not set nodePort in case the service.type is not NodePort\n      rpcWs:\n        port: 8549\n        nodePort: 31749  # Do not set nodePort in case the service.type is not NodePort\n  database:\n    mode: sidecarPostgres\n    migrationMode: auto\n  secretBackedSigners:\n    - name: signer-auto-wallet\n      secret: central-bank.keys\n      type: autoHDWallet  # or preConfigured. in case of preConfigured you must create the secret with the seed\n      keySelector: \".*\"\n  config: |\n    log:\n      level: debug\n    publicTxManager:\n      gasLimit:\n        gasEstimateFactor: 2.0\n  paladinRegistration:\n    registryAdminNode: central-bank\n    registryAdminKey:  registry.operator\n    registry:         evm-registry\n</code></pre> <p>Run:</p> <pre><code>helm install paladin paladin/paladin-operator -n paladin --create-namespace \\\n  -f values-attach.yaml\n</code></pre>"},{"location":"getting-started/installation-advanced/#mode-operator-only","title":"Mode: <code>operator-only</code>","text":"<p>Deploys only the Paladin operator without additional nodes or domains, useful for advanced scenarios or incremental setup:</p> <pre><code>helm install paladin paladin/paladin-operator --set mode=operator-only\n</code></pre>"},{"location":"getting-started/installation-advanced/#advanced-customization","title":"Advanced Customization","text":"<p>For users requiring direct application and full manual control, including complex multi-cluster setups, refer to the manual installation documentation. This approach involves manually configuring CRs, applying individual artifacts, and managing explicit node and domain settings.</p>"},{"location":"getting-started/installation-manual/","title":"Paladin Manual Installation Guide","text":"<p>This guide provides detailed instructions for manually installing a Paladin Network by directly configuring the Custom Resources (CRs) provided by the Paladin operator. This approach offers maximum flexibility for customizing network configuration, node distribution, blockchain integration, and smart contract management.</p>"},{"location":"getting-started/installation-manual/#prerequisites","title":"Prerequisites","text":"<p>Ensure the following are installed:</p> <ul> <li>Helm v3</li> <li>kubectl</li> </ul>"},{"location":"getting-started/installation-manual/#step-1-install-paladin-operator-crds","title":"Step 1: Install Paladin Operator CRDs","text":"<p>Add the Paladin Helm repository:</p> <pre><code>helm repo add paladin https://LF-Decentralized-Trust-labs.github.io/paladin --force-update\nhelm upgrade --install paladin-crds paladin/paladin-operator-crd\n</code></pre>"},{"location":"getting-started/installation-manual/#step-2-install-cert-manager-crds","title":"Step 2: Install cert-manager CRDs","text":"<p>Install the cert-manager required by Paladin:</p> <pre><code>helm repo add jetstack https://charts.jetstack.io --force-update\nhelm install cert-manager --namespace cert-manager --version v1.16.1 jetstack/cert-manager --create-namespace --set crds.enabled=true\n</code></pre>"},{"location":"getting-started/installation-manual/#step-3-install-paladin-operator","title":"Step 3: Install Paladin Operator","text":"<p>Install the Paladin operator in <code>operator-only</code> mode (without additional resources):</p> <pre><code>helm upgrade --install paladin paladin/paladin-operator -n paladin --create-namespace --set mode=operator-only\n</code></pre>"},{"location":"getting-started/installation-manual/#step-4-deploy-smart-contract-artifacts","title":"Step 4: Deploy Smart Contract Artifacts","text":"<p>Download the latest release artifacts:</p> <pre><code>wget https://github.com/LF-Decentralized-Trust-labs/paladin/releases/download/latest/artifacts.tar.gz\ntar -xzvf artifacts.tar.gz\n</code></pre> <p>Apply the self-signed certificate issuer in all Kubernetes clusters:</p> <pre><code>kubectl -n paladin apply -f cert_issuer_selfsigned.yaml\n</code></pre> <p>On the primary Kubernetes cluster (designated for smart contract deployment), apply the smart contract resources:</p> <p>The contents of these CRs should not be modified, with the exception of * <code>spec.node</code>- the name of the node that will be used to submit the transactions. Change this if you wish to name your first node something other than <code>node1</code>. * <code>spec.from</code>- the identifier of the key that will be used to sign the transactions. Change this if you wish to use a specific key from your signer for this purpose.</p> <pre><code>kubectl -n paladin apply -f core_v1alpha1_paladinregistry.yaml\nkubectl -n paladin apply -f core_v1alpha1_smartcontractdeployment_noto_factory.yaml\nkubectl -n paladin apply -f core_v1alpha1_smartcontractdeployment_pente_factory.yaml\nkubectl -n paladin apply -f core_v1alpha1_smartcontractdeployment_registry.yaml\nkubectl -n paladin apply -f core_v1alpha1_smartcontractdeployment_zeto_factory.yaml\n# Apply other provided Zeto-related smart contracts similarly\nkubectl -n paladin apply -f core_v1alpha1_smartcontractdeployment_zeto_g16_anon_batch.yaml\nkubectl -n paladin apply -f core_v1alpha1_smartcontractdeployment_zeto_g16_anon_enc_batch.yaml\nkubectl -n paladin apply -f core_v1alpha1_smartcontractdeployment_zeto_g16_anon_enc.yaml\nkubectl -n paladin apply -f core_v1alpha1_smartcontractdeployment_zeto_g16_anon_nullifier_transfer_batch.yaml\nkubectl -n paladin apply -f core_v1alpha1_smartcontractdeployment_zeto_g16_anon_nullifier_transfer.yaml\nkubectl -n paladin apply -f core_v1alpha1_smartcontractdeployment_zeto_g16_anon.yaml\nkubectl -n paladin apply -f core_v1alpha1_smartcontractdeployment_zeto_g16_deposit.yaml\nkubectl -n paladin apply -f core_v1alpha1_smartcontractdeployment_zeto_g16_withdraw_batch.yaml\nkubectl -n paladin apply -f core_v1alpha1_smartcontractdeployment_zeto_g16_withdraw_nullifier_batch.yaml\nkubectl -n paladin apply -f core_v1alpha1_smartcontractdeployment_zeto_g16_withdraw_nullifier.yaml\nkubectl -n paladin apply -f core_v1alpha1_smartcontractdeployment_zeto_g16_withdraw.yaml\nkubectl -n paladin apply -f core_v1alpha1_smartcontractdeployment_zeto_impl_anon_enc.yaml\nkubectl -n paladin apply -f core_v1alpha1_smartcontractdeployment_zeto_impl_anon_nullifier.yaml\nkubectl -n paladin apply -f core_v1alpha1_smartcontractdeployment_zeto_impl_anon.yaml\nkubectl -n paladin apply -f core_v1alpha1_smartcontractdeployment_zeto_poseidon_unit2l.yaml\nkubectl -n paladin apply -f core_v1alpha1_smartcontractdeployment_zeto_poseidon_unit3l.yaml\nkubectl -n paladin apply -f core_v1alpha1_smartcontractdeployment_zeto_smt_lib.yaml\nkubectl -n paladin apply -f core_v1alpha1_transactioninvoke_zeto_register_anon_enc.yaml\nkubectl -n paladin apply -f core_v1alpha1_transactioninvoke_zeto_register_anon_nullifier.yaml\nkubectl -n paladin apply -f core_v1alpha1_transactioninvoke_zeto_register_anon.yaml\n</code></pre> <p>Note: Smart contracts won't be fully deployed until Step 7.</p>"},{"location":"getting-started/installation-manual/#step-5-create-an-evm-registry","title":"Step 5: Create an EVM Registry","text":"<p>Create the registry CR. For the primary cluster, use a deployment name; subsequent clusters should reference the existing contract address:</p> <p>The <code>paladin.io/registry-name</code> label is significant as this what Paladin nodes will use to reference the registry.</p> <pre><code>apiVersion: core.paladin.io/v1alpha1\nkind: PaladinRegistry\nmetadata:\n  name: evm-registry\n  namespace: paladin\n  labels:\n    paladin.io/registry-name: evm-registry\nspec:\n  type: evm\n  evm:\n    smartContractDeployment: registry  # use 'contractAddress' if referencing existing deployment\n    # contractAddress: \"0x....\"\n  plugin:\n    library: /app/registries/libevm.so\n    type: c-shared\n</code></pre>"},{"location":"getting-started/installation-manual/#step-6-deploy-domains","title":"Step 6: Deploy Domains","text":"<p>Deploy Paladin domains (<code>noto</code>, <code>pente</code>, <code>zeto</code>). Similar to the registry, reference the deployment name initially and contract address for subsequent clusters:</p> <pre><code>apiVersion: core.paladin.io/v1alpha1\nkind: PaladinDomain\nmetadata:\n  name: noto\n  namespace: paladin\n  labels:\n    paladin.io/domain-name: noto\nspec:\n  plugin:\n    library: /app/domains/libnoto.so\n    type: c-shared\n  smartContractDeployment: noto-factory  # use 'contractAddress' for existing deployments\n  # contractAddress: \"0x....\"\n</code></pre> <p>Repeat for <code>pente</code> and <code>zeto</code> domains.</p> pente <pre><code>apiVersion: core.paladin.io/v1alpha1\nkind: PaladinDomain\nmetadata:\n  labels:\n    paladin.io/domain-name: pente\n  name: pente\n  namespace: paladin\nspec:\n  plugin:\n    class: io.kaleido.paladin.pente.domain.PenteDomainFactory\n    library: /app/domains/pente.jar\n    type: jar\n  smartContractDeployment: pente-factory\n</code></pre> zeto <pre><code>apiVersion: core.paladin.io/v1alpha1\nkind: PaladinDomain\nmetadata:\n  labels:\n    paladin.io/domain-name: zeto\n  name: zeto\n  namespace: paladin\nspec:\n  allowSigning: true\n  configJSON: |\n    {\n      \"domainContracts\": {\n        \"implementations\": [\n          {\n            \"name\": \"Zeto_Anon\",\n            \"circuits\": {\n              \"deposit\": {\n                \"name\": \"deposit\"\n              },\n              \"withdraw\": {\n                \"name\": \"withdraw\"\n              },\n              \"transfer\": {\n                \"name\": \"anon\"\n              },\n              \"transferLocked\": {\n                \"name\": \"anon\"\n              }\n            }\n          },\n          {\n            \"name\": \"Zeto_AnonEnc\",\n            \"circuits\": {\n              \"deposit\": {\n                \"name\": \"deposit\"\n              },\n              \"withdraw\": {\n                \"name\": \"withdraw\"\n              },\n              \"transfer\": {\n                \"name\": \"anon_enc\",\n                \"usesEncryption\": true\n              },\n              \"transferLocked\": {\n                \"name\": \"anon_enc\",\n                \"usesEncryption\": true\n              }\n            }\n          },\n          {\n            \"name\": \"Zeto_AnonNullifier\",\n            \"circuits\": {\n              \"deposit\": {\n                \"name\": \"deposit\"\n              },\n              \"withdraw\": {\n                \"name\": \"withdraw_nullifier\",\n                \"usesNullifiers\": true\n              },\n              \"transfer\": {\n                \"name\": \"anon_nullifier_transfer\",\n                \"usesNullifiers\": true\n              },\n              \"transferLocked\": {\n                \"name\": \"anon_nullifier_transferLocked\",\n                \"usesNullifiers\": true\n              }\n            }\n          }\n        ]\n      },\n      \"snarkProver\": {\n        \"circuitsDir\": \"/app/domains/zeto/zkp\",\n        \"provingKeysDir\": \"/app/domains/zeto/zkp\"\n      }\n    }\n  plugin:\n    library: /app/domains/libzeto.so\n    type: c-shared\n  smartContractDeployment: zeto-factory\n</code></pre>"},{"location":"getting-started/installation-manual/#step-7-create-paladin-nodes","title":"Step 7: Create Paladin Nodes","text":"<p>Deploy Paladin nodes with unique names. The first node (<code>node1</code>) handles initial smart contract deployment transactions:</p> <p>Paladin node names need to be unique within the network. The Paladin node that is used to deploy the smart contracts must be called <code>node1</code>. </p> <pre><code>apiVersion: core.paladin.io/v1alpha1\nkind: Paladin\nmetadata:\n  name: node1\n  namespace: paladin\nspec:\n  baseLedgerEndpoint:\n    type: endpoint\n    endpoint:\n      jsonrpc: https://chain-json-rpc-endpoint\n      ws: wss://chain-json-ws-endpoint\n      auth:\n        type: secret\n        secret:\n          name: node1-auth\n  config: |\n    log:\n      level: debug\n  database:\n    migrationMode: auto\n    mode: sidecarPostgres\n  domains:\n  - labelSelector:\n      matchLabels:\n        paladin.io/domain-name: noto\n  - labelSelector:\n      matchLabels:\n        paladin.io/domain-name: zeto\n  - labelSelector:\n      matchLabels:\n        paladin.io/domain-name: pente\n  registries:\n  - labelSelector:\n      matchLabels:\n        paladin.io/registry-name: evm-registry\n  secretBackedSigners:\n  - keySelector: .*\n    name: signer-1\n    secret: node1.keys\n    type: autoHDWallet\n  service:\n    ports:\n    - name: rpc-http\n      nodePort: 31548\n      port: 8548\n      protocol: TCP\n    - name: rpc-ws\n      nodePort: 31549\n      port: 8549\n      protocol: TCP\n    type: NodePort\n  transports:\n  - configJSON: |\n      {\n        \"port\": 9000,\n        \"address\": \"0.0.0.0\"\n      }\n    name: grpc\n    plugin:\n      library: /app/transports/libgrpc.so\n      type: c-shared\n    ports:\n    - name: transport-grpc\n      port: 9000\n      protocol: TCP\n      targetPort: 9000\n    tls:\n      certName: paladin-node1-mtls\n      issuer: selfsigned-issuer\n      secretName: paladin-node1-mtls\n</code></pre> <p>Adjust configuration fields as needed:</p>"},{"location":"getting-started/installation-manual/#baseledgerendpoint","title":"<code>baseLedgerEndpoint</code>","text":"<pre><code>  baseLedgerEndpoint:\n    type: endpoint\n    endpoint:\n      jsonrpc: https://chain-json-rpc-endpoint\n      ws: wss://chain-json-ws-endpoint\n      auth:\n        type: secret\n        secret:\n          name: node1-auth\n</code></pre> <p>Configure the JSON RPC and websocket endpoints for the blockchain node you wish this Paladin node to connect to.</p> <p>If the blockchain node is secured with basic auth, you may specify a secret that contains the username and password.</p> <pre><code>apiVersion: v1\nkind: Secret\nmetadata:\n  name: node1-auth\n  namespace: paladin\ndata:\n  password: ...\n  username: ...\ntype: Opaque\n</code></pre>"},{"location":"getting-started/installation-manual/#config","title":"<code>config</code>","text":"<p>This section contains an inline yaml/json string which can be used to provide Paladin node configuration that isn't exposed directly by the CRD. If the same configuration value is provided in the inline config and a CR field, the CR field will take precedence.</p> <p>This code file defines the full set of Paladin configuration.</p>"},{"location":"getting-started/installation-manual/#database","title":"<code>database</code>","text":"<p><pre><code>database:\n  migrationMode: auto\n  mode: sidecarPostgres\n</code></pre> <code>mode</code> may be <code>sidecarPostgres</code> or <code>embeddedSQLite</code></p>"},{"location":"getting-started/installation-manual/#domains","title":"<code>domains</code>","text":"<p><pre><code>domains:\n- labelSelector:\n    matchLabels:\n      paladin.io/domain-name: noto\n- labelSelector:\n    matchLabels:\n      paladin.io/domain-name: zeto\n- labelSelector:\n    matchLabels:\n      paladin.io/domain-name: pente\n</code></pre> The domain name labels provided here must match the labels on the domains created in step 6.</p>"},{"location":"getting-started/installation-manual/#registries","title":"<code>registries</code>","text":"<p><pre><code>registries:\n- labelSelector:\n    matchLabels:\n      paladin.io/registry-name: evm-registry\n</code></pre> The registry name label provided here must match the label on the registry created in step 5.</p>"},{"location":"getting-started/installation-manual/#secretbackedsigners","title":"<code>secretBackedSigners</code>","text":"<p>To use a HD wallet with a seed phrase generated by the Paladin operator, set <code>type: autoHDWallet</code> and provide the name of a secret you wish the seed phrase to be stored into, but which doesn't exist yet.</p> <pre><code>secretBackedSigners:\n- keySelector: .*\n  name: signer-1\n  secret: node1.keys\n  type: autoHDWallet\n</code></pre> <p>If you wish to use an existing seed phrase, store a file containing this seed phrase in a secret, and reference it in the signer configuration.</p> <pre><code>seed:\n  inline: manual rabbit frost hero squeeze adjust link crystal filter purchase fruit border coin able tennis until endless crisp scout figure wage finish aisle rabbit\n</code></pre> <pre><code>kubectl create secret generic &lt;secret name&gt; --from-file=keys.yaml=&lt;file name&gt;\n</code></pre> <pre><code>secretBackedSigners:\n- keySelector: .*\n  name: signer-1\n  secret: node1.keys\n</code></pre>"},{"location":"getting-started/installation-manual/#service","title":"<code>service</code>","text":"<p><pre><code>service:\n  ports:\n  - name: rpc-http\n    nodePort: 31548\n    port: 8548\n    protocol: TCP\n  - name: rpc-ws\n    nodePort: 31549\n    port: 8549\n    protocol: TCP\n  type: NodePort\n</code></pre> This section is used directly to create a Kubernetes service to expose the Paladin HTTP and WS servers. See the Kubernetes documentation to understand how to configure this section.</p> <p>The Paladin http and ws servers run on ports <code>8548</code> and <code>8549</code> by default. </p>"},{"location":"getting-started/installation-manual/#transports","title":"<code>transports</code>","text":"<pre><code>transports:\n- configJSON: |\n    {\n      \"port\": 9000,\n      \"address\": \"0.0.0.0\",\n      \"externalHostname\": ...\n    }\n  name: grpc\n  plugin:\n    library: /app/transports/libgrpc.so\n    type: c-shared\n  ports:\n  - name: transport-grpc\n    port: 9000\n    protocol: TCP\n    targetPort: 9000\n  tls:\n    certName: paladin-node1-mtls\n    issuer: selfsigned-issuer\n    secretName: paladin-node1-mtls\n</code></pre> <p><code>configJSON</code> is the json/yaml configuration that is passed to the transport plugin. Specifically for the grpc transport plugin * <code>port</code>- this must match <code>targetPort</code> in the <code>ports</code> configuration * <code>externalHostname</code> - this can be set if the Paladin node needs to be accessible from outside the cluster. The value will depend on how ingress in configured, which is outside the scope of the Paladin project. If not set it defaults to the internal hostname, which is adequate if all Paladin nodes are running in the same cluster</p> <p>The certificates generated to match the <code>tls</code> configuration section is added in by the operator to the configuration for the transport plugin.</p>"},{"location":"getting-started/installation-manual/#step-8-register-paladin-nodes","title":"Step 8: Register Paladin Nodes","text":"<p>Create <code>PaladinRegistration</code> CRs for each Paladin node:</p> <ul> <li><code>spec.registryAdminKey</code>: the identifier for the key that will be used to sign the root registration transaction</li> <li><code>spec.nodeAdminKey</code>: the identifier for the key that is used as the owner of the registration, and used to register transports These keys come from the signer configured on the node being registered.</li> </ul> <pre><code>apiVersion: core.paladin.io/v1alpha1\nkind: PaladinRegistration\nmetadata:\n  name: node1\nspec:\n  node: node1 # &lt;node name&gt;\n  nodeAdminKey: registry.node1 # registry.&lt;node name&gt;\n  registry: evm-registry\n  registryAdminKey: registry.operator\n  registryAdminNode: node1 # &lt;admin node name&gt;\n  transports:\n  - grpc\n</code></pre> <p>Repeat for all nodes created in Step 7.</p>"},{"location":"getting-started/installation-manual/#multi-cluster-considerations","title":"Multi-cluster Considerations","text":"<p>When deploying across multiple clusters:</p> <ul> <li>Follow Steps 1-8 on the primary cluster.</li> <li>On additional clusters, reference the existing contract addresses obtained from the primary cluster (Steps 5-6).</li> </ul>"},{"location":"getting-started/installation/","title":"Installation","text":"<p>Installing the operator in <code>devnet</code> mode also installs and configures a three node Paladin network and three node Besu network. This is great way to get up and running quickly with Paladin and to try out the tutorials.</p>"},{"location":"getting-started/installation/#pre-requisites","title":"Pre-requisites","text":"<ul> <li>Access to a running Kubernetes cluster</li> <li>helm <code>v3</code> installed</li> <li>kubectl installed</li> </ul>"},{"location":"getting-started/installation/#quick-start-with-kind","title":"Quick Start with kind","text":"<p>If you are new to Kubernetes or simply need a quick way to get a running cluster, kind provides a lightweight way to run a local Kubernetes cluster on your machine. This repo contains a starter config file for kind which will open up the container ports used by the Paladin charts below.</p> <p>You can create a new cluster with:</p> <pre><code>curl https://raw.githubusercontent.com/LF-Decentralized-Trust-labs/paladin/refs/heads/main/operator/paladin-kind.yaml -L -O\nkind create cluster --name paladin --config paladin-kind.yaml\n</code></pre> <p>If you need to start over, you can delete the cluster with:</p> <pre><code>kind delete cluster --name paladin\n</code></pre> <p>This guide is not intended to be a full tutorial on kind or Kubernetes - please refer to the relevant documentation for any issues with these tools.</p>"},{"location":"getting-started/installation/#installation_1","title":"Installation","text":""},{"location":"getting-started/installation/#step-1-install-the-crd-chart","title":"Step 1: Install the CRD Chart","text":"<p>Install the CRD chart that contains the necessary Custom Resource Definitions (CRDs) for the Paladin operator:</p> <pre><code>helm repo add paladin https://LF-Decentralized-Trust-labs.github.io/paladin --force-update\nhelm upgrade --install paladin-crds paladin/paladin-operator-crd\n</code></pre>"},{"location":"getting-started/installation/#step-2-install-cert-manager-crds","title":"Step 2: Install cert-manager CRDs","text":"<p>Install the cert-manager CRDs:</p> <pre><code>helm repo add jetstack https://charts.jetstack.io --force-update\nhelm install cert-manager --namespace cert-manager --version v1.16.1 jetstack/cert-manager --create-namespace --set crds.enabled=true\n</code></pre>"},{"location":"getting-started/installation/#step-3-install-the-paladin-operator-chart","title":"Step 3: Install the Paladin Operator Chart","text":"<p>Install the Paladin operator chart:</p> <pre><code>helm upgrade --install paladin paladin/paladin-operator -n paladin --create-namespace\n</code></pre>"},{"location":"getting-started/installation/#outcome","title":"Outcome","text":"<p>This process will:</p> <ol> <li>Install the cert-manager chart.</li> <li>Install the paladin-operator chart.</li> <li>Create a Besu network with 3 nodes.</li> <li>Create a Paladin network with 3 nodes, each associated with one of the Besu nodes.</li> <li>Deploy smart contracts to the blockchain.</li> </ol> <p>You can verify the running pods with:</p> <pre><code>kubectl config set-context --current --namespace paladin\nkubectl get pods\n</code></pre> See output <pre><code>NAME                                READY   STATUS    RESTARTS      AGE\nbesu-node1-0                        1/1     Running   0             104s\nbesu-node2-0                        1/1     Running   0             104s\nbesu-node3-0                        1/1     Running   0             104s\npaladin-node1-0                     2/2     Running   0             104s\npaladin-node2-0                     2/2     Running   0             104s\npaladin-node3-0                     2/2     Running   0             104s\npaladin-operator-6f6864854b-bp8nb   1/1     Running   0             115s\n</code></pre> <p>Check service details with:</p> <pre><code>kubectl get service\n</code></pre> See output <pre><code>NAME               TYPE        CLUSTER-IP     EXTERNAL-IP   PORT(S)                                                                        AGE\nbesu-node1         NodePort    10.96.83.214   &lt;none&gt;        8547:31547/TCP,30303:31627/TCP,30303:31627/UDP,8545:31545/TCP,8546:31546/TCP   6m53s\nbesu-node2         NodePort    10.96.73.13    &lt;none&gt;        8547:31647/TCP,30303:32690/TCP,30303:32690/UDP,8545:31645/TCP,8546:31646/TCP   6m53s\nbesu-node3         NodePort    10.96.22.234   &lt;none&gt;        8547:31747/TCP,30303:31724/TCP,30303:31724/UDP,8545:31745/TCP,8546:31746/TCP   6m53s\npaladin-node1      NodePort    10.96.174.16   &lt;none&gt;        8548:31548/TCP,8549:31549/TCP,9000:31702/TCP                                   6m54s\npaladin-node2      NodePort    10.96.15.53    &lt;none&gt;        8548:31648/TCP,8549:31649/TCP,9000:32414/TCP                                   6m54s\npaladin-node3      NodePort    10.96.130.13   &lt;none&gt;        8548:31748/TCP,8549:31749/TCP,9000:30324/TCP                                   6m52s\npaladin-operator   ClusterIP   10.96.134.58   &lt;none&gt;        80/TCP                                                                         7m4s\n</code></pre> <p>Check the status of the smart contract deployments with:</p> <pre><code>kubectl get scd\n</code></pre> See output <pre><code>NAME                                     STATUS    DEPS   TRANSACTIONID                          CONTRACT                                     TXHASH                                                               FAILURE\nnoto-factory                             Success   0/0    37bdf054-1586-4fbf-8fb1-8ba82e804b03   0x097e199bb09c67fa1a70f8faabd6bb6f73b46b1b   0x101d18edc452cdfb7708482a82931c008e7614ff6c827b6ecf19e603f28bd64e\npente-factory                            Success   0/0    5cb8afba-6d6b-4c69-86d1-dced6d66e72b   0x1d9490417b1aa097ea4ed5a2c7461a91a24e1b94   0x2c6ab8d2815f7ecca8f5455a279d9f318cc73812fe4e8527dfa60d3faf01fb5c\nregistry                                 Success   0/0    cb6c4d54-6cbb-459e-92fb-d9a4b1253008   0x8e4368f9cff103257fc0d3fee65de96da476f402   0x6a524eee8f9c3f728b8c55ef128da81658e022e01f68dd7f09a907cd0b41792b\nzeto-factory                             Success   0/0    1956cd0d-57df-4ead-938d-6b2ca7c3af24   0xbe51a4d2a77dab8523062f36310cadb9491e212f   0xe47fd55373bf2c5e088c22535fb27c171db879150ca9b81743482a6dbe51b82b\nzeto-g16-check-hashes-value              Success   0/0    bb89354d-d33b-4918-a76e-815204ae621f   0xce09a6f94fedbf7797aadedc607485afb3f12ae0   0xd63f0105c02473910ec7ad43d8f19907ab08c6909eefc77ece4b2815a03c74a8\nzeto-g16-check-inputs-outputs            Success   0/0    e0793bf5-5daa-499e-a999-1d054b0c09cf   0x16a030887b97b7d5425159478f5545f5d37370f1   0x2f1f000f08e0189e2aa6b806d0e672dc5b6df1f1f009bf8792994d7b92b3ee18\nzeto-g16-check-inputs-outputs-batch      Success   0/0    20d75131-7de9-4378-aa24-27a6788e9efe   0xacdc6af26b831a9307125e4e1ec0a5601eae6f0a   0x7dc9999281ad5d3b27408893d64ba4c7550292b64c3134d3733cbc110b6245f5\nzeto-g16-verifier-anon                   Success   0/0    714cddd9-7479-4d18-8554-fd9cb49d6047   0x76da65751f561b35a7befe3c8b7f1ba1d5617882   0xc9b5fef8c99319f84a14330ebd6e4778994bdea2857a65a404920d7a2c8c838d\nzeto-g16-verifier-anon-batch             Success   0/0    5037f730-cc9e-4875-8a11-428be74855ae   0x65e9b3b755d551b1a938aae02154118bfb2e7d5c   0xf1ee595b494927ca50122c9893a8acfdf93d74c6e53fd04be3b3da5f840f8a4b\nzeto-g16-verifier-anon-enc               Success   0/0    906b8cd2-40c1-4992-8fe8-1e696eaf9d70   0x99287a67da14dd77d21a15536b7e3671f9a51772   0x38ae90890d20c43cfc25a05a36dd5e9b9085ba13578585b04f76c2bf7cc02ab3\nzeto-g16-verifier-anon-enc-batch         Success   0/0    1b1a9713-a695-499f-a28c-c8b02f74ab82   0x1bcaff14e2c1652e2b552b0ee31c77223301b8e1   0x5f826fe4fe871afdd2214608fefda755997baffc7d110a5a1d44b81b65c9fdb9\nzeto-g16-verifier-anon-nullifier         Success   0/0    e0c2a915-7b1f-43e4-a485-de2ae119e472   0x4c1f4a2d0789a74a1814101c223ce839c6f9d506   0x71ec84c3647a6d0de12fe3dcf8165cb10a06e110cdabc7d873fe5929110bb76b\nzeto-g16-verifier-anon-nullifier-batch   Success   0/0    b533c381-9c68-499e-80e0-2d97a69ee530   0xf88b34f7fe5a5c5d6b3d08e555ba22560ecbb59a   0x453e5ddcb77f6462d8aad9b1e68d6b979b8d454c330f8faae10cbd1f1a7c0b1c\nzeto-impl-anon                           Success   0/0    22c9cf3a-2219-4b6d-aa63-3657a480c611   0x600bfecadf35e5d88c6672dbfd9b1ed4d9e28845   0xe7e7ab84afb10e4a4086096fc4f6a96b1119b52a5560b3a90a18f34f8b8dbf93\nzeto-impl-anon-enc                       Success   0/0    e39b026a-1f74-4d9d-af6b-269ccebb8dc0   0xf4cdfd7ff695500eb2a28430d59958a36d06fe54   0x854e8f34791243c9672c02d962ed23d4df6b8f6e679881961badcc430ceed855\nzeto-impl-anon-nullifier                 Success   2/2    2d1d51d6-a16f-4745-bfff-9eeaeb9ae06e   0xc423ccfec92822b3354dd540fa8fa4b6b5bbd923   0x43698f6172c2be0daaa149ee5cad8c547a9ba06de1d6e0492aaf5f49516d583f\nzeto-poseidon-unit2l                     Success   0/0    d40f7043-300e-4345-981d-08470514ac34   0xa74a67ed2eaa058aaa640168e7738ac9de73804e   0x8138c9ce405e56c72c6da6cac2f549a0d36b5c9443c154e49d96f1bedbbce8ca\nzeto-poseidon-unit3l                     Success   0/0    f8c5de8b-dfa3-4c0e-b3b1-9cdafbb25b54   0x01b3139005de155632fb52107757b1688b937ed1   0x859a12b1705c7e061a288857d4ad9c4a27b42ca6d9fd3804a1fdaa2c11b3cc38\nzeto-smt-lib                             Success   2/2    ac199436-51a4-4d91-98a3-b80b8074e3a8   0xf79adb0e771c08783d79cc223ec2be29166e8858   0x6ed5ee88c82d7f8c0ef9c56976d9f274c9a5ce5e575a9932be49b118cbdb502a\n</code></pre> <p>Check the status of Paladin nodes publishing registration details to one another:</p> <pre><code>kubectl get reg\n</code></pre> See output <pre><code>NAME    PUBLISHED\nnode1   2\nnode2   2\nnode3   2\n</code></pre>"},{"location":"getting-started/installation/#accessing-the-ui","title":"Accessing the UI","text":"<p>Each Paladin node runs an instance of the Paladin UI at the path <code>/ui</code>. If you used the provided kind config (or a similar port mapping), you should be able to access the UI for each node:</p> <ul> <li>http://localhost:31548/ui</li> <li>http://localhost:31648/ui</li> <li>http://localhost:31748/ui</li> </ul> <p>Learn about interacting with the UI, and try out the Tutorials.</p>"},{"location":"getting-started/installation/#advanced-installation","title":"Advanced installation","text":"<p>This guide is designed for first-time Paladin users looking for a quick and easy introduction. For more complex setups, integration with existing blockchain networks, or detailed customization, please refer to the Advanced Installation or Manual Installation guides.</p>"},{"location":"getting-started/installation/#troubleshooting","title":"Troubleshooting","text":"<p>If you encounter any issues during installation, please refer to the Troubleshooting Guide.  </p> <p>If your issue is not listed or remains unresolved, please report it by opening an issue on the Paladin GitHub page.</p>"},{"location":"getting-started/installation/#uninstall","title":"Uninstall","text":"<p>To remove the Paladin operator and related resources, run the following commands: <pre><code>helm uninstall paladin -n paladin\nhelm uninstall paladin-crds\nkubectl delete namespace paladin\nhelm uninstall cert-manager -n cert-manager\nkubectl delete -f https://github.com/cert-manager/cert-manager/releases/download/v1.16.1/cert-manager.crds.yaml\nkubectl delete namespace cert-manager\n</code></pre></p>"},{"location":"getting-started/troubleshooting/","title":"Troubleshooting","text":""},{"location":"getting-started/troubleshooting/#issue-page-not-loaded-in-ui","title":"Issue: Page Not Loaded in UI","text":"<p>If you navigate to <code>http://localhost:31548/ui</code> and the page does not load, there may be several potential issues. Follow these steps to troubleshoot:</p> <ol> <li> <p>Check Pod Status:    Ensure all relevant pods are running. You can do this by executing: <pre><code>kubectl -n paladin get pods\n</code></pre>    Look for any pods that are not in a <code>Running</code> state.</p> </li> <li> <p>Verify Service Health:    Confirm that the services are healthy and accessible. Run: <pre><code>kubectl -n paladin get services\n</code></pre>    Ensure the service associated with the UI is exposed and reachable.</p> </li> <li> <p>Test Network Connectivity:    Verify that the issue is not isolated to your local machine's connection to the pod. Use the following steps:</p> </li> <li><code>exec</code> into another pod in the cluster and test connectivity between pods:      <pre><code>kubectl -n paladin -it exec paladin-node2-0 -- curl http://paladin-node2:8548/ui\n</code></pre></li> <li> <p>If pods fail to communicate with each other, there may be a networking issue.</p> </li> <li> <p>Check Cluster and Docker Versions:    If network issues exist, you might be using an outdated version of your cluster or Docker. Ensure the following minimum versions are installed:</p> </li> <li>Docker: Version <code>27.0.0</code> or newer  </li> <li>Kind: Version <code>0.24.0</code> or newer  </li> </ol> <p>You can check the versions by running:    <pre><code>docker --version\nkind --version\n</code></pre></p> <p>If you identify an outdated version, upgrade your tools and retry.</p>"},{"location":"getting-started/user-interface/","title":"User Interface","text":""},{"location":"getting-started/user-interface/#introduction","title":"Introduction","text":"<p>The graphical user interface makes it easy to visualize activity in Paladin nodes. This includes transactions, events, submissions and node registry.</p>"},{"location":"getting-started/user-interface/#accessing-the-ui","title":"Accessing the UI","text":"<p>Each Paladin node runs an instance of the Paladin UI at the path <code>/ui</code>. If you used the provided kind config (or a similar port mapping) with devnet, you should be able to access the UI for each node:</p> <ul> <li>http://localhost:31548/ui</li> <li>http://localhost:31648/ui</li> <li>http://localhost:31748/ui</li> </ul>"},{"location":"getting-started/user-interface/#interacting-with-the-ui","title":"Interacting with the UI","text":""},{"location":"getting-started/user-interface/#indexer","title":"Indexer","text":"<p>The indexer panel displays recent transactions and events. </p> <p></p> <p>Clicking on <code>View Details</code> brings up detailed information on a transaction or event:</p> <p></p>"},{"location":"getting-started/user-interface/#submissions","title":"Submissions","text":"<p>The submissions panel displays recent transactions that have been submitted with an option to display only those in pending state.</p> <p></p>"},{"location":"getting-started/user-interface/#registry","title":"Registry","text":"<p>The registry panel displays the list of Paladin nodes.</p> <p></p>"},{"location":"reference/architecture/","title":"Architecture","text":"<p>Explain the architecture of the project, including diagrams.</p>"},{"location":"reference/commands/","title":"Commands","text":"<p>Explain the different commands that are available.</p>"},{"location":"reference/roadmap/","title":"Roadmap","text":"<p>Provide details on the roadmap for the project.</p> <p>If you would like to see something added to the roadmap, please see \"Requesting a Change\".</p>"},{"location":"reference/apis/bidx/","title":"bidx_*","text":""},{"location":"reference/apis/bidx/#bidx_decodetransactionevents","title":"<code>bidx_decodeTransactionEvents</code>","text":""},{"location":"reference/apis/bidx/#parameters","title":"Parameters","text":"<ol> <li><code>transactionHash</code>: <code>Bytes32</code></li> <li><code>abi</code>: <code>Entry[]</code></li> <li><code>resultFormat</code>: <code>JSONFormatOptions</code></li> </ol>"},{"location":"reference/apis/bidx/#returns","title":"Returns","text":"<ol> <li><code>events</code>: <code>EventWithData[]</code></li> </ol>"},{"location":"reference/apis/bidx/#bidx_getblockbynumber","title":"<code>bidx_getBlockByNumber</code>","text":""},{"location":"reference/apis/bidx/#parameters_1","title":"Parameters","text":"<ol> <li><code>blockNumber</code>: <code>HexUint64</code></li> </ol>"},{"location":"reference/apis/bidx/#returns_1","title":"Returns","text":"<ol> <li><code>block</code>: <code>IndexedBlock</code></li> </ol>"},{"location":"reference/apis/bidx/#bidx_getblocktransactionsbynumber","title":"<code>bidx_getBlockTransactionsByNumber</code>","text":""},{"location":"reference/apis/bidx/#parameters_2","title":"Parameters","text":"<ol> <li><code>blockNumber</code>: <code>HexUint64</code></li> </ol>"},{"location":"reference/apis/bidx/#returns_2","title":"Returns","text":"<ol> <li><code>transactions</code>: <code>IndexedTransaction[]</code></li> </ol>"},{"location":"reference/apis/bidx/#bidx_getconfirmedblockheight","title":"<code>bidx_getConfirmedBlockHeight</code>","text":""},{"location":"reference/apis/bidx/#returns_3","title":"Returns","text":"<ol> <li><code>blockHeight</code>: <code>HexUint64</code></li> </ol>"},{"location":"reference/apis/bidx/#bidx_gettransactionbyhash","title":"<code>bidx_getTransactionByHash</code>","text":""},{"location":"reference/apis/bidx/#parameters_3","title":"Parameters","text":"<ol> <li><code>blockHash</code>: <code>Bytes32</code></li> </ol>"},{"location":"reference/apis/bidx/#returns_4","title":"Returns","text":"<ol> <li><code>transaction</code>: <code>IndexedTransaction</code></li> </ol>"},{"location":"reference/apis/bidx/#bidx_gettransactionbynonce","title":"<code>bidx_getTransactionByNonce</code>","text":""},{"location":"reference/apis/bidx/#parameters_4","title":"Parameters","text":"<ol> <li><code>from</code>: <code>EthAddress</code></li> <li><code>nonce</code>: <code>HexUint64</code></li> </ol>"},{"location":"reference/apis/bidx/#returns_5","title":"Returns","text":"<ol> <li><code>transaction</code>: <code>IndexedTransaction</code></li> </ol>"},{"location":"reference/apis/bidx/#bidx_gettransactioneventsbyhash","title":"<code>bidx_getTransactionEventsByHash</code>","text":""},{"location":"reference/apis/bidx/#parameters_5","title":"Parameters","text":"<ol> <li><code>transactionHash</code>: <code>Bytes32</code></li> </ol>"},{"location":"reference/apis/bidx/#returns_6","title":"Returns","text":"<ol> <li><code>events</code>: <code>IndexedEvent[]</code></li> </ol>"},{"location":"reference/apis/bidx/#bidx_queryindexedblocks","title":"<code>bidx_queryIndexedBlocks</code>","text":""},{"location":"reference/apis/bidx/#parameters_6","title":"Parameters","text":"<ol> <li><code>query</code>: <code>QueryJSON</code></li> </ol>"},{"location":"reference/apis/bidx/#returns_7","title":"Returns","text":"<ol> <li><code>blocks</code>: <code>IndexedBlock[]</code></li> </ol>"},{"location":"reference/apis/bidx/#bidx_queryindexedevents","title":"<code>bidx_queryIndexedEvents</code>","text":""},{"location":"reference/apis/bidx/#parameters_7","title":"Parameters","text":"<ol> <li><code>query</code>: <code>QueryJSON</code></li> </ol>"},{"location":"reference/apis/bidx/#returns_8","title":"Returns","text":"<ol> <li><code>events</code>: <code>IndexedEvent[]</code></li> </ol>"},{"location":"reference/apis/bidx/#bidx_queryindexedtransactions","title":"<code>bidx_queryIndexedTransactions</code>","text":""},{"location":"reference/apis/bidx/#parameters_8","title":"Parameters","text":"<ol> <li><code>query</code>: <code>QueryJSON</code></li> </ol>"},{"location":"reference/apis/bidx/#returns_9","title":"Returns","text":"<ol> <li><code>transactions</code>: <code>IndexedTransaction[]</code></li> </ol>"},{"location":"reference/apis/keymgr/","title":"keymgr_*","text":""},{"location":"reference/apis/keymgr/#keymgr_resolveethaddress","title":"<code>keymgr_resolveEthAddress</code>","text":""},{"location":"reference/apis/keymgr/#parameters","title":"Parameters","text":"<ol> <li><code>keyIdentifier</code>: <code>string</code></li> </ol>"},{"location":"reference/apis/keymgr/#returns","title":"Returns","text":"<ol> <li><code>ethAddress</code>: <code>EthAddress</code></li> </ol>"},{"location":"reference/apis/keymgr/#keymgr_resolvekey","title":"<code>keymgr_resolveKey</code>","text":""},{"location":"reference/apis/keymgr/#parameters_1","title":"Parameters","text":"<ol> <li><code>keyIdentifier</code>: <code>string</code></li> <li><code>algorithm</code>: <code>string</code></li> <li><code>verifierType</code>: <code>string</code></li> </ol>"},{"location":"reference/apis/keymgr/#returns_1","title":"Returns","text":"<ol> <li><code>mapping</code>: <code>KeyMappingAndVerifier</code></li> </ol>"},{"location":"reference/apis/keymgr/#keymgr_reversekeylookup","title":"<code>keymgr_reverseKeyLookup</code>","text":""},{"location":"reference/apis/keymgr/#parameters_2","title":"Parameters","text":"<ol> <li><code>algorithm</code>: <code>string</code></li> <li><code>verifierType</code>: <code>string</code></li> <li><code>verifier</code>: <code>string</code></li> </ol>"},{"location":"reference/apis/keymgr/#returns_2","title":"Returns","text":"<ol> <li><code>mapping</code>: <code>KeyMappingAndVerifier</code></li> </ol>"},{"location":"reference/apis/keymgr/#keymgr_wallets","title":"<code>keymgr_wallets</code>","text":""},{"location":"reference/apis/keymgr/#returns_3","title":"Returns","text":"<ol> <li><code>wallets</code>: <code>string[]</code></li> </ol>"},{"location":"reference/apis/pgroup/","title":"pgroup_*","text":""},{"location":"reference/apis/pgroup/#pgroup_call","title":"<code>pgroup_call</code>","text":""},{"location":"reference/apis/pgroup/#parameters","title":"Parameters","text":"<ol> <li><code>call</code>: <code>PrivacyGroupEVMCall</code></li> </ol>"},{"location":"reference/apis/pgroup/#returns","title":"Returns","text":"<ol> <li><code>data</code>: <code>RawJSON</code></li> </ol>"},{"location":"reference/apis/pgroup/#pgroup_creategroup","title":"<code>pgroup_createGroup</code>","text":""},{"location":"reference/apis/pgroup/#parameters_1","title":"Parameters","text":"<ol> <li><code>spec</code>: <code>PrivacyGroupInput</code></li> </ol>"},{"location":"reference/apis/pgroup/#returns_1","title":"Returns","text":"<ol> <li><code>group</code>: <code>PrivacyGroup</code></li> </ol>"},{"location":"reference/apis/pgroup/#pgroup_createmessagelistener","title":"<code>pgroup_createMessageListener</code>","text":""},{"location":"reference/apis/pgroup/#parameters_2","title":"Parameters","text":"<ol> <li><code>listener</code>: <code>PrivacyGroupMessageListener</code></li> </ol>"},{"location":"reference/apis/pgroup/#returns_2","title":"Returns","text":"<ol> <li><code>success</code>: <code>bool</code></li> </ol>"},{"location":"reference/apis/pgroup/#pgroup_deletemessagelistener","title":"<code>pgroup_deleteMessageListener</code>","text":""},{"location":"reference/apis/pgroup/#parameters_3","title":"Parameters","text":"<ol> <li><code>listenerName</code>: <code>string</code></li> </ol>"},{"location":"reference/apis/pgroup/#returns_3","title":"Returns","text":"<ol> <li><code>success</code>: <code>bool</code></li> </ol>"},{"location":"reference/apis/pgroup/#pgroup_getgroupbyaddress","title":"<code>pgroup_getGroupByAddress</code>","text":""},{"location":"reference/apis/pgroup/#parameters_4","title":"Parameters","text":"<ol> <li><code>address</code>: <code>EthAddress</code></li> </ol>"},{"location":"reference/apis/pgroup/#returns_4","title":"Returns","text":"<ol> <li><code>pgroup</code>: <code>PrivacyGroup</code></li> </ol>"},{"location":"reference/apis/pgroup/#pgroup_getgroupbyid","title":"<code>pgroup_getGroupById</code>","text":""},{"location":"reference/apis/pgroup/#parameters_5","title":"Parameters","text":"<ol> <li><code>domainName</code>: <code>string</code></li> <li><code>id</code>: <code>HexBytes</code></li> </ol>"},{"location":"reference/apis/pgroup/#returns_5","title":"Returns","text":"<ol> <li><code>pgroup</code>: <code>PrivacyGroup</code></li> </ol>"},{"location":"reference/apis/pgroup/#pgroup_getmessagebyid","title":"<code>pgroup_getMessageById</code>","text":""},{"location":"reference/apis/pgroup/#parameters_6","title":"Parameters","text":"<ol> <li><code>id</code>: <code>UUID</code></li> </ol>"},{"location":"reference/apis/pgroup/#returns_6","title":"Returns","text":"<ol> <li><code>msg</code>: <code>PrivacyGroupMessage</code></li> </ol>"},{"location":"reference/apis/pgroup/#pgroup_getmessagelistener","title":"<code>pgroup_getMessageListener</code>","text":""},{"location":"reference/apis/pgroup/#parameters_7","title":"Parameters","text":"<ol> <li><code>listenerName</code>: <code>string</code></li> </ol>"},{"location":"reference/apis/pgroup/#returns_7","title":"Returns","text":"<ol> <li><code>listener</code>: <code>PrivacyGroupMessageListener</code></li> </ol>"},{"location":"reference/apis/pgroup/#pgroup_querygroups","title":"<code>pgroup_queryGroups</code>","text":""},{"location":"reference/apis/pgroup/#parameters_8","title":"Parameters","text":"<ol> <li><code>query</code>: <code>QueryJSON</code></li> </ol>"},{"location":"reference/apis/pgroup/#returns_8","title":"Returns","text":"<ol> <li><code>pgroups</code>: <code>PrivacyGroup[]</code></li> </ol>"},{"location":"reference/apis/pgroup/#pgroup_querygroupswithmember","title":"<code>pgroup_queryGroupsWithMember</code>","text":""},{"location":"reference/apis/pgroup/#parameters_9","title":"Parameters","text":"<ol> <li><code>member</code>: <code>string</code></li> <li><code>query</code>: <code>QueryJSON</code></li> </ol>"},{"location":"reference/apis/pgroup/#returns_9","title":"Returns","text":"<ol> <li><code>pgroups</code>: <code>PrivacyGroup[]</code></li> </ol>"},{"location":"reference/apis/pgroup/#pgroup_querymessagelisteners","title":"<code>pgroup_queryMessageListeners</code>","text":""},{"location":"reference/apis/pgroup/#parameters_10","title":"Parameters","text":"<ol> <li><code>query</code>: <code>QueryJSON</code></li> </ol>"},{"location":"reference/apis/pgroup/#returns_10","title":"Returns","text":"<ol> <li><code>listeners</code>: <code>PrivacyGroupMessageListener[]</code></li> </ol>"},{"location":"reference/apis/pgroup/#pgroup_querymessages","title":"<code>pgroup_queryMessages</code>","text":""},{"location":"reference/apis/pgroup/#parameters_11","title":"Parameters","text":"<ol> <li><code>query</code>: <code>QueryJSON</code></li> </ol>"},{"location":"reference/apis/pgroup/#returns_11","title":"Returns","text":"<ol> <li><code>msgs</code>: <code>PrivacyGroupMessage[]</code></li> </ol>"},{"location":"reference/apis/pgroup/#pgroup_sendmessage","title":"<code>pgroup_sendMessage</code>","text":""},{"location":"reference/apis/pgroup/#parameters_12","title":"Parameters","text":"<ol> <li><code>msg</code>: <code>PrivacyGroupMessageInput</code></li> </ol>"},{"location":"reference/apis/pgroup/#returns_12","title":"Returns","text":"<ol> <li><code>msgId</code>: <code>UUID</code></li> </ol>"},{"location":"reference/apis/pgroup/#pgroup_sendtransaction","title":"<code>pgroup_sendTransaction</code>","text":""},{"location":"reference/apis/pgroup/#parameters_13","title":"Parameters","text":"<ol> <li><code>tx</code>: <code>PrivacyGroupEVMTXInput</code></li> </ol>"},{"location":"reference/apis/pgroup/#returns_13","title":"Returns","text":"<ol> <li><code>transactionId</code>: <code>UUID</code></li> </ol>"},{"location":"reference/apis/pgroup/#pgroup_startmessagelistener","title":"<code>pgroup_startMessageListener</code>","text":""},{"location":"reference/apis/pgroup/#parameters_14","title":"Parameters","text":"<ol> <li><code>listenerName</code>: <code>string</code></li> </ol>"},{"location":"reference/apis/pgroup/#returns_14","title":"Returns","text":"<ol> <li><code>success</code>: <code>bool</code></li> </ol>"},{"location":"reference/apis/pgroup/#pgroup_stopmessagelistener","title":"<code>pgroup_stopMessageListener</code>","text":""},{"location":"reference/apis/pgroup/#parameters_15","title":"Parameters","text":"<ol> <li><code>listenerName</code>: <code>string</code></li> </ol>"},{"location":"reference/apis/pgroup/#returns_15","title":"Returns","text":"<ol> <li><code>success</code>: <code>bool</code></li> </ol>"},{"location":"reference/apis/pstate/","title":"pstate_*","text":""},{"location":"reference/apis/pstate/#pstate_listschemas","title":"<code>pstate_listSchemas</code>","text":""},{"location":"reference/apis/pstate/#parameters","title":"Parameters","text":"<ol> <li><code>domain</code>: <code>string</code></li> </ol>"},{"location":"reference/apis/pstate/#returns","title":"Returns","text":"<ol> <li><code>schemas</code>: <code>Schema[]</code></li> </ol>"},{"location":"reference/apis/pstate/#pstate_querycontractnullifiers","title":"<code>pstate_queryContractNullifiers</code>","text":""},{"location":"reference/apis/pstate/#parameters_1","title":"Parameters","text":"<ol> <li><code>domain</code>: <code>string</code></li> <li><code>contractAddress</code>: <code>EthAddress</code></li> <li><code>schemaRef</code>: <code>Bytes32</code></li> <li><code>query</code>: <code>QueryJSON</code></li> <li><code>qualifier</code>: <code>StateStatusQualifier</code></li> </ol>"},{"location":"reference/apis/pstate/#returns_1","title":"Returns","text":"<ol> <li><code>states</code>: <code>State[]</code></li> </ol>"},{"location":"reference/apis/pstate/#pstate_querycontractstates","title":"<code>pstate_queryContractStates</code>","text":""},{"location":"reference/apis/pstate/#parameters_2","title":"Parameters","text":"<ol> <li><code>domain</code>: <code>string</code></li> <li><code>contractAddress</code>: <code>EthAddress</code></li> <li><code>schemaRef</code>: <code>Bytes32</code></li> <li><code>query</code>: <code>QueryJSON</code></li> <li><code>qualifier</code>: <code>StateStatusQualifier</code></li> </ol>"},{"location":"reference/apis/pstate/#returns_2","title":"Returns","text":"<ol> <li><code>states</code>: <code>State[]</code></li> </ol>"},{"location":"reference/apis/pstate/#pstate_querynullifiers","title":"<code>pstate_queryNullifiers</code>","text":""},{"location":"reference/apis/pstate/#parameters_3","title":"Parameters","text":"<ol> <li><code>domain</code>: <code>string</code></li> <li><code>schemaRef</code>: <code>Bytes32</code></li> <li><code>query</code>: <code>QueryJSON</code></li> <li><code>qualifier</code>: <code>StateStatusQualifier</code></li> </ol>"},{"location":"reference/apis/pstate/#returns_3","title":"Returns","text":"<ol> <li><code>states</code>: <code>State[]</code></li> </ol>"},{"location":"reference/apis/pstate/#pstate_querystates","title":"<code>pstate_queryStates</code>","text":""},{"location":"reference/apis/pstate/#parameters_4","title":"Parameters","text":"<ol> <li><code>domain</code>: <code>string</code></li> <li><code>schemaRef</code>: <code>Bytes32</code></li> <li><code>query</code>: <code>QueryJSON</code></li> <li><code>qualifier</code>: <code>StateStatusQualifier</code></li> </ol>"},{"location":"reference/apis/pstate/#returns_4","title":"Returns","text":"<ol> <li><code>states</code>: <code>State[]</code></li> </ol>"},{"location":"reference/apis/pstate/#pstate_storestate","title":"<code>pstate_storeState</code>","text":""},{"location":"reference/apis/pstate/#parameters_5","title":"Parameters","text":"<ol> <li><code>domain</code>: <code>string</code></li> <li><code>contractAddress</code>: <code>EthAddress</code></li> <li><code>schemaRef</code>: <code>Bytes32</code></li> <li><code>data</code>: <code>RawJSON</code></li> </ol>"},{"location":"reference/apis/pstate/#returns_5","title":"Returns","text":"<ol> <li><code>state</code>: <code>State</code></li> </ol>"},{"location":"reference/apis/ptx/","title":"ptx_*","text":""},{"location":"reference/apis/ptx/#ptx_call","title":"<code>ptx_call</code>","text":""},{"location":"reference/apis/ptx/#parameters","title":"Parameters","text":"<ol> <li><code>transaction</code>: <code>TransactionCall</code></li> </ol>"},{"location":"reference/apis/ptx/#returns","title":"Returns","text":"<ol> <li><code>result</code>: <code>RawJSON</code></li> </ol>"},{"location":"reference/apis/ptx/#ptx_createblockchaineventlistener","title":"<code>ptx_createBlockchainEventListener</code>","text":""},{"location":"reference/apis/ptx/#parameters_1","title":"Parameters","text":"<ol> <li><code>listener</code>: <code>BlockchainEventListener</code></li> </ol>"},{"location":"reference/apis/ptx/#returns_1","title":"Returns","text":"<ol> <li><code>success</code>: <code>bool</code></li> </ol>"},{"location":"reference/apis/ptx/#ptx_createreceiptlistener","title":"<code>ptx_createReceiptListener</code>","text":""},{"location":"reference/apis/ptx/#parameters_2","title":"Parameters","text":"<ol> <li><code>listener</code>: <code>TransactionReceiptListener</code></li> </ol>"},{"location":"reference/apis/ptx/#returns_2","title":"Returns","text":"<ol> <li><code>success</code>: <code>bool</code></li> </ol>"},{"location":"reference/apis/ptx/#ptx_decodecall","title":"<code>ptx_decodeCall</code>","text":""},{"location":"reference/apis/ptx/#parameters_3","title":"Parameters","text":"<ol> <li><code>callData</code>: <code>HexBytes</code></li> <li><code>dataFormat</code>: <code>JSONFormatOptions</code></li> </ol>"},{"location":"reference/apis/ptx/#returns_3","title":"Returns","text":"<ol> <li><code>decodedCall</code>: <code>ABIDecodedData</code></li> </ol>"},{"location":"reference/apis/ptx/#ptx_decodeerror","title":"<code>ptx_decodeError</code>","text":""},{"location":"reference/apis/ptx/#parameters_4","title":"Parameters","text":"<ol> <li><code>revertData</code>: <code>HexBytes</code></li> <li><code>dataFormat</code>: <code>JSONFormatOptions</code></li> </ol>"},{"location":"reference/apis/ptx/#returns_4","title":"Returns","text":"<ol> <li><code>decodedError</code>: <code>ABIDecodedData</code></li> </ol>"},{"location":"reference/apis/ptx/#ptx_decodeevent","title":"<code>ptx_decodeEvent</code>","text":""},{"location":"reference/apis/ptx/#parameters_5","title":"Parameters","text":"<ol> <li><code>topics</code>: <code>Bytes32[]</code></li> <li><code>data</code>: <code>HexBytes</code></li> <li><code>dataFormat</code>: <code>JSONFormatOptions</code></li> </ol>"},{"location":"reference/apis/ptx/#returns_5","title":"Returns","text":"<ol> <li><code>decodedEvent</code>: <code>ABIDecodedData</code></li> </ol>"},{"location":"reference/apis/ptx/#ptx_deleteblockchaineventlistener","title":"<code>ptx_deleteBlockchainEventListener</code>","text":""},{"location":"reference/apis/ptx/#parameters_6","title":"Parameters","text":"<ol> <li><code>listenerName</code>: <code>string</code></li> </ol>"},{"location":"reference/apis/ptx/#returns_6","title":"Returns","text":"<ol> <li><code>success</code>: <code>bool</code></li> </ol>"},{"location":"reference/apis/ptx/#ptx_deletereceiptlistener","title":"<code>ptx_deleteReceiptListener</code>","text":""},{"location":"reference/apis/ptx/#parameters_7","title":"Parameters","text":"<ol> <li><code>listenerName</code>: <code>string</code></li> </ol>"},{"location":"reference/apis/ptx/#returns_7","title":"Returns","text":"<ol> <li><code>success</code>: <code>bool</code></li> </ol>"},{"location":"reference/apis/ptx/#ptx_getblockchaineventlistener","title":"<code>ptx_getBlockchainEventListener</code>","text":""},{"location":"reference/apis/ptx/#parameters_8","title":"Parameters","text":"<ol> <li><code>listenerName</code>: <code>string</code></li> </ol>"},{"location":"reference/apis/ptx/#returns_8","title":"Returns","text":"<ol> <li><code>listener</code>: <code>BlockchainEventListener</code></li> </ol>"},{"location":"reference/apis/ptx/#ptx_getblockchaineventlistenerstatus","title":"<code>ptx_getBlockchainEventListenerStatus</code>","text":""},{"location":"reference/apis/ptx/#parameters_9","title":"Parameters","text":"<ol> <li><code>listenerName</code>: <code>string</code></li> </ol>"},{"location":"reference/apis/ptx/#returns_9","title":"Returns","text":"<ol> <li><code>listenerStatus</code>: <code>BlockchainEventListenerStatus</code></li> </ol>"},{"location":"reference/apis/ptx/#ptx_getdomainreceipt","title":"<code>ptx_getDomainReceipt</code>","text":""},{"location":"reference/apis/ptx/#parameters_10","title":"Parameters","text":"<ol> <li><code>domain</code>: <code>string</code></li> <li><code>transactionId</code>: <code>UUID</code></li> </ol>"},{"location":"reference/apis/ptx/#returns_10","title":"Returns","text":"<ol> <li><code>domainReceipt</code>: <code>RawJSON</code></li> </ol>"},{"location":"reference/apis/ptx/#ptx_getpreparedtransaction","title":"<code>ptx_getPreparedTransaction</code>","text":""},{"location":"reference/apis/ptx/#parameters_11","title":"Parameters","text":"<ol> <li><code>transactionId</code>: <code>UUID</code></li> </ol>"},{"location":"reference/apis/ptx/#returns_11","title":"Returns","text":"<ol> <li><code>preparedTransaction</code>: <code>PreparedTransaction</code></li> </ol>"},{"location":"reference/apis/ptx/#ptx_getreceiptlistener","title":"<code>ptx_getReceiptListener</code>","text":""},{"location":"reference/apis/ptx/#parameters_12","title":"Parameters","text":"<ol> <li><code>listenerName</code>: <code>string</code></li> </ol>"},{"location":"reference/apis/ptx/#returns_12","title":"Returns","text":"<ol> <li><code>listener</code>: <code>TransactionReceiptListener</code></li> </ol>"},{"location":"reference/apis/ptx/#ptx_getstatereceipt","title":"<code>ptx_getStateReceipt</code>","text":""},{"location":"reference/apis/ptx/#parameters_13","title":"Parameters","text":"<ol> <li><code>transactionId</code>: <code>UUID</code></li> </ol>"},{"location":"reference/apis/ptx/#returns_13","title":"Returns","text":"<ol> <li><code>stateReceipt</code>: <code>TransactionStates</code></li> </ol>"},{"location":"reference/apis/ptx/#ptx_getstoredabi","title":"<code>ptx_getStoredABI</code>","text":""},{"location":"reference/apis/ptx/#parameters_14","title":"Parameters","text":"<ol> <li><code>hashRef</code>: <code>Bytes32</code></li> </ol>"},{"location":"reference/apis/ptx/#returns_14","title":"Returns","text":"<ol> <li><code>storedABI</code>: <code>StoredABI</code></li> </ol>"},{"location":"reference/apis/ptx/#ptx_gettransaction","title":"<code>ptx_getTransaction</code>","text":""},{"location":"reference/apis/ptx/#parameters_15","title":"Parameters","text":"<ol> <li><code>transactionId</code>: <code>UUID</code></li> </ol>"},{"location":"reference/apis/ptx/#returns_15","title":"Returns","text":"<ol> <li><code>transaction</code>: <code>Transaction</code></li> </ol>"},{"location":"reference/apis/ptx/#ptx_gettransactionbyidempotencykey","title":"<code>ptx_getTransactionByIdempotencyKey</code>","text":""},{"location":"reference/apis/ptx/#parameters_16","title":"Parameters","text":"<ol> <li><code>idempotencyKey</code>: <code>string</code></li> </ol>"},{"location":"reference/apis/ptx/#returns_16","title":"Returns","text":"<ol> <li><code>transaction</code>: <code>Transaction</code></li> </ol>"},{"location":"reference/apis/ptx/#ptx_gettransactionfull","title":"<code>ptx_getTransactionFull</code>","text":""},{"location":"reference/apis/ptx/#parameters_17","title":"Parameters","text":"<ol> <li><code>transactionId</code>: <code>UUID</code></li> </ol>"},{"location":"reference/apis/ptx/#returns_17","title":"Returns","text":"<ol> <li><code>transaction</code>: <code>TransactionFull</code></li> </ol>"},{"location":"reference/apis/ptx/#ptx_gettransactionreceipt","title":"<code>ptx_getTransactionReceipt</code>","text":""},{"location":"reference/apis/ptx/#parameters_18","title":"Parameters","text":"<ol> <li><code>transactionId</code>: <code>UUID</code></li> </ol>"},{"location":"reference/apis/ptx/#returns_18","title":"Returns","text":"<ol> <li><code>receipt</code>: <code>TransactionReceipt</code></li> </ol>"},{"location":"reference/apis/ptx/#ptx_gettransactionreceiptfull","title":"<code>ptx_getTransactionReceiptFull</code>","text":""},{"location":"reference/apis/ptx/#parameters_19","title":"Parameters","text":"<ol> <li><code>transactionId</code>: <code>UUID</code></li> </ol>"},{"location":"reference/apis/ptx/#returns_19","title":"Returns","text":"<ol> <li><code>receipt</code>: <code>TransactionReceiptFull</code></li> </ol>"},{"location":"reference/apis/ptx/#ptx_preparetransaction","title":"<code>ptx_prepareTransaction</code>","text":""},{"location":"reference/apis/ptx/#parameters_20","title":"Parameters","text":"<ol> <li><code>transaction</code>: <code>TransactionInput</code></li> </ol>"},{"location":"reference/apis/ptx/#returns_20","title":"Returns","text":"<ol> <li><code>transactionId</code>: <code>UUID</code></li> </ol>"},{"location":"reference/apis/ptx/#ptx_preparetransactions","title":"<code>ptx_prepareTransactions</code>","text":""},{"location":"reference/apis/ptx/#parameters_21","title":"Parameters","text":"<ol> <li><code>transactions</code>: <code>TransactionInput[]</code></li> </ol>"},{"location":"reference/apis/ptx/#returns_21","title":"Returns","text":"<ol> <li><code>transactionIds</code>: <code>UUID[]</code></li> </ol>"},{"location":"reference/apis/ptx/#ptx_queryblockchaineventlisteners","title":"<code>ptx_queryBlockchainEventListeners</code>","text":""},{"location":"reference/apis/ptx/#parameters_22","title":"Parameters","text":"<ol> <li><code>query</code>: <code>QueryJSON</code></li> </ol>"},{"location":"reference/apis/ptx/#returns_22","title":"Returns","text":"<ol> <li><code>listeners</code>: <code>BlockchainEventListener[]</code></li> </ol>"},{"location":"reference/apis/ptx/#ptx_querypreparedtransactions","title":"<code>ptx_queryPreparedTransactions</code>","text":""},{"location":"reference/apis/ptx/#parameters_23","title":"Parameters","text":"<ol> <li><code>query</code>: <code>QueryJSON</code></li> </ol>"},{"location":"reference/apis/ptx/#returns_23","title":"Returns","text":"<ol> <li><code>preparedTransactions</code>: <code>PreparedTransaction[]</code></li> </ol>"},{"location":"reference/apis/ptx/#ptx_queryreceiptlisteners","title":"<code>ptx_queryReceiptListeners</code>","text":""},{"location":"reference/apis/ptx/#parameters_24","title":"Parameters","text":"<ol> <li><code>query</code>: <code>QueryJSON</code></li> </ol>"},{"location":"reference/apis/ptx/#returns_24","title":"Returns","text":"<ol> <li><code>listeners</code>: <code>TransactionReceiptListener[]</code></li> </ol>"},{"location":"reference/apis/ptx/#ptx_querystoredabis","title":"<code>ptx_queryStoredABIs</code>","text":""},{"location":"reference/apis/ptx/#parameters_25","title":"Parameters","text":"<ol> <li><code>query</code>: <code>QueryJSON</code></li> </ol>"},{"location":"reference/apis/ptx/#returns_25","title":"Returns","text":"<ol> <li><code>storedABIs</code>: <code>StoredABI[]</code></li> </ol>"},{"location":"reference/apis/ptx/#ptx_querytransactionreceipts","title":"<code>ptx_queryTransactionReceipts</code>","text":""},{"location":"reference/apis/ptx/#parameters_26","title":"Parameters","text":"<ol> <li><code>query</code>: <code>QueryJSON</code></li> </ol>"},{"location":"reference/apis/ptx/#returns_26","title":"Returns","text":"<ol> <li><code>receipts</code>: <code>TransactionReceipt[]</code></li> </ol>"},{"location":"reference/apis/ptx/#ptx_querytransactions","title":"<code>ptx_queryTransactions</code>","text":""},{"location":"reference/apis/ptx/#parameters_27","title":"Parameters","text":"<ol> <li><code>query</code>: <code>QueryJSON</code></li> </ol>"},{"location":"reference/apis/ptx/#returns_27","title":"Returns","text":"<ol> <li><code>transactions</code>: <code>Transaction[]</code></li> </ol>"},{"location":"reference/apis/ptx/#ptx_querytransactionsfull","title":"<code>ptx_queryTransactionsFull</code>","text":""},{"location":"reference/apis/ptx/#parameters_28","title":"Parameters","text":"<ol> <li><code>query</code>: <code>QueryJSON</code></li> </ol>"},{"location":"reference/apis/ptx/#returns_28","title":"Returns","text":"<ol> <li><code>transactions</code>: <code>TransactionFull[]</code></li> </ol>"},{"location":"reference/apis/ptx/#ptx_resolveverifier","title":"<code>ptx_resolveVerifier</code>","text":""},{"location":"reference/apis/ptx/#parameters_29","title":"Parameters","text":"<ol> <li><code>keyIdentifier</code>: <code>string</code></li> <li><code>algorithm</code>: <code>string</code></li> <li><code>verifierType</code>: <code>string</code></li> </ol>"},{"location":"reference/apis/ptx/#returns_29","title":"Returns","text":"<ol> <li><code>verifier</code>: <code>string</code></li> </ol>"},{"location":"reference/apis/ptx/#ptx_sendtransaction","title":"<code>ptx_sendTransaction</code>","text":""},{"location":"reference/apis/ptx/#parameters_30","title":"Parameters","text":"<ol> <li><code>transaction</code>: <code>TransactionInput</code></li> </ol>"},{"location":"reference/apis/ptx/#returns_30","title":"Returns","text":"<ol> <li><code>transactionId</code>: <code>UUID</code></li> </ol>"},{"location":"reference/apis/ptx/#ptx_sendtransactions","title":"<code>ptx_sendTransactions</code>","text":""},{"location":"reference/apis/ptx/#parameters_31","title":"Parameters","text":"<ol> <li><code>transactions</code>: <code>TransactionInput[]</code></li> </ol>"},{"location":"reference/apis/ptx/#returns_31","title":"Returns","text":"<ol> <li><code>transactionIds</code>: <code>UUID[]</code></li> </ol>"},{"location":"reference/apis/ptx/#ptx_startblockchaineventlistener","title":"<code>ptx_startBlockchainEventListener</code>","text":""},{"location":"reference/apis/ptx/#parameters_32","title":"Parameters","text":"<ol> <li><code>listenerName</code>: <code>string</code></li> </ol>"},{"location":"reference/apis/ptx/#returns_32","title":"Returns","text":"<ol> <li><code>success</code>: <code>bool</code></li> </ol>"},{"location":"reference/apis/ptx/#ptx_startreceiptlistener","title":"<code>ptx_startReceiptListener</code>","text":""},{"location":"reference/apis/ptx/#parameters_33","title":"Parameters","text":"<ol> <li><code>listenerName</code>: <code>string</code></li> </ol>"},{"location":"reference/apis/ptx/#returns_33","title":"Returns","text":"<ol> <li><code>success</code>: <code>bool</code></li> </ol>"},{"location":"reference/apis/ptx/#ptx_stopblockchaineventlistener","title":"<code>ptx_stopBlockchainEventListener</code>","text":""},{"location":"reference/apis/ptx/#parameters_34","title":"Parameters","text":"<ol> <li><code>listenerName</code>: <code>string</code></li> </ol>"},{"location":"reference/apis/ptx/#returns_34","title":"Returns","text":"<ol> <li><code>success</code>: <code>bool</code></li> </ol>"},{"location":"reference/apis/ptx/#ptx_stopreceiptlistener","title":"<code>ptx_stopReceiptListener</code>","text":""},{"location":"reference/apis/ptx/#parameters_35","title":"Parameters","text":"<ol> <li><code>listenerName</code>: <code>string</code></li> </ol>"},{"location":"reference/apis/ptx/#returns_35","title":"Returns","text":"<ol> <li><code>success</code>: <code>bool</code></li> </ol>"},{"location":"reference/apis/ptx/#ptx_storeabi","title":"<code>ptx_storeABI</code>","text":""},{"location":"reference/apis/ptx/#parameters_36","title":"Parameters","text":"<ol> <li><code>abi</code>: <code>Entry[]</code></li> </ol>"},{"location":"reference/apis/ptx/#returns_36","title":"Returns","text":"<ol> <li><code>storedABI</code>: <code>StoredABI</code></li> </ol>"},{"location":"reference/apis/ptx/#ptx_updatetransaction","title":"<code>ptx_updateTransaction</code>","text":""},{"location":"reference/apis/ptx/#parameters_37","title":"Parameters","text":"<ol> <li><code>transactionId</code>: <code>UUID</code></li> <li><code>transaction</code>: <code>TransactionInput</code></li> </ol>"},{"location":"reference/apis/ptx/#returns_37","title":"Returns","text":"<ol> <li><code>transactionId</code>: <code>UUID</code></li> </ol>"},{"location":"reference/apis/reg/","title":"reg_*","text":""},{"location":"reference/apis/reg/#reg_getentryproperties","title":"<code>reg_getEntryProperties</code>","text":""},{"location":"reference/apis/reg/#parameters","title":"Parameters","text":"<ol> <li><code>registryName</code>: <code>string</code></li> <li><code>entryId</code>: <code>HexBytes</code></li> <li><code>activeFilter</code>: <code>\"active\", \"inactive\", \"any\"</code></li> </ol>"},{"location":"reference/apis/reg/#returns","title":"Returns","text":"<ol> <li><code>properties</code>: <code>RegistryProperty[]</code></li> </ol>"},{"location":"reference/apis/reg/#reg_queryentries","title":"<code>reg_queryEntries</code>","text":""},{"location":"reference/apis/reg/#parameters_1","title":"Parameters","text":"<ol> <li><code>registryName</code>: <code>string</code></li> <li><code>query</code>: <code>QueryJSON</code></li> <li><code>activeFilter</code>: <code>\"active\", \"inactive\", \"any\"</code></li> </ol>"},{"location":"reference/apis/reg/#returns_1","title":"Returns","text":"<ol> <li><code>entries</code>: <code>RegistryEntry[]</code></li> </ol>"},{"location":"reference/apis/reg/#reg_queryentrieswithprops","title":"<code>reg_queryEntriesWithProps</code>","text":""},{"location":"reference/apis/reg/#parameters_2","title":"Parameters","text":"<ol> <li><code>registryName</code>: <code>string</code></li> <li><code>query</code>: <code>QueryJSON</code></li> <li><code>activeFilter</code>: <code>\"active\", \"inactive\", \"any\"</code></li> </ol>"},{"location":"reference/apis/reg/#returns_2","title":"Returns","text":"<ol> <li><code>entries</code>: <code>RegistryEntryWithProperties[]</code></li> </ol>"},{"location":"reference/apis/reg/#reg_registries","title":"<code>reg_registries</code>","text":""},{"location":"reference/apis/reg/#returns_3","title":"Returns","text":"<ol> <li><code>registryNames</code>: <code>string[]</code></li> </ol>"},{"location":"reference/apis/transport/","title":"transport_*","text":""},{"location":"reference/apis/transport/#transport_localtransportdetails","title":"<code>transport_localTransportDetails</code>","text":""},{"location":"reference/apis/transport/#parameters","title":"Parameters","text":"<ol> <li><code>transportName</code>: <code>string</code></li> </ol>"},{"location":"reference/apis/transport/#returns","title":"Returns","text":"<ol> <li><code>transportDetailsStr</code>: <code>string</code></li> </ol>"},{"location":"reference/apis/transport/#transport_localtransports","title":"<code>transport_localTransports</code>","text":""},{"location":"reference/apis/transport/#returns_1","title":"Returns","text":"<ol> <li><code>transportNames</code>: <code>string[]</code></li> </ol>"},{"location":"reference/apis/transport/#transport_nodename","title":"<code>transport_nodeName</code>","text":""},{"location":"reference/apis/transport/#returns_2","title":"Returns","text":"<ol> <li><code>nodeName</code>: <code>string</code></li> </ol>"},{"location":"reference/apis/transport/#transport_peerinfo","title":"<code>transport_peerInfo</code>","text":""},{"location":"reference/apis/transport/#parameters_1","title":"Parameters","text":"<ol> <li><code>nodeName</code>: <code>string</code></li> </ol>"},{"location":"reference/apis/transport/#returns_3","title":"Returns","text":"<ol> <li><code>peer</code>: <code>PeerInfo</code></li> </ol>"},{"location":"reference/apis/transport/#transport_peers","title":"<code>transport_peers</code>","text":""},{"location":"reference/apis/transport/#returns_4","title":"Returns","text":"<ol> <li><code>peers</code>: <code>PeerInfo[]</code></li> </ol>"},{"location":"reference/apis/transport/#transport_queryreliablemessageacks","title":"<code>transport_queryReliableMessageAcks</code>","text":""},{"location":"reference/apis/transport/#parameters_2","title":"Parameters","text":"<ol> <li><code>query</code>: <code>QueryJSON</code></li> </ol>"},{"location":"reference/apis/transport/#returns_5","title":"Returns","text":"<ol> <li><code>reliableMessageAcks</code>: <code>ReliableMessageAck[]</code></li> </ol>"},{"location":"reference/apis/transport/#transport_queryreliablemessages","title":"<code>transport_queryReliableMessages</code>","text":""},{"location":"reference/apis/transport/#parameters_3","title":"Parameters","text":"<ol> <li><code>query</code>: <code>QueryJSON</code></li> </ol>"},{"location":"reference/apis/transport/#returns_6","title":"Returns","text":"<ol> <li><code>reliableMessages</code>: <code>ReliableMessage[]</code></li> </ol>"},{"location":"reference/crds/core.paladin.io/","title":"API Reference","text":""},{"location":"reference/crds/core.paladin.io/#packages","title":"Packages","text":"<ul> <li>core.paladin.io/v1alpha1</li> </ul>"},{"location":"reference/crds/core.paladin.io/#corepaladiniov1alpha1","title":"core.paladin.io/v1alpha1","text":"<p>Package v1alpha1 contains API Schema definitions for the core v1alpha1 API group</p>"},{"location":"reference/crds/core.paladin.io/#resource-types","title":"Resource Types","text":"<ul> <li>Besu</li> <li>BesuGenesis</li> <li>BesuGenesisList</li> <li>BesuList</li> <li>Paladin</li> <li>PaladinDomain</li> <li>PaladinDomainList</li> <li>PaladinList</li> <li>PaladinRegistration</li> <li>PaladinRegistrationList</li> <li>PaladinRegistry</li> <li>PaladinRegistryList</li> <li>SmartContractDeployment</li> <li>SmartContractDeploymentList</li> <li>TransactionInvoke</li> <li>TransactionInvokeList</li> </ul>"},{"location":"reference/crds/core.paladin.io/#auth","title":"Auth","text":"<p>Appears in: - NetworkLedgerEndpoint - PaladinSpec</p> Field Description Default Validation <code>type</code> AuthType auth method to use for the connection Enum: [secret inline]  <code>secret</code> AuthSecret Secret is used to provide the name of the secret to use for authentication <code>secretRef</code> AuthSecret SecretRef is used to provide the name of the secret to use for authentication (deprecated, use secret) <code>inline</code> AuthInline Auth details are provided inline (not recommended)"},{"location":"reference/crds/core.paladin.io/#authinline","title":"AuthInline","text":"<p>Appears in: - Auth</p> Field Description Default Validation <code>username</code> string <code>password</code> string"},{"location":"reference/crds/core.paladin.io/#authsecret","title":"AuthSecret","text":"<p>Appears in: - Auth</p> Field Description Default Validation <code>name</code> string The name of the secret to use for authentication"},{"location":"reference/crds/core.paladin.io/#authtype","title":"AuthType","text":"<p>Underlying type: string</p> <p>Appears in: - Auth</p> Field Description <code>secret</code> AuthTypeSecret is used to authenticate with a secretThe secret must contain keys \"username\" and \"password\" <code>inline</code>"},{"location":"reference/crds/core.paladin.io/#baseledgerendpoint","title":"BaseLedgerEndpoint","text":"<p>Appears in: - PaladinSpec</p> Field Description Default Validation <code>type</code> BaseLedgerEndpointType Type specifies the type of the endpoint. Enum: [local endpoint]  <code>local</code> LocalLedgerEndpoint Local specifies the configuration when the type is 'local'. <code>endpoint</code> NetworkLedgerEndpoint Network specifies the configuration when the type is 'endpoint'."},{"location":"reference/crds/core.paladin.io/#baseledgerendpointtype","title":"BaseLedgerEndpointType","text":"<p>Underlying type: string</p> <p>Appears in: - BaseLedgerEndpoint</p> Field Description <code>local</code> <code>endpoint</code>"},{"location":"reference/crds/core.paladin.io/#besu","title":"Besu","text":"<p>Besu is the Schema for the besus API</p> <p>Appears in: - BesuList</p> Field Description Default Validation <code>apiVersion</code> string <code>core.paladin.io/v1alpha1</code> <code>kind</code> string <code>Besu</code> <code>metadata</code> ObjectMeta Refer to Kubernetes API documentation for fields of <code>metadata</code>. <code>spec</code> BesuSpec"},{"location":"reference/crds/core.paladin.io/#besugenesis","title":"BesuGenesis","text":"<p>BesuGenesis is the Schema for the besugeneses API</p> <p>Appears in: - BesuGenesisList</p> Field Description Default Validation <code>apiVersion</code> string <code>core.paladin.io/v1alpha1</code> <code>kind</code> string <code>BesuGenesis</code> <code>metadata</code> ObjectMeta Refer to Kubernetes API documentation for fields of <code>metadata</code>. <code>spec</code> BesuGenesisSpec"},{"location":"reference/crds/core.paladin.io/#besugenesislist","title":"BesuGenesisList","text":"<p>BesuGenesisList contains a list of BesuGenesis</p> Field Description Default Validation <code>apiVersion</code> string <code>core.paladin.io/v1alpha1</code> <code>kind</code> string <code>BesuGenesisList</code> <code>metadata</code> ListMeta Refer to Kubernetes API documentation for fields of <code>metadata</code>. <code>items</code> BesuGenesis array"},{"location":"reference/crds/core.paladin.io/#besugenesisspec","title":"BesuGenesisSpec","text":"<p>BesuGenesisSpec defines the desired state of BesuGenesis All Besu nodes must be bound to a genesis, and will attempt to peer with any other nodes in the same namespace using the same genesis.</p> <p>Appears in: - BesuGenesis</p> Field Description Default Validation <code>base</code> string Base JSON genesis file will be loaded in and then modified as appropriate.Note only modelled fields of the genesis are supported, so check besugenesis.GenesisJSON for support of the field you wish to modify <code>chainID</code> integer The chain ID - must not change after creation without chain reset <code>gasLimit</code> integer The initial gas limit - must not change after creation without chain reset (node config be used to increase gas limit incrementally in new blocks) <code>consensus</code> string Enum: [qbft]  <code>blockPeriod</code> string Block period can be in seconds (s) or milliseconds - cannot be changed once set (used in genesis generation) <code>emptyBlockPeriod</code> string EmptyBlockPeriod period will be rounded to seconds regardless of units used <code>initialValidators</code> string array List of nodes that are included in the genesis block validators.The CRs for these must created for the genesis to form, as it requires the identity secrets of those nodes.Cannot be changed once set (used in genesis generation)."},{"location":"reference/crds/core.paladin.io/#besulist","title":"BesuList","text":"<p>BesuList contains a list of Besu</p> Field Description Default Validation <code>apiVersion</code> string <code>core.paladin.io/v1alpha1</code> <code>kind</code> string <code>BesuList</code> <code>metadata</code> ListMeta Refer to Kubernetes API documentation for fields of <code>metadata</code>. <code>items</code> Besu array"},{"location":"reference/crds/core.paladin.io/#besuspec","title":"BesuSpec","text":"<p>BesuSpec defines the desired state of Besu</p> <p>Appears in: - Besu</p> Field Description Default Validation <code>config</code> string Settings from this config will be loaded as TOML and used as the base of the configuration. <code>genesis</code> string The name of the genesis CR that these nodes will use to obtain their genesis file, and find bootnodes <code>pvcTemplate</code> PersistentVolumeClaimSpec <code>service</code> ServiceSpec Optionally tune the service definition.We merge any configuration you add (such as node ports) for the following services:\"rpc-http\" - 8545 (TCP),\"rpc-ws\" - 8546 (TCP),\"graphql-http\" - 8547 (TCP),\"p2p-tcp\" - 30303 (TCP),\"p2p-udp\" - 30303 (UDP)"},{"location":"reference/crds/core.paladin.io/#contactdependenciesstatus","title":"ContactDependenciesStatus","text":"<p>Appears in: - SmartContractDeploymentStatus - TransactionInvokeStatus</p> Field Description Default Validation <code>contractDepsSummary</code> string <code>resolvedContractAddresses</code> object (keys:string, values:string)"},{"location":"reference/crds/core.paladin.io/#database","title":"Database","text":"<p>Database configuration</p> <p>Appears in: - PaladinSpec</p> Field Description Default Validation <code>mode</code> string preConfigured Enum: [preConfigured sidecarPostgres embeddedSQLite]  <code>migrationMode</code> string preConfigured Enum: [preConfigured auto]  <code>passwordSecret</code> string If set then {{.username}} and {{.password}} variables will be available in your DSN <code>pvcTemplate</code> PersistentVolumeClaimSpec"},{"location":"reference/crds/core.paladin.io/#domainreference","title":"DomainReference","text":"<p>Each domain reference can select one or more domains to include via label selectors Most common to use a simple one-reference-per-domain approach.</p> <p>Appears in: - PaladinSpec</p> Field Description Default Validation <code>labelSelector</code> LabelSelector Label selectors provide a flexible many-to-many mapping between nodes and domains in a namespace.The domain CRs you reference must be labelled to match. For example you could use a label like \"paladin.io/domain-name\" to select by name."},{"location":"reference/crds/core.paladin.io/#evmregistryconfig","title":"EVMRegistryConfig","text":"<p>Appears in: - PaladinRegistrySpec</p> Field Description Default Validation <code>smartContractDeployment</code> string Reference to a SmartContractDeployment CR that is used to deploy the registry <code>contractAddress</code> string If you have separately deployed the registry, supply the registry address directly"},{"location":"reference/crds/core.paladin.io/#labelreference","title":"LabelReference","text":"<p>Appears in: - DomainReference - RegistryReference</p> Field Description Default Validation <code>labelSelector</code> LabelSelector Label selectors provide a flexible many-to-many mapping between nodes and domains in a namespace.The domain CRs you reference must be labelled to match. For example you could use a label like \"paladin.io/domain-name\" to select by name."},{"location":"reference/crds/core.paladin.io/#localledgerendpoint","title":"LocalLedgerEndpoint","text":"<p>LocalLedgerEndpoint defines the configuration for local endpoints.</p> <p>Appears in: - BaseLedgerEndpoint</p> Field Description Default Validation <code>nodeName</code> string NodeName specifies the name of the local node."},{"location":"reference/crds/core.paladin.io/#networkledgerendpoint","title":"NetworkLedgerEndpoint","text":"<p>NetworkLedgerEndpoint defines the configuration for network endpoints.</p> <p>Appears in: - BaseLedgerEndpoint</p> Field Description Default Validation <code>jsonrpc</code> string <code>ws</code> string <code>auth</code> Auth"},{"location":"reference/crds/core.paladin.io/#paladin","title":"Paladin","text":"<p>Paladin is the Schema for the paladin API</p> <p>Appears in: - PaladinList</p> Field Description Default Validation <code>apiVersion</code> string <code>core.paladin.io/v1alpha1</code> <code>kind</code> string <code>Paladin</code> <code>metadata</code> ObjectMeta Refer to Kubernetes API documentation for fields of <code>metadata</code>. <code>spec</code> PaladinSpec"},{"location":"reference/crds/core.paladin.io/#paladindomain","title":"PaladinDomain","text":"<p>PaladinDomain is the Schema for the paladindomains API</p> <p>Appears in: - PaladinDomainList</p> Field Description Default Validation <code>apiVersion</code> string <code>core.paladin.io/v1alpha1</code> <code>kind</code> string <code>PaladinDomain</code> <code>metadata</code> ObjectMeta Refer to Kubernetes API documentation for fields of <code>metadata</code>. <code>spec</code> PaladinDomainSpec"},{"location":"reference/crds/core.paladin.io/#paladindomainlist","title":"PaladinDomainList","text":"<p>PaladinDomainList contains a list of PaladinDomain</p> Field Description Default Validation <code>apiVersion</code> string <code>core.paladin.io/v1alpha1</code> <code>kind</code> string <code>PaladinDomainList</code> <code>metadata</code> ListMeta Refer to Kubernetes API documentation for fields of <code>metadata</code>. <code>items</code> PaladinDomain array"},{"location":"reference/crds/core.paladin.io/#paladindomainspec","title":"PaladinDomainSpec","text":"<p>PaladinDomainSpec defines the desired state of PaladinDomain</p> <p>Appears in: - PaladinDomain</p> Field Description Default Validation <code>smartContractDeployment</code> string Reference to a SmartContractDeployment CR that is used to deploy a new registry contract <code>registryAddress</code> string If you have separately deployed the registry for this domain, supply the registry address directly <code>plugin</code> PluginConfig Details of the plugin to load for the domain <code>allowSigning</code> boolean Whether the code inside of this domain is allowed to perform processing using in-memory key materials.Required when Zero Knowledge Proof (ZKP) generation is being co-located with the Paladin core processfor domains like Zeto. <code>configJSON</code> string JSON configuration specific to the individual domain"},{"location":"reference/crds/core.paladin.io/#paladinlist","title":"PaladinList","text":"<p>PaladinList contains a list of Paladin</p> Field Description Default Validation <code>apiVersion</code> string <code>core.paladin.io/v1alpha1</code> <code>kind</code> string <code>PaladinList</code> <code>metadata</code> ListMeta Refer to Kubernetes API documentation for fields of <code>metadata</code>. <code>items</code> Paladin array"},{"location":"reference/crds/core.paladin.io/#paladinregistration","title":"PaladinRegistration","text":"<p>PaladinRegistration is the Schema for the paladinregistrations API</p> <p>Appears in: - PaladinRegistrationList</p> Field Description Default Validation <code>apiVersion</code> string <code>core.paladin.io/v1alpha1</code> <code>kind</code> string <code>PaladinRegistration</code> <code>metadata</code> ObjectMeta Refer to Kubernetes API documentation for fields of <code>metadata</code>. <code>spec</code> PaladinRegistrationSpec"},{"location":"reference/crds/core.paladin.io/#paladinregistrationlist","title":"PaladinRegistrationList","text":"<p>PaladinRegistrationList contains a list of PaladinRegistration</p> Field Description Default Validation <code>apiVersion</code> string <code>core.paladin.io/v1alpha1</code> <code>kind</code> string <code>PaladinRegistrationList</code> <code>metadata</code> ListMeta Refer to Kubernetes API documentation for fields of <code>metadata</code>. <code>items</code> PaladinRegistration array"},{"location":"reference/crds/core.paladin.io/#paladinregistrationspec","title":"PaladinRegistrationSpec","text":"<p>PaladinRegistrationSpec defines the desired state of PaladinRegistration</p> <p>Appears in: - PaladinRegistration</p> Field Description Default Validation <code>registry</code> string Reference to the Registry CR - must be of type \"evm\" for the registration to process <code>registryAdminNode</code> string The node to use to submit the registration with access to the admin key <code>registryAdminKey</code> string The key to use to sign the transactions <code>node</code> string The node to publish the registration for - owns its registration key <code>nodeAdminKey</code> string The key to use on the node to publish its endpoint information <code>transports</code> string array The transports to publish - we'll wait for them to become available, in the order specified here"},{"location":"reference/crds/core.paladin.io/#paladinregistry","title":"PaladinRegistry","text":"<p>PaladinRegistry is the Schema for the paladinregistries API</p> <p>Appears in: - PaladinRegistryList</p> Field Description Default Validation <code>apiVersion</code> string <code>core.paladin.io/v1alpha1</code> <code>kind</code> string <code>PaladinRegistry</code> <code>metadata</code> ObjectMeta Refer to Kubernetes API documentation for fields of <code>metadata</code>. <code>spec</code> PaladinRegistrySpec"},{"location":"reference/crds/core.paladin.io/#paladinregistrylist","title":"PaladinRegistryList","text":"<p>PaladinRegistryList contains a list of PaladinRegistry</p> Field Description Default Validation <code>apiVersion</code> string <code>core.paladin.io/v1alpha1</code> <code>kind</code> string <code>PaladinRegistryList</code> <code>metadata</code> ListMeta Refer to Kubernetes API documentation for fields of <code>metadata</code>. <code>items</code> PaladinRegistry array"},{"location":"reference/crds/core.paladin.io/#paladinregistryspec","title":"PaladinRegistrySpec","text":"<p>PaladinRegistrySpec defines the desired state of PaladinRegistry</p> <p>Appears in: - PaladinRegistry</p> Field Description Default Validation <code>type</code> RegistryType evm Enum: [evm]  <code>evm</code> EVMRegistryConfig Config specific to EVM based registry <code>transports</code> RegistryTransportsConfig Optionally adjust how the transport configuration works <code>plugin</code> PluginConfig Details of the plugin to load for the domain <code>configJSON</code> string JSON configuration specific to the individual registry"},{"location":"reference/crds/core.paladin.io/#paladinspec","title":"PaladinSpec","text":"<p>PaladinSpec defines the desired state of Paladin</p> <p>Appears in: - Paladin</p> Field Description Default Validation <code>config</code> string Settings from this config will be loaded as YAML and used as the base of the configuration. <code>database</code> Database Database section k8s native functions for setting up the databasewith auto-generation/auto-edit of the DB related config sections <code>secretBackedSigners</code> SecretBackedSigner array Adds signing modules that load their key materials from a k8s secret <code>besuNode</code> string Deprecated: Use 'baseLedgerEndpoint' instead. Example:{ \"baseLedgerEndpoint\": {\"type\": \"local\", \"local\": {\"nodeName\": \"node-name\"}} }Optionally bind to a local Besu node deployed with this operator(vs. configuring a connection to a production blockchain network). <code>authConfig</code> Auth Deprecated: Use 'baseLedgerEndpoint' instead. Example:{ \"baseLedgerEndpoint\": {\"type\": \"network\", \"network\": {\"auth\": {}}} } <code>baseLedgerEndpoint</code> BaseLedgerEndpoint BaseLedgerEndpoint specifies the base endpoint for the ledger <code>service</code> ServiceSpec Optionally tune the service definition.We merge any configuration you add (such as node ports) for the following services:\"rpc-http\" - 8545 (TCP),\"rpc-ws\" - 8546 (TCP) <code>domains</code> DomainReference array A list of domains to merge into the configuration, and rebuild the config of paladin when this list changes <code>registries</code> RegistryReference array A list of registries to merge into the configuration, and rebuild the config of paladin when this list changes <code>signingModules</code> SigningModuleConfig array A list of pluggable signing modules to merge into the configuration, and rebuild the config of paladin when this list changes <code>transports</code> TransportConfig array Transports are configured individually on each node, as they reference security details specific to that node"},{"location":"reference/crds/core.paladin.io/#pluginconfig","title":"PluginConfig","text":"<p>Appears in: - PaladinDomainSpec - PaladinRegistrySpec - SigningModuleConfig - TransportConfig</p> Field Description Default Validation <code>type</code> string The library type to load Enum: [c-shared jar]  <code>library</code> string The location of the library - do not include the \"lib\" prefix or the \".so\" suffix for shared libraries <code>class</code> string For Java only, the name of the class to load from the Jar"},{"location":"reference/crds/core.paladin.io/#registryreference","title":"RegistryReference","text":"<p>Each registry reference can select one or more domains to include via label selectors Most common to use a simple one-reference-per-domain approach.</p> <p>Appears in: - PaladinSpec</p> Field Description Default Validation <code>labelSelector</code> LabelSelector Label selectors provide a flexible many-to-many mapping between nodes and domains in a namespace.The domain CRs you reference must be labelled to match. For example you could use a label like \"paladin.io/domain-name\" to select by name."},{"location":"reference/crds/core.paladin.io/#registrytransportsconfig","title":"RegistryTransportsConfig","text":"<p>Appears in: - PaladinRegistrySpec</p> Field Description Default Validation <code>enabled</code> boolean If true, then this registry will be used for lookup of node transports true <code>requiredPrefix</code> string Prefix if set that will be matched and cut from any supplied lookupnode name before performing a lookup. If it does not match (or matchesthe whole lookup) then this registry will not be used to lookup the node.This allows multiple registries to be used safely for differentprivate node connectivity networks without any possibilityof clashing node names. <code>hierarchySplitter</code> string By default the whole node name must match a root entry in the registry.If a hierarchySplitter is provided (such as \".\") then the supplied nodename will be split into path parts and each entry in the hierarchywill be resolved in order, from the root down to the leaf. <code>propertyRegexp</code> string If a node is found, then each property name will be applied to thisregular expression, and if it matches then the value of the propertywill be considered a set of transport details.The transport name must be extracted as a match group.For example the default is:  propertyRegexp: \"^transport.(.*)$\"This will match a property called \"transport.grpc\" as the transportdetails for the grpc transport. <code>transportMap</code> object (keys:string, values:string) Optionally add entries here to map from the name of a transport as stored inthe registry, to the name in your local configuration.This allows you to use different configurations (MTLS certs etc.)for different private node networks that all use the same logicaltransport name."},{"location":"reference/crds/core.paladin.io/#registrytype","title":"RegistryType","text":"<p>Underlying type: string</p> <p>Appears in: - PaladinRegistrySpec</p> Field Description <code>evm</code>"},{"location":"reference/crds/core.paladin.io/#secretbackedsigner","title":"SecretBackedSigner","text":"<p>Appears in: - PaladinSpec</p> Field Description Default Validation <code>secret</code> string <code>name</code> string Pattern: <code>^[a-z0-9]([-a-z0-9]*[a-z0-9])?$</code> <code>type</code> string The operator supports generating the seed and base config for a simple seeded BIP32 HDWallet signer.If more other options are needed, these can be set directly in the YAML config for this signer. autoHDWallet Enum: [autoHDWallet preConfigured]  <code>keySelector</code> string Wallets will be evaluated against new allocations of key identifiers in the order they aredefined. The key selector regular expression allows wallets to sub-select, with more specificrules first on key matching and more generic rules (like the default of \".*\") last. .* <code>keySelectorMustNotMatch</code> boolean To instruct the key selector to behave in a non-matching mode whereby wallet selection applies when thekey identifier DOES NOT match against the given regular expression for the key selector. false"},{"location":"reference/crds/core.paladin.io/#signingmoduleconfig","title":"SigningModuleConfig","text":"<p>Appears in: - PaladinSpec</p> Field Description Default Validation <code>name</code> string <code>plugin</code> PluginConfig Plugin configuration for loading the signing module <code>configJSON</code> string JSON configuration specific to the individual signing module."},{"location":"reference/crds/core.paladin.io/#smartcontractdeployment","title":"SmartContractDeployment","text":"<p>SmartContractDeployment is the Schema for the smartcontractdeployments API</p> <p>Appears in: - SmartContractDeploymentList</p> Field Description Default Validation <code>apiVersion</code> string <code>core.paladin.io/v1alpha1</code> <code>kind</code> string <code>SmartContractDeployment</code> <code>metadata</code> ObjectMeta Refer to Kubernetes API documentation for fields of <code>metadata</code>. <code>spec</code> SmartContractDeploymentSpec"},{"location":"reference/crds/core.paladin.io/#smartcontractdeploymentlist","title":"SmartContractDeploymentList","text":"<p>SmartContractDeploymentList contains a list of SmartContractDeployment</p> Field Description Default Validation <code>apiVersion</code> string <code>core.paladin.io/v1alpha1</code> <code>kind</code> string <code>SmartContractDeploymentList</code> <code>metadata</code> ListMeta Refer to Kubernetes API documentation for fields of <code>metadata</code>. <code>items</code> SmartContractDeployment array"},{"location":"reference/crds/core.paladin.io/#smartcontractdeploymentspec","title":"SmartContractDeploymentSpec","text":"<p>SmartContractDeploymentSpec defines the desired state of SmartContractDeployment</p> <p>Appears in: - SmartContractDeployment</p> Field Description Default Validation <code>requiredContractDeployments</code> string array This CR will wait for the deployment of all contracts in this list, beforeparsing the bytecode for deployment. This allows unlinked dependenciesto be linked before deployment. <code>node</code> string The node to use to deploy - reference to a PaladinNode CR <code>txType</code> string Type of transaction to submit to Paladin public Enum: [public private]  <code>domain</code> string Domain for private transactions <code>abiJSON</code> string The ABI of the smart contract - provides the constructor parameter definition <code>bytecode</code> string The bytecode of the smart contract <code>from</code> string Reference to the signing key to use to deploy <code>paramsJSON</code> string JSON parameter data (array, object, or empty if no params) <code>linkReferencesJSON</code> string Unlinked contracts have list of the references that need to be resolve, alongside the bytecode <code>linkedContracts</code> object (keys:string, values:string) If the bytecode is unlinked, then this map will be used to resolve the dependencies.The keys in the map are the library name, which can be optionally fully qualifiedwith the syntax FileName.sol:LibName. An entry must be provided for everyunlinked dependency, or the CR will not perform a deployment.The values are evaluated as go templates, with access to the CR.So you can refer to .status.resolvedContractAddresses in the values via go templating.See https://docs.soliditylang.org/en/latest/using-the-compiler.html#library-linking for detail"},{"location":"reference/crds/core.paladin.io/#statusphase","title":"StatusPhase","text":"<p>Underlying type: string</p> <p>Appears in: - Status</p> Field Description <code>Pending</code> <code>Ready</code> <code>Failed</code> <code>Unknown</code>"},{"location":"reference/crds/core.paladin.io/#tlsconfig","title":"TLSConfig","text":"<p>Appears in: - TransportConfig</p> Field Description Default Validation <code>secretName</code> string Secret name is required <code>certName</code> string If specified then a cert-manager.io/v1 Certificate will be created for the internal DNS names of the service.If you define multiple transports that share a secret, then only specify this on one. <code>issuer</code> string Issuer for the certificate if a certificateName is specified (note cluster issuer can be used with a custom certSpecTemplate) selfsigned-issuer <code>additionalDNSNames</code> string array Additional DNS names to add to the definition (for external hostnames) when using automatic cert-manager <code>certSpecTemplate</code> string Go template for the YAML spec of the issuer CR, which will have access to the inserts when building:{{.nodeName}} {{.dnsNames}} {{.secretName}} {{.issuer}}Where .nodeName is that placed in the configThis approach allows us to avoid a build-time dependency on the CertManager CRs, while letting youcustomize things like the algorithm."},{"location":"reference/crds/core.paladin.io/#transactioninvoke","title":"TransactionInvoke","text":"<p>TransactionInvoke is the Schema for the transactioninvokes API</p> <p>Appears in: - TransactionInvokeList</p> Field Description Default Validation <code>apiVersion</code> string <code>core.paladin.io/v1alpha1</code> <code>kind</code> string <code>TransactionInvoke</code> <code>metadata</code> ObjectMeta Refer to Kubernetes API documentation for fields of <code>metadata</code>. <code>spec</code> TransactionInvokeSpec"},{"location":"reference/crds/core.paladin.io/#transactioninvokelist","title":"TransactionInvokeList","text":"<p>TransactionInvokeList contains a list of TransactionInvoke</p> Field Description Default Validation <code>apiVersion</code> string <code>core.paladin.io/v1alpha1</code> <code>kind</code> string <code>TransactionInvokeList</code> <code>metadata</code> ListMeta Refer to Kubernetes API documentation for fields of <code>metadata</code>. <code>items</code> TransactionInvoke array"},{"location":"reference/crds/core.paladin.io/#transactioninvokespec","title":"TransactionInvokeSpec","text":"<p>TransactionInvokeSpec defines the desired state of TransactionInvoke</p> <p>Appears in: - TransactionInvoke</p> Field Description Default Validation <code>requiredContractDeployments</code> string array A list of pre-requisite smart contract deployments that must be resolvedto contract addresses before the transaction can be built+submitted.The set of smart contracts is built one-by-one as the smart contract deploymentscomplete, and once set a dependency does not change if the deployment CRis deleted and re-created. So it is important to delete+recreate allinter-related SmartContractDeployment and TransactionInvoke CRs in a setwhen they are being used as a deployment engine for test infrastructure.This is not intended as substitute to proper smart contract managementin production. Instead it is an excellent tool for rapid re-deploymentof test infrastructure. <code>node</code> string The node to use to deploy - reference to a PaladinNode CR <code>txType</code> string Type of transaction to submit to Paladin public Enum: [public private]  <code>domain</code> string Domain for private transactions <code>function</code> string The name or full signature of the function to invoke <code>abiJSON</code> string The ABI of the smart contract - provides the constructor parameter definition <code>from</code> string Reference to the signing key to use to deploy <code>toTemplate</code> string Go template that specifies the target smart contract for invocation.See paramsJSONTemplate for more detail <code>paramsJSONTemplate</code> string Go template that specifies the data JSON payload for the invocationof the smart contract (array of input values, or map of inputs by name).Once all pre-requisite contract deployments are completed, this templatewill be executed with the JSON serialization of CR as the inputto the CR execution. As such it has access to fields like:.status.resolvedContractAddresses"},{"location":"reference/crds/core.paladin.io/#transactionstatus","title":"TransactionStatus","text":"<p>Underlying type: string</p> <p>Appears in: - SmartContractDeploymentStatus - TransactionInvokeStatus - TransactionSubmission</p> Field Description <code>Submitting</code> <code>Pending</code> <code>Success</code> <code>Failed</code> <code>Rejected</code>"},{"location":"reference/crds/core.paladin.io/#transactionsubmission","title":"TransactionSubmission","text":"<p>Appears in: - PaladinRegistrationStatus - SmartContractDeploymentStatus - TransactionInvokeStatus</p> Field Description Default Validation <code>transactionStatus</code> TransactionStatus <code>idempotencyKey</code> string <code>transactionID</code> string <code>failureMessage</code> string <code>transactionHash</code> string"},{"location":"reference/crds/core.paladin.io/#transportconfig","title":"TransportConfig","text":"<p>Appears in: - PaladinSpec</p> Field Description Default Validation <code>name</code> string <code>plugin</code> PluginConfig Plugin configuration for loading the transport <code>configJSON</code> string JSON configuration specific to the individual transport.The \"tls\" root section of the config will be automatically populated from the k8s secret.The \"externalHostname\" property will be automatically set to the internal k8s hostname, unless it is already set in the configJSON <code>tls</code> TLSConfig TLS configuration to use for this secret <code>ports</code> ServicePort array The port number to listen on this transport"},{"location":"reference/types/abidecodeddata/","title":"ABIDecodedData","text":""},{"location":"reference/types/abidecodeddata/#example","title":"Example","text":"<pre><code>{\n    \"data\": null,\n    \"definition\": null,\n    \"signature\": \"\"\n}\n</code></pre>"},{"location":"reference/types/abidecodeddata/#field-descriptions","title":"Field Descriptions","text":"Field Name Description Type <code>data</code> The decoded JSON data using the matched ABI definition <code>RawJSON</code> <code>summary</code> A string formatted summary - errors only <code>string</code> <code>definition</code> The ABI definition entry matched from the dictionary of ABIs <code>Entry</code> <code>signature</code> The signature of the matched ABI definition <code>string</code>"},{"location":"reference/types/blockchaineventlistener/","title":"BlockchainEventListener","text":""},{"location":"reference/types/blockchaineventlistener/#example","title":"Example","text":"<pre><code>{\n    \"name\": \"\",\n    \"created\": 0,\n    \"started\": null,\n    \"sources\": null,\n    \"options\": {}\n}\n</code></pre>"},{"location":"reference/types/blockchaineventlistener/#field-descriptions","title":"Field Descriptions","text":"Field Name Description Type <code>name</code> Unique name for the blockchain event listener <code>string</code> <code>created</code> Time the listener was created <code>Timestamp</code> <code>started</code> If the listener is started - can be set to false to disable delivery server-side <code>bool</code> <code>sources</code> Sources of events <code>BlockchainEventListenerSource[]</code> <code>options</code> Options for the event listener <code>BlockchainEventListenerOptions</code>"},{"location":"reference/types/blockchaineventlistenercheckpoint/","title":"BlockchainEventListenerCheckpoint","text":""},{"location":"reference/types/blockchaineventlistenercheckpoint/#example","title":"Example","text":"<pre><code>{\n    \"blockNumber\": 0\n}\n</code></pre>"},{"location":"reference/types/blockchaineventlistenercheckpoint/#field-descriptions","title":"Field Descriptions","text":"Field Name Description Type <code>blockNumber</code> The last block fully processed by the event listener <code>int64</code>"},{"location":"reference/types/blockchaineventlisteneroptions/","title":"BlockchainEventListenerOptions","text":""},{"location":"reference/types/blockchaineventlisteneroptions/#example","title":"Example","text":"<pre><code>{}\n</code></pre>"},{"location":"reference/types/blockchaineventlisteneroptions/#field-descriptions","title":"Field Descriptions","text":"Field Name Description Type <code>batchSize</code> The maximum number of events to deliver in each batch <code>int</code> <code>batchTimeout</code> The maximum time to wait for a batch to fill before delivering <code>string</code> <code>fromBlock</code> The block number from which to start listenening for events, or 'latest' to start from the latest block <code>uint8[]</code>"},{"location":"reference/types/blockchaineventlistenersource/","title":"BlockchainEventListenerSource","text":""},{"location":"reference/types/blockchaineventlistenersource/#example","title":"Example","text":"<pre><code>{\n    \"abi\": null\n}\n</code></pre>"},{"location":"reference/types/blockchaineventlistenersource/#field-descriptions","title":"Field Descriptions","text":"Field Name Description Type <code>abi</code> The ABI containing events to listen for <code>Entry[]</code> <code>address</code> The address to listen for events from <code>EthAddress</code>"},{"location":"reference/types/blockchaineventlistenerstatus/","title":"BlockchainEventListenerStatus","text":""},{"location":"reference/types/blockchaineventlistenerstatus/#example","title":"Example","text":"<pre><code>{\n    \"catchup\": false,\n    \"checkpoint\": {\n        \"blockNumber\": 0\n    }\n}\n</code></pre>"},{"location":"reference/types/blockchaineventlistenerstatus/#field-descriptions","title":"Field Descriptions","text":"Field Name Description Type <code>catchup</code> Whether the event listener is catching up to the latest block <code>bool</code> <code>checkpoint</code> The checkpoint for the event listener <code>BlockchainEventListenerCheckpoint</code>"},{"location":"reference/types/eventwithdata/","title":"EventWithData","text":""},{"location":"reference/types/eventwithdata/#example","title":"Example","text":"<pre><code>{\n    \"soliditySignature\": \"\",\n    \"address\": \"0x0000000000000000000000000000000000000000\",\n    \"data\": null\n}\n</code></pre>"},{"location":"reference/types/eventwithdata/#field-descriptions","title":"Field Descriptions","text":"Field Name Description Type <code>blockNumber</code> The block number containing this event <code>int64</code> <code>transactionIndex</code> The index of the transaction within the block <code>int64</code> <code>logIndex</code> The log index of the event <code>int64</code> <code>transactionHash</code> The hash of the transaction that triggered this event <code>Bytes32</code> <code>signature</code> The event signature <code>Bytes32</code> <code>transaction</code> The transaction that triggered this event (optional) <code>IndexedTransaction</code> <code>block</code> The block containing this event <code>IndexedBlock</code> <code>soliditySignature</code> A Solidity style description of the event and parameters, including parameter names and whether they are indexed <code>string</code> <code>address</code> The address of the smart contract that emitted this event <code>EthAddress</code> <code>data</code> JSON formatted data from the event <code>RawJSON</code>"},{"location":"reference/types/indexedblock/","title":"IndexedBlock","text":""},{"location":"reference/types/indexedblock/#example","title":"Example","text":"<pre><code>{\n    \"number\": 0,\n    \"hash\": \"0x0000000000000000000000000000000000000000000000000000000000000000\",\n    \"timestamp\": 0\n}\n</code></pre>"},{"location":"reference/types/indexedblock/#field-descriptions","title":"Field Descriptions","text":"Field Name Description Type <code>number</code> The block number <code>int64</code> <code>hash</code> The unique hash of the block <code>Bytes32</code> <code>timestamp</code> The block timestamp <code>Timestamp</code>"},{"location":"reference/types/indexedevent/","title":"IndexedEvent","text":""},{"location":"reference/types/indexedevent/#example","title":"Example","text":"<pre><code>{\n    \"blockNumber\": 0,\n    \"transactionIndex\": 0,\n    \"logIndex\": 0,\n    \"transactionHash\": \"0x0000000000000000000000000000000000000000000000000000000000000000\",\n    \"signature\": \"0x0000000000000000000000000000000000000000000000000000000000000000\"\n}\n</code></pre>"},{"location":"reference/types/indexedevent/#field-descriptions","title":"Field Descriptions","text":"Field Name Description Type <code>blockNumber</code> The block number containing this event <code>int64</code> <code>transactionIndex</code> The index of the transaction within the block <code>int64</code> <code>logIndex</code> The log index of the event <code>int64</code> <code>transactionHash</code> The hash of the transaction that triggered this event <code>Bytes32</code> <code>signature</code> The event signature <code>Bytes32</code> <code>transaction</code> The transaction that triggered this event (optional) <code>IndexedTransaction</code> <code>block</code> The block containing this event <code>IndexedBlock</code>"},{"location":"reference/types/indexedtransaction/","title":"IndexedTransaction","text":""},{"location":"reference/types/indexedtransaction/#example","title":"Example","text":"<pre><code>{\n    \"hash\": \"0x0000000000000000000000000000000000000000000000000000000000000000\",\n    \"blockNumber\": 0,\n    \"transactionIndex\": 0,\n    \"from\": null,\n    \"nonce\": 0\n}\n</code></pre>"},{"location":"reference/types/indexedtransaction/#field-descriptions","title":"Field Descriptions","text":"Field Name Description Type <code>hash</code> The unique hash of the transaction <code>Bytes32</code> <code>blockNumber</code> The block number containing this transaction <code>int64</code> <code>transactionIndex</code> The index of the transaction within the block <code>int64</code> <code>from</code> The sender's Ethereum address <code>EthAddress</code> <code>to</code> The recipient's Ethereum address (optional) <code>EthAddress</code> <code>nonce</code> The transaction nonce <code>uint64</code> <code>contractAddress</code> The contract address created by this transaction (optional) <code>EthAddress</code> <code>result</code> The result of the transaction (optional) <code>\"failure\", \"success\"</code> <code>block</code> The block containing this event <code>IndexedBlock</code>"},{"location":"reference/types/jsonformatoptions/","title":"JSONFormatOptions","text":"<p>An optional URL query string formatted set of options for how to serialize ABI decoded data into JSON.</p>"},{"location":"reference/types/jsonformatoptions/#defaults","title":"Defaults","text":"<p>By default when no options are specified, the following set of options are used</p> <pre><code>mode=object&amp;number=string&amp;bytes=hex&amp;address=hex\n</code></pre>"},{"location":"reference/types/jsonformatoptions/#mode","title":"Mode","text":"<p>The following <code>mode</code> options can be used for the overall structure of the JSON returned:</p> <ul> <li><code>object</code> (default) - the top-level JSON and all <code>tuples</code> fields (Solidity <code>struct</code>) will be JSON objects<ul> <li>The key will be the <code>name</code> as defined in the ABI</li> <li>If no <code>name</code> is provided for a field in the ABI, then the numeric index <code>0</code>,<code>1</code>,<code>2</code> etc. will be used</li> </ul> </li> <li><code>array</code> - the top-level JSON and all <code>tuple</code> fields will be JSON arrays</li> <li><code>self-describing</code>  - each level is an array that contains the following fields<ul> <li><code>name</code> - the name of the field from the ABI</li> <li><code>type</code> - the type of the field from the ABI, with a falst signature format for <code>tuple</code> children</li> <li><code>value</code> - the value of the field, which will be a self-describing sub-array in the case of <code>tuple</code> types</li> </ul> </li> </ul>"},{"location":"reference/types/jsonformatoptions/#number","title":"Number","text":"<p>The following <code>number</code> options can be used for formatting of numbers - <code>uint256</code>, <code>int64</code> etc types:</p> <ul> <li><code>string</code> (default) - a decimal (base-10) formatted string</li> <li><code>hex</code> or<code>hex-0x</code> - a hexidecimal (base-16) formatted string prefixed with <code>0x</code></li> <li><code>number</code> - a JSON number of arbitrary precision<ul> <li>Be careful if using this option that your JSON parsing library has been configured to support big integers</li> <li>Ethereum token balances regularly use 18 decimals, meaning 100 would be <code>{\"value\": 100000000000000000000}</code></li> <li>Many default implementations of JSON parsing fail in obscure ways when parsing large numbers like this</li> </ul> </li> </ul>"},{"location":"reference/types/jsonformatoptions/#bytes","title":"Bytes","text":"<p>The following <code>bytes</code> options can be used for formatting of byte types - <code>bytes</code>, <code>bytes32</code>.</p> <ul> <li><code>hex</code> or<code>hex-0x</code> (default) - a hexidecimal (base-16) formatted string prefixed with <code>0x</code></li> <li><code>hex-plain</code> - a hexidecimal (base-16) formatted string with no prefix</li> <li><code>base64</code> - a base64 (standard encoding) formatted string</li> </ul>"},{"location":"reference/types/jsonformatoptions/#address","title":"Address","text":"<p>The following <code>bytes</code> options can be used for formatting <code>address</code> type fields.</p> <ul> <li><code>hex</code> or<code>hex-0x</code> (default) - a hexidecimal (base-16) formatted string prefixed with <code>0x</code></li> <li><code>hex-plain</code> - a hexidecimal (base-16) formatted string with no prefix</li> <li><code>checksum</code> - ERC-55 mixed-case checksum address encoding</li> </ul>"},{"location":"reference/types/jsonformatoptions/#pretty","title":"Pretty","text":"<p>Setting <code>pretty</code>, or <code>pretty=true</code> in the query string will cause pretty printing of the returned JSON over multiple lines.</p>"},{"location":"reference/types/jsonformatoptions/#examples","title":"Examples","text":"<p>Given this ABI we illustrate how different options will be formatted</p> <pre><code>[\n    {\n        \"name\": \"date\",              // sample value:\n        \"type\": \"uint64\"             //  1729450200\n    },\n    {\n        \"name\": \"stock\",\n        \"type\": \"tuple[]\",\n        \"components\": [\n            {\n                \"name\": \"item\",       // sample value: \n                \"type\": \"bytes32\"     //  0xbb36636e2b58f2ca2538a966b95a253ed78c6bd1d176255be5a58c7ced3c21ea\n            },\n            {\n                \"name\": \"description\", // sample value:\n                \"type\": \"string\"       //  \"widgetA\"\n            },\n            {\n                \"name\": \"count\",       // sample value:\n                \"type\": \"uint256\"      //  100\n            },\n            {\n                \"name\": \"valueDiff\",   // large negative sample value:\n                \"type\": \"int256\"       //  -123456789012345678901234567890\n            },\n            {\n                \"name\": \"supplier\",    // sample address\n                \"type\": \"address\"      //   0xb8f7764d413b518c49824fb5e6078b41b2549d4e\n            }\n        ]\n    }\n]\n</code></pre>"},{"location":"reference/types/jsonformatoptions/#default-modeobjectnumberstringbyteshexaddresshex","title":"Default (<code>mode=object&amp;number=string&amp;bytes=hex&amp;address=hex</code>)","text":"<pre><code>{\n    \"date\": \"1729450200\",\n    \"stock\": [\n        {\n            \"count\": \"100\",\n            \"description\": \"widgetA\",\n            \"valueDiff\": \"-123456789012345678901234567890\",\n            \"item\": \"0xbb36636e2b58f2ca2538a966b95a253ed78c6bd1d176255be5a58c7ced3c21ea\",\n            \"supplier\": \"0xb8f7764d413b518c49824fb5e6078b41b2549d4e\"\n        }\n    ]\n}\n</code></pre>"},{"location":"reference/types/jsonformatoptions/#modeobjectnumberhexbyteshex-plainaddresschecksum","title":"<code>mode=object&amp;number=hex&amp;bytes=hex-plain&amp;address=checksum</code>","text":"<p>Note the numbers are all in hex, and the address is checksummed:</p> <pre><code>{\n    \"date\": \"0x671550d8\",\n    \"stock\": [\n        {\n            \"count\": \"0x64\",\n            \"description\": \"widgetA\",\n            \"valueDiff\": \"-0x18ee90ff6c373e0ee4e3f0ad2\",\n            \"item\": \"bb36636e2b58f2ca2538a966b95a253ed78c6bd1d176255be5a58c7ced3c21ea\",\n            \"supplier\": \"0xB8F7764d413B518c49824fb5E6078b41B2549d4e\"\n        }\n    ]\n}\n</code></pre>"},{"location":"reference/types/jsonformatoptions/#modeobjectnumberjson-numberbytesbase64addresshex-plain","title":"<code>mode=object&amp;number=json-number&amp;bytes=base64&amp;address=hex-plain</code>","text":"<p>Note the numbers are plain JSON numbers including the one larger than a uint64 can hold, the bytes are Base64, but the address is still hex (with no prefix).</p> <pre><code>{\n    \"date\": 1729450200,\n    \"stock\": [\n        {\n            \"count\": 100,\n            \"description\": \"widgetA\",\n            \"valueDiff\": -123456789012345678901234567890,\n            \"item\": \"uzZjbitY8solOKlmuVolPteMa9HRdiVb5aWMfO08Ieo=\",\n            \"supplier\": \"b8f7764d413b518c49824fb5e6078b41b2549d4e\"\n        }\n    ]\n}\n</code></pre>"},{"location":"reference/types/jsonformatoptions/#modearraynumberstringbyteshex-plainaddresshex","title":"<code>mode=array&amp;number=string&amp;bytes=hex-plain&amp;address=hex</code>","text":"<p>We've switched here to array formatting, including for the nested object.</p> <p>The order is very important now, as you must refer to the fields in ABI order to get the correct values.</p> <pre><code>[\n    \"1729450200\",\n    [\n        [\n            \"bb36636e2b58f2ca2538a966b95a253ed78c6bd1d176255be5a58c7ced3c21ea\",\n            \"widgetA\",\n            \"100\",\n            \"-123456789012345678901234567890\",\n            \"0xb8f7764d413b518c49824fb5e6078b41b2549d4e\"\n        ]\n    ]\n]\n</code></pre>"},{"location":"reference/types/jsonformatoptions/#modeself-describingnumberjson-numberbyteshex","title":"<code>mode=self-describing&amp;number=json-number&amp;bytes=hex</code>","text":"<p>This is the most complex format, where arrays are used that self-describe the data.</p> <p>You still have formatting options on the leaf values, here using JSON numbers.</p> <pre><code>[\n    {\n        \"name\": \"date\",\n        \"type\": \"uint64\",\n        \"value\": 1729450200\n    },\n    {\n        \"name\": \"stock\",\n        \"type\": \"(bytes32,string,uint256,int256,address)[]\",\n        \"value\": [\n            [\n                {\n                    \"name\": \"item\",\n                    \"type\": \"bytes32\",\n                    \"value\": \"0xbb36636e2b58f2ca2538a966b95a253ed78c6bd1d176255be5a58c7ced3c21ea\"\n                },\n                {\n                    \"name\": \"description\",\n                    \"type\": \"string\",\n                    \"value\": \"widgetA\"\n                },\n                {\n                    \"name\": \"count\",\n                    \"type\": \"uint256\",\n                    \"value\": 100\n                },\n                {\n                    \"name\": \"valueDiff\",\n                    \"type\": \"int256\",\n                    \"value\": -123456789012345678901234567890\n                },\n                {\n                    \"name\": \"supplier\",\n                    \"type\": \"address\",\n                    \"value\": \"0xb8f7764d413b518c49824fb5e6078b41b2549d4e\"\n                }\n            ]\n        ]\n    }\n]\n</code></pre>"},{"location":"reference/types/jsonformatoptions/#example","title":"Example","text":"<pre><code>\"\"\n</code></pre>"},{"location":"reference/types/keymappingandverifier/","title":"KeyMappingAndVerifier","text":""},{"location":"reference/types/keymappingandverifier/#example","title":"Example","text":"<pre><code>{\n    \"verifier\": null\n}\n</code></pre>"},{"location":"reference/types/keymappingandverifier/#field-descriptions","title":"Field Descriptions","text":"Field Name Description Type <code>identifier</code> The full identifier used to look up this key <code>string</code> <code>wallet</code> The name of the wallet containing this key <code>string</code> <code>keyHandle</code> The handle within the wallet containing the key <code>string</code> <code>path</code> The full path including the leaf that is the identifier <code>KeyPathSegment[]</code> <code>verifier</code> The verifier associated with this key mapping <code>KeyVerifier</code>"},{"location":"reference/types/keymappingandverifier/#keypathsegment","title":"KeyPathSegment","text":"Field Name Description Type <code>name</code> The name of the path segment <code>string</code> <code>index</code> The index of the path segment <code>int64</code>"},{"location":"reference/types/keymappingandverifier/#keyverifier","title":"KeyVerifier","text":"Field Name Description Type <code>verifier</code> The verifier value <code>string</code> <code>type</code> The type of verifier <code>string</code> <code>algorithm</code> The algorithm used by the verifier <code>string</code>"},{"location":"reference/types/onchainlocation/","title":"OnChainLocation","text":""},{"location":"reference/types/onchainlocation/#example","title":"Example","text":"<pre><code>{\n    \"blockNumber\": 0,\n    \"transactionIndex\": 0,\n    \"logIndex\": 0\n}\n</code></pre>"},{"location":"reference/types/onchainlocation/#field-descriptions","title":"Field Descriptions","text":"Field Name Description Type <code>blockNumber</code> For Ethereum blockchain backed registries, this is the block number where the registry entry/property was set <code>int64</code> <code>transactionIndex</code> The transaction index within the block <code>int64</code> <code>logIndex</code> The log index within the transaction of the event <code>int64</code>"},{"location":"reference/types/peerinfo/","title":"PeerInfo","text":""},{"location":"reference/types/peerinfo/#example","title":"Example","text":"<pre><code>{\n    \"name\": \"\",\n    \"stats\": {\n        \"sentMsgs\": 0,\n        \"receivedMsgs\": 0,\n        \"sentBytes\": 0,\n        \"receivedBytes\": 0,\n        \"lastSend\": null,\n        \"lastReceive\": null,\n        \"reliableHighestSent\": 0,\n        \"reliableAckBase\": 0\n    },\n    \"activated\": 0\n}\n</code></pre>"},{"location":"reference/types/peerinfo/#field-descriptions","title":"Field Descriptions","text":"Field Name Description Type <code>name</code> The name of the peer node <code>string</code> <code>stats</code> Statistics for the outbound and inbound data transfer <code>PeerStats</code> <code>activated</code> The time when the peer was activated by an attempt to send data, or data arriving on a transport from this peer <code>Timestamp</code> <code>outboundTransport</code> The name of the transport selected for outbound connection to the peer. Omitted if no attempt to send data has occurred for this peer <code>string</code> <code>outbound</code> Transport specific information about an established outbound connection to the peer. Omitted if the peer does not have an established outbound connection `` <code>outboundError</code> Contains an error if attempting to send data, and the transport connection failed <code>error</code>"},{"location":"reference/types/peerinfo/#peerstats","title":"PeerStats","text":"Field Name Description Type <code>sentMsgs</code> Count of messages sent since activation of this peer <code>uint64</code> <code>receivedMsgs</code> Count of messages received since activation of this peer <code>uint64</code> <code>sentBytes</code> Count of payload bytes sent since activation of this peer (does not include header data) <code>uint64</code> <code>receivedBytes</code> Count of payload bytes received since activation of this peer (does not include header data) <code>uint64</code> <code>lastSend</code> Timestamp of the last send to this peer <code>Timestamp</code> <code>lastReceive</code> Timestamp of the last receive from this peer <code>Timestamp</code> <code>reliableHighestSent</code> Outbound reliable messages are assigned a sequence. This is the highest sequence sent to the peer since activation <code>uint64</code> <code>reliableAckBase</code> Outbound reliable messages are assigned a sequence. This is the lowest sequence that has not received an acknowledgement from the peer <code>uint64</code>"},{"location":"reference/types/preparedtransaction/","title":"PreparedTransaction","text":""},{"location":"reference/types/preparedtransaction/#example","title":"Example","text":"<pre><code>{\n    \"states\": {}\n}\n</code></pre>"},{"location":"reference/types/preparedtransaction/#field-descriptions","title":"Field Descriptions","text":"Field Name Description Type <code>id</code> The ID of the original transaction that prepared this transaction, and will be confirmed by its submission to the blockchain <code>UUID</code> <code>domain</code> The domain of the original transaction that prepared this transaction submission <code>string</code> <code>to</code> The to address or the original transaction that prepared this transaction submission <code>EthAddress</code> <code>transaction</code> The Paladin transaction definition that has been prepared for submission, with the ABI and function details resolved <code>TransactionInput</code> <code>metadata</code> Domain specific additional information generated during prepare in addition to the states. Used particularly in atomic multi-party transactions to separate data that can be disclosed, away from the full transaction submission payload <code>RawJSON</code> <code>states</code> Details of all states of the original transaction that prepared this transaction submission <code>TransactionStates</code>"},{"location":"reference/types/privacygroup/","title":"PrivacyGroup","text":""},{"location":"reference/types/privacygroup/#example","title":"Example","text":"<pre><code>{\n    \"id\": \"0x\",\n    \"domain\": \"\",\n    \"created\": 0,\n    \"name\": \"\",\n    \"members\": null,\n    \"properties\": null,\n    \"configuration\": null,\n    \"genesisSalt\": \"0x0000000000000000000000000000000000000000000000000000000000000000\",\n    \"genesisSchema\": \"0x0000000000000000000000000000000000000000000000000000000000000000\",\n    \"genesisTransaction\": \"00000000-0000-0000-0000-000000000000\",\n    \"contractAddress\": null\n}\n</code></pre>"},{"location":"reference/types/privacygroup/#field-descriptions","title":"Field Descriptions","text":"Field Name Description Type <code>id</code> The ID of the group, which is the hash-derived ID of the genesis state (assured to be unique within the domain) <code>HexBytes</code> <code>domain</code> The domain of the privacy group <code>string</code> <code>created</code> The creation time <code>Timestamp</code> <code>name</code> Optional name for the privacy group, which is indexed for efficient query <code>string</code> <code>members</code> The member list must be a set of fully qualified identity locators 'some.identity@node.name' <code>string[]</code> <code>properties</code> Application specific properties for the privacy group `` <code>configuration</code> Domain specific configuration options that define the behavior of the privacy group `` <code>genesisSalt</code> The salt used in the genesis state to ensure uniqueness of the resulting state ID <code>Bytes32</code> <code>genesisSchema</code> The ID of the schema for the genesis state <code>Bytes32</code> <code>genesisTransaction</code> The ID of the genesis transaction for the privacy group, correlated with the receipt <code>UUID</code> <code>contractAddress</code> Returns the deployed contract address from the receipt associated with the transaction. Unset until the transaction is confirmed <code>EthAddress</code>"},{"location":"reference/types/privacygroupevmcall/","title":"PrivacyGroupEVMCall","text":""},{"location":"reference/types/privacygroupevmcall/#example","title":"Example","text":"<pre><code>{\n    \"dataFormat\": \"\"\n}\n</code></pre>"},{"location":"reference/types/privacygroupevmcall/#field-descriptions","title":"Field Descriptions","text":"Field Name Description Type <code>domain</code> The domain that manages the privacy group <code>string</code> <code>group</code> The privacy group ID <code>HexBytes</code> <code>from</code> The local signing identity to use to submit the transaction <code>string</code> <code>to</code> The private EVM smart contract address to invoke, or null for an EVM smart contract deployment <code>EthAddress</code> <code>gas</code> Gas limit for the transaction (optional) <code>HexUint64</code> <code>value</code> Native gas token value to transfer in the transaction, if supported by the EVM privacy group domain (optional) <code>HexUint256</code> <code>input</code> An object or array of unencoded inputs, when an function ABI is supplied. Or a hex string containing pre-encoded function selector and ABI encoded inputs <code>RawJSON</code> <code>function</code> The ABI fragment/entry for the function to call. Do not supply the whole ABI array, just one object for the function/constructor. Omit when pre-encoded hex input is provided <code>Entry</code> <code>bytecode</code> For contract deployments to EVM privacy groups, the bytecode must be submitted separately to the constructor parameters (which are supplied as input) <code>HexBytes</code> <code>block</code> The block number or 'latest' when calling a public smart contract (optional) <code>HexUint64OrString</code> <code>dataFormat</code> How call data should be serialized into JSON once decoded using the ABI function definition <code>JSONFormatOptions</code>"},{"location":"reference/types/privacygroupevmtxinput/","title":"PrivacyGroupEVMTXInput","text":""},{"location":"reference/types/privacygroupevmtxinput/#example","title":"Example","text":"<pre><code>{\n    \"publicTxOptions\": {}\n}\n</code></pre>"},{"location":"reference/types/privacygroupevmtxinput/#field-descriptions","title":"Field Descriptions","text":"Field Name Description Type <code>idempotencyKey</code> The idempotencyKey to use in the resulting transaction submission <code>string</code> <code>domain</code> The domain that manages the privacy group <code>string</code> <code>group</code> The privacy group ID <code>HexBytes</code> <code>from</code> The local signing identity to use to submit the transaction <code>string</code> <code>to</code> The private EVM smart contract address to invoke, or null for an EVM smart contract deployment <code>EthAddress</code> <code>gas</code> Gas limit for the transaction (optional) <code>HexUint64</code> <code>value</code> Native gas token value to transfer in the transaction, if supported by the EVM privacy group domain (optional) <code>HexUint256</code> <code>input</code> An object or array of unencoded inputs, when an function ABI is supplied. Or a hex string containing pre-encoded function selector and ABI encoded inputs <code>RawJSON</code> <code>function</code> The ABI fragment/entry for the function to call. Do not supply the whole ABI array, just one object for the function/constructor. Omit when pre-encoded hex input is provided <code>Entry</code> <code>bytecode</code> For contract deployments to EVM privacy groups, the bytecode must be submitted separately to the constructor parameters (which are supplied as input) <code>HexBytes</code> <code>publicTxOptions</code> The public transaction submission options to use in the resulting transaction submission <code>PublicTxOptions</code>"},{"location":"reference/types/privacygroupevmtxinput/#publictxoptions","title":"PublicTxOptions","text":"Field Name Description Type <code>gas</code> The gas limit for the transaction (optional) <code>HexUint64</code> <code>value</code> The value transferred in the transaction (optional) <code>HexUint256</code> <code>maxPriorityFeePerGas</code> The maximum priority fee per gas (optional) <code>HexUint256</code> <code>maxFeePerGas</code> The maximum fee per gas (optional) <code>HexUint256</code> <code>gasPrice</code> The gas price (optional) <code>HexUint256</code>"},{"location":"reference/types/privacygroupinput/","title":"PrivacyGroupInput","text":""},{"location":"reference/types/privacygroupinput/#example","title":"Example","text":"<pre><code>{\n    \"domain\": \"\",\n    \"members\": null,\n    \"name\": \"\"\n}\n</code></pre>"},{"location":"reference/types/privacygroupinput/#field-descriptions","title":"Field Descriptions","text":"Field Name Description Type <code>domain</code> The domain of the privacy group <code>string</code> <code>members</code> The member list must be a set of fully qualified identity locators 'some.identity@node.name' <code>string[]</code> <code>name</code> Optional name for the privacy group, which is indexed for efficient query <code>string</code> <code>properties</code> Application specific properties for the privacy group `` <code>configuration</code> Domain specific configuration options that define the behavior of the privacy group `` <code>transactionOptions</code> Options that will be propagated to the final private transaction that is submitted after the domain has validated the input properties and generated the base private transaction <code>PrivacyGroupTXOptions</code>"},{"location":"reference/types/privacygroupinput/#privacygrouptxoptions","title":"PrivacyGroupTXOptions","text":""},{"location":"reference/types/privacygroupmessage/","title":"PrivacyGroupMessage","text":""},{"location":"reference/types/privacygroupmessage/#example","title":"Example","text":"<pre><code>{\n    \"id\": \"00000000-0000-0000-0000-000000000000\",\n    \"localSequence\": 0,\n    \"sent\": 0,\n    \"received\": 0,\n    \"node\": \"\",\n    \"domain\": \"\",\n    \"group\": \"0x\"\n}\n</code></pre>"},{"location":"reference/types/privacygroupmessage/#field-descriptions","title":"Field Descriptions","text":"Field Name Description Type <code>id</code> Unique UUID for each message - will be the same on all nodes that receive the message <code>UUID</code> <code>localSequence</code> Local sequence number for the message, with the local database of the local node. Will not be the same on all nodes that receive the message <code>uint64</code> <code>sent</code> Time the message was sent. Generated on the sending node <code>Timestamp</code> <code>received</code> Time the message was received. Generated by the receiving node (same as sent on the sending node) <code>Timestamp</code> <code>node</code> The node that originated the message <code>string</code> <code>correlationId</code> Optional UUID to designate a message as being in response to a previous message <code>UUID</code> <code>domain</code> Domain of the privacy group <code>string</code> <code>group</code> Group ID of the privacy group. All members in the group will receive a copy of the message (no guarantee of order) <code>HexBytes</code> <code>topic</code> A topic for the message, which by convention should be a dot or slash separated string instructing the receiver how the message should be processed <code>string</code> <code>data</code> Application defined JSON payload for the message. Can be any JSON type including as an object, array, hex string, other string, or number <code>RawJSON</code>"},{"location":"reference/types/privacygroupmessageinput/","title":"PrivacyGroupMessageInput","text":""},{"location":"reference/types/privacygroupmessageinput/#example","title":"Example","text":"<pre><code>{\n    \"domain\": \"\",\n    \"group\": \"0x\"\n}\n</code></pre>"},{"location":"reference/types/privacygroupmessageinput/#field-descriptions","title":"Field Descriptions","text":"Field Name Description Type <code>correlationId</code> Optional UUID to designate a message as being in response to a previous message <code>UUID</code> <code>domain</code> Domain of the privacy group <code>string</code> <code>group</code> Group ID of the privacy group. All members in the group will receive a copy of the message (no guarantee of order) <code>HexBytes</code> <code>topic</code> A topic for the message, which by convention should be a dot or slash separated string instructing the receiver how the message should be processed <code>string</code> <code>data</code> Application defined JSON payload for the message. Can be any JSON type including as an object, array, hex string, other string, or number <code>RawJSON</code>"},{"location":"reference/types/privacygroupmessagelistener/","title":"PrivacyGroupMessageListener","text":""},{"location":"reference/types/privacygroupmessagelistener/#example","title":"Example","text":"<pre><code>{\n    \"name\": \"\",\n    \"created\": 0,\n    \"started\": null,\n    \"filters\": {},\n    \"options\": {}\n}\n</code></pre>"},{"location":"reference/types/privacygroupmessagelistener/#field-descriptions","title":"Field Descriptions","text":"Field Name Description Type <code>name</code> Unique name for the message listener <code>string</code> <code>created</code> Time the listener was created <code>Timestamp</code> <code>started</code> If the listener is started - can be set to false to disable delivery server-side <code>bool</code> <code>filters</code> Filters to apply to messages <code>PrivacyGroupMessageListenerFilters</code> <code>options</code> Options for the receipt listener <code>PrivacyGroupMessageListenerOptions</code>"},{"location":"reference/types/privacygroupmessagelistener/#privacygroupmessagelistenerfilters","title":"PrivacyGroupMessageListenerFilters","text":"Field Name Description Type <code>sequenceAbove</code> Only deliver message above a certain sequence (rather than from the earliest message) <code>uint64</code> <code>domain</code> Only deliver messages for an individual domain <code>string</code> <code>group</code> Only deliver messages for an individual group ID <code>HexBytes</code> <code>topic</code> Regular expression filter to apply to the topic of each message to determine whether to deliver it to the listener <code>string</code>"},{"location":"reference/types/privacygroupmessagelistener/#privacygroupmessagelisteneroptions","title":"PrivacyGroupMessageListenerOptions","text":"Field Name Description Type <code>excludeLocal</code> When true, messages sent by the local node will not be delivered to the listener <code>bool</code>"},{"location":"reference/types/privacygroupwithabi/","title":"PrivacyGroupWithABI","text":""},{"location":"reference/types/privacygroupwithabi/#example","title":"Example","text":"<pre><code>{\n    \"genesisABI\": null\n}\n</code></pre>"},{"location":"reference/types/privacygroupwithabi/#field-descriptions","title":"Field Descriptions","text":"Field Name Description Type <code>id</code> The ID of the group, which is the hash-derived ID of the genesis state (assured to be unique within the domain) <code>HexBytes</code> <code>domain</code> The domain of the privacy group <code>string</code> <code>created</code> The creation time <code>Timestamp</code> <code>members</code> The member list, validated by the domain to match the genesis state on creation/receipt <code>string[]</code> <code>contractAddress</code> Returns the deployed contract address from the receipt associated with the transaction. Unset until the transaction is confirmed <code>EthAddress</code> <code>genesis</code> The genesis state data (as stored in the state manager) <code>RawJSON</code> <code>genesisTransaction</code> The ID of the genesis transaction for the privacy group, correlated with the receipt <code>UUID</code> <code>genesisSchema</code> The ID of the schema for the genesis state <code>Bytes32</code> <code>genesisSignature</code> String summary of the genesis schema <code>string</code> <code>genesisABI</code> The full ABI of the genesis schema - only returned when querying directly by ID <code>Parameter</code>"},{"location":"reference/types/publictx/","title":"PublicTx","text":""},{"location":"reference/types/publictx/#example","title":"Example","text":"<pre><code>{\n    \"from\": \"0x0000000000000000000000000000000000000000\",\n    \"nonce\": null,\n    \"created\": 0,\n    \"transactionHash\": null\n}\n</code></pre>"},{"location":"reference/types/publictx/#field-descriptions","title":"Field Descriptions","text":"Field Name Description Type <code>localId</code> A locally generated numeric ID for the public transaction. Unique within the node <code>uint64</code> <code>to</code> The target contract address (optional) <code>EthAddress</code> <code>data</code> The pre-encoded calldata (optional) <code>HexBytes</code> <code>from</code> The sender's Ethereum address <code>EthAddress</code> <code>nonce</code> The transaction nonce <code>HexUint64</code> <code>created</code> The creation time <code>Timestamp</code> <code>completedAt</code> The completion time (optional) <code>Timestamp</code> <code>transactionHash</code> The transaction hash (optional) <code>Bytes32</code> <code>success</code> The transaction success status (optional) <code>bool</code> <code>revertData</code> The revert data (optional) <code>HexBytes</code> <code>submissions</code> The submission data (optional) <code>PublicTxSubmissionData[]</code> <code>activity</code> The transaction activity records (optional) <code>TransactionActivityRecord[]</code> <code>gas</code> The gas limit for the transaction (optional) <code>HexUint64</code> <code>value</code> The value transferred in the transaction (optional) <code>HexUint256</code> <code>maxPriorityFeePerGas</code> The maximum priority fee per gas (optional) <code>HexUint256</code> <code>maxFeePerGas</code> The maximum fee per gas (optional) <code>HexUint256</code> <code>gasPrice</code> The gas price (optional) <code>HexUint256</code>"},{"location":"reference/types/publictx/#publictxsubmissiondata","title":"PublicTxSubmissionData","text":"Field Name Description Type <code>time</code> The submission time <code>Timestamp</code> <code>transactionHash</code> The transaction hash <code>Bytes32</code> <code>maxPriorityFeePerGas</code> The maximum priority fee per gas (optional) <code>HexUint256</code> <code>maxFeePerGas</code> The maximum fee per gas (optional) <code>HexUint256</code> <code>gasPrice</code> The gas price (optional) <code>HexUint256</code>"},{"location":"reference/types/publictx/#transactionactivityrecord","title":"TransactionActivityRecord","text":"Field Name Description Type <code>time</code> Time the record occurred <code>Timestamp</code> <code>message</code> Activity message <code>string</code>"},{"location":"reference/types/queryjson/","title":"QueryJSON","text":""},{"location":"reference/types/queryjson/#example","title":"Example","text":"<pre><code>{\n    \"eq\": [\n        {\n            \"field\": \"field1\",\n            \"value\": \"abcde\"\n        },\n        {\n            \"not\": true,\n            \"caseInsensitive\": true,\n            \"field\": \"field12\",\n            \"value\": \"abcde\"\n        }\n    ],\n    \"neq\": [\n        {\n            \"field\": \"field2\",\n            \"value\": \"abcde\"\n        }\n    ],\n    \"like\": [\n        {\n            \"field\": \"field3\",\n            \"value\": \"abcde\"\n        }\n    ],\n    \"lt\": [\n        {\n            \"field\": \"field4\",\n            \"value\": 12345\n        }\n    ],\n    \"lte\": [\n        {\n            \"field\": \"field5\",\n            \"value\": 12345\n        }\n    ],\n    \"gt\": [\n        {\n            \"field\": \"field6\",\n            \"value\": 12345\n        }\n    ],\n    \"gte\": [\n        {\n            \"field\": \"field7\",\n            \"value\": 12345\n        }\n    ],\n    \"in\": [\n        {\n            \"field\": \"field8\",\n            \"values\": [\n                \"abcde\",\n                \"fghij\"\n            ]\n        }\n    ],\n    \"nin\": [\n        {\n            \"field\": \"field9\",\n            \"values\": [\n                \"abcde\",\n                \"fghij\"\n            ]\n        }\n    ],\n    \"null\": [\n        {\n            \"not\": true,\n            \"field\": \"field1\"\n        },\n        {\n            \"field\": \"field2\"\n        }\n    ],\n    \"limit\": 10,\n    \"sort\": [\n        \"field1 DESC\",\n        \"field2\"\n    ]\n}\n</code></pre>"},{"location":"reference/types/queryjson/#field-descriptions","title":"Field Descriptions","text":"Field Name Description Type <code>or</code> List of alternative statements <code>Statements[]</code> <code>equal</code> Equal to <code>OpSingleVal[]</code> <code>eq</code> Equal to (short name) <code>OpSingleVal[]</code> <code>neq</code> Not equal to <code>OpSingleVal[]</code> <code>like</code> Like <code>OpSingleVal[]</code> <code>lessThan</code> Less than <code>OpSingleVal[]</code> <code>lt</code> Less than (short name) <code>OpSingleVal[]</code> <code>lessThanOrEqual</code> Less than or equal to <code>OpSingleVal[]</code> <code>lte</code> Less than or equal to (short name) <code>OpSingleVal[]</code> <code>greaterThan</code> Greater than <code>OpSingleVal[]</code> <code>gt</code> Greater than (short name) <code>OpSingleVal[]</code> <code>greaterThanOrEqual</code> Greater than or equal to <code>OpSingleVal[]</code> <code>gte</code> Greater than or equal to (short name) <code>OpSingleVal[]</code> <code>in</code> In <code>OpMultiVal[]</code> <code>nin</code> Not in <code>OpMultiVal[]</code> <code>null</code> Null <code>Op[]</code> <code>limit</code> Query limit <code>int</code> <code>sort</code> Query sort order <code>string[]</code>"},{"location":"reference/types/queryjson/#statements","title":"Statements","text":"Field Name Description Type <code>or</code> List of alternative statements <code>Statements[]</code> <code>equal</code> Equal to <code>OpSingleVal[]</code> <code>eq</code> Equal to (short name) <code>OpSingleVal[]</code> <code>neq</code> Not equal to <code>OpSingleVal[]</code> <code>like</code> Like <code>OpSingleVal[]</code> <code>lessThan</code> Less than <code>OpSingleVal[]</code> <code>lt</code> Less than (short name) <code>OpSingleVal[]</code> <code>lessThanOrEqual</code> Less than or equal to <code>OpSingleVal[]</code> <code>lte</code> Less than or equal to (short name) <code>OpSingleVal[]</code> <code>greaterThan</code> Greater than <code>OpSingleVal[]</code> <code>gt</code> Greater than (short name) <code>OpSingleVal[]</code> <code>greaterThanOrEqual</code> Greater than or equal to <code>OpSingleVal[]</code> <code>gte</code> Greater than or equal to (short name) <code>OpSingleVal[]</code> <code>in</code> In <code>OpMultiVal[]</code> <code>nin</code> Not in <code>OpMultiVal[]</code> <code>null</code> Null <code>Op[]</code>"},{"location":"reference/types/queryjson/#opsingleval","title":"OpSingleVal","text":"Field Name Description Type <code>not</code> Negate the operation <code>bool</code> <code>caseInsensitive</code> Perform case-insensitive matching <code>bool</code> <code>field</code> Field to apply the operation to <code>string</code> <code>value</code> Value to compare against <code>RawJSON</code>"},{"location":"reference/types/queryjson/#opmultival","title":"OpMultiVal","text":"Field Name Description Type <code>not</code> Negate the operation <code>bool</code> <code>caseInsensitive</code> Perform case-insensitive matching <code>bool</code> <code>field</code> Field to apply the operation to <code>string</code> <code>values</code> Values to compare against <code>RawJSON[]</code>"},{"location":"reference/types/queryjson/#op","title":"Op","text":"Field Name Description Type <code>not</code> Negate the operation <code>bool</code> <code>caseInsensitive</code> Perform case-insensitive matching <code>bool</code> <code>field</code> Field to apply the operation to <code>string</code>"},{"location":"reference/types/registryentry/","title":"RegistryEntry","text":""},{"location":"reference/types/registryentry/#example","title":"Example","text":"<pre><code>{\n    \"registry\": \"\",\n    \"id\": \"0x\",\n    \"name\": \"\",\n    \"blockNumber\": 0,\n    \"transactionIndex\": 0,\n    \"logIndex\": 0\n}\n</code></pre>"},{"location":"reference/types/registryentry/#field-descriptions","title":"Field Descriptions","text":"Field Name Description Type <code>registry</code> The registry that maintains this record <code>string</code> <code>id</code> The ID of the entry, which is unique within the registry across all records in the hierarchy <code>HexBytes</code> <code>name</code> The name of the entry, which is unique across entries with the same parent <code>string</code> <code>parentId</code> Unset for a root record, otherwise a reference to another entity in the same registry <code>HexBytes</code> <code>blockNumber</code> For Ethereum blockchain backed registries, this is the block number where the registry entry/property was set <code>int64</code> <code>transactionIndex</code> The transaction index within the block <code>int64</code> <code>logIndex</code> The log index within the transaction of the event <code>int64</code> <code>active</code> When querying with an activeFilter of 'any' or 'inactive', this boolean shows if the entry/property is active or not <code>bool</code>"},{"location":"reference/types/registryentrywithproperties/","title":"RegistryEntryWithProperties","text":""},{"location":"reference/types/registryentrywithproperties/#example","title":"Example","text":"<pre><code>{\n    \"registry\": \"\",\n    \"id\": \"0x\",\n    \"name\": \"\",\n    \"blockNumber\": 0,\n    \"transactionIndex\": 0,\n    \"logIndex\": 0,\n    \"properties\": null\n}\n</code></pre>"},{"location":"reference/types/registryentrywithproperties/#field-descriptions","title":"Field Descriptions","text":"Field Name Description Type <code>registry</code> The registry that maintains this record <code>string</code> <code>id</code> The ID of the entry, which is unique within the registry across all records in the hierarchy <code>HexBytes</code> <code>name</code> The name of the entry, which is unique across entries with the same parent <code>string</code> <code>parentId</code> Unset for a root record, otherwise a reference to another entity in the same registry <code>HexBytes</code> <code>blockNumber</code> For Ethereum blockchain backed registries, this is the block number where the registry entry/property was set <code>int64</code> <code>transactionIndex</code> The transaction index within the block <code>int64</code> <code>logIndex</code> The log index within the transaction of the event <code>int64</code> <code>active</code> When querying with an activeFilter of 'any' or 'inactive', this boolean shows if the entry/property is active or not <code>bool</code> <code>properties</code> A name + value pair map of all the active properties for this entry. Only active properties are listed, even if the query on the entries used an activeFilter to return inactive entries ``"},{"location":"reference/types/registryproperty/","title":"RegistryProperty","text":""},{"location":"reference/types/registryproperty/#example","title":"Example","text":"<pre><code>{\n    \"registry\": \"\",\n    \"entryId\": \"0x\",\n    \"name\": \"\",\n    \"value\": \"\"\n}\n</code></pre>"},{"location":"reference/types/registryproperty/#field-descriptions","title":"Field Descriptions","text":"Field Name Description Type <code>registry</code> The registry that maintains this record <code>string</code> <code>entryId</code> The ID of the entry this property is associated with <code>HexBytes</code> <code>name</code> The name of the property <code>string</code> <code>value</code> The value of the property <code>string</code> <code>blockNumber</code> For Ethereum blockchain backed registries, this is the block number where the registry entry/property was set <code>int64</code> <code>transactionIndex</code> The transaction index within the block <code>int64</code> <code>logIndex</code> The log index within the transaction of the event <code>int64</code> <code>active</code> When querying with an activeFilter of 'any' or 'inactive', this boolean shows if the entry/property is active or not <code>bool</code>"},{"location":"reference/types/reliablemessage/","title":"ReliableMessage","text":""},{"location":"reference/types/reliablemessage/#example","title":"Example","text":"<pre><code>{\n    \"sequence\": 0,\n    \"id\": \"00000000-0000-0000-0000-000000000000\",\n    \"created\": 0,\n    \"node\": \"\",\n    \"messageType\": \"\",\n    \"metadata\": null\n}\n</code></pre>"},{"location":"reference/types/reliablemessage/#field-descriptions","title":"Field Descriptions","text":"Field Name Description Type <code>sequence</code> Sequence number for the position of this message in the local database <code>uint64</code> <code>id</code> UUID for this message. A separate message, with a separate ID, is allocated for each participant that will receive the message <code>UUID</code> <code>created</code> The time this message was created <code>Timestamp</code> <code>node</code> The target node for this message to be delivered to <code>string</code> <code>messageType</code> The type of the message. Each type has a different locally stored metadata schema, and an on-the-wire full payload format that can be built from the metadata on the source node <code>\"state\", \"receipt\", \"prepared_txn\", \"privacy_group\", \"privacy_group_message\"</code> <code>metadata</code> The locally stored (on the source node) minimal data that allows the on-the-wire message to be built using other stored data <code>RawJSON</code> <code>ack</code> An ack (or nack with error) that has finalized this message delivery so it will not be retried <code>ReliableMessageAckNoMsgID</code>"},{"location":"reference/types/reliablemessage/#reliablemessageacknomsgid","title":"ReliableMessageAckNoMsgID","text":"Field Name Description Type <code>time</code> Time the ack was received (or generated if it is local failure that stops a delivery being attempted) <code>Timestamp</code> <code>error</code> A permanent failure (a 'nack') that will stop any further attempts to deliver this message <code>string</code>"},{"location":"reference/types/reliablemessageack/","title":"ReliableMessageAck","text":""},{"location":"reference/types/reliablemessageack/#example","title":"Example","text":"<pre><code>{\n    \"messageId\": \"00000000-0000-0000-0000-000000000000\"\n}\n</code></pre>"},{"location":"reference/types/reliablemessageack/#field-descriptions","title":"Field Descriptions","text":"Field Name Description Type <code>messageId</code> ID of the reliable message delivery that this ack is associated with <code>UUID</code> <code>time</code> Time the ack was received (or generated if it is local failure that stops a delivery being attempted) <code>Timestamp</code> <code>error</code> A permanent failure (a 'nack') that will stop any further attempts to deliver this message <code>string</code>"},{"location":"reference/types/schema/","title":"Schema","text":""},{"location":"reference/types/schema/#example","title":"Example","text":"<pre><code>{\n    \"id\": \"0x0000000000000000000000000000000000000000000000000000000000000000\",\n    \"created\": 0,\n    \"domain\": \"\",\n    \"type\": \"\",\n    \"signature\": \"\",\n    \"definition\": null,\n    \"labels\": null\n}\n</code></pre>"},{"location":"reference/types/schema/#field-descriptions","title":"Field Descriptions","text":"Field Name Description Type <code>id</code> The hash derived ID of the schema (query only) <code>Bytes32</code> <code>created</code> Server-generated creation timestamp for this schema (query only) <code>Timestamp</code> <code>domain</code> The name of the domain this schema is managed by <code>string</code> <code>type</code> The type of the schema, such as if it is an ABI defined schema <code>\"abi\"</code> <code>signature</code> Human readable signature string for this schema, that is used to generate the hash <code>string</code> <code>definition</code> The definition of the schema, such as the ABI definition <code>RawJSON</code> <code>labels</code> The list of indexed labels that can be used to filter and sort states using to this schema <code>string[]</code>"},{"location":"reference/types/simpletypes/","title":"Simple Types","text":""},{"location":"reference/types/simpletypes/#bytes32","title":"Bytes32","text":"<p>Bytes32 is a 32 byte value, with DB storage serialization</p>"},{"location":"reference/types/simpletypes/#hexbytes","title":"HexBytes","text":"<p>HexBytes is byte slice that is formatted in JSON with an 0x prefix, and stored in the DB as hex</p>"},{"location":"reference/types/simpletypes/#ethaddress","title":"EthAddress","text":"<p>Address0xHex formats with an 0x prefix, but no checksum (lower case)</p>"},{"location":"reference/types/simpletypes/#hexuint256","title":"HexUint256","text":"<p>HexUint256 is an unsigned integer that is serialized in JSON as hex</p>"},{"location":"reference/types/simpletypes/#hexint256","title":"HexInt256","text":"<p>HexInt256 is an unsigned integer that is serialized in JSON as hex</p>"},{"location":"reference/types/simpletypes/#uuid","title":"UUID","text":"<p>Using the UUID package</p>"},{"location":"reference/types/simpletypes/#hexuint64orstring","title":"HexUint64OrString","text":""},{"location":"reference/types/simpletypes/#hexuint64","title":"HexUint64","text":"<p>HexUint64 is an unsigned integer that is serialized in JSON as hex</p>"},{"location":"reference/types/simpletypes/#timestamp","title":"Timestamp","text":""},{"location":"reference/types/simpletypes/#rawjson","title":"RawJSON","text":""},{"location":"reference/types/simpletypes/#privateidentitylocator","title":"PrivateIdentityLocator","text":""},{"location":"reference/types/state/","title":"State","text":""},{"location":"reference/types/state/#example","title":"Example","text":"<pre><code>{\n    \"id\": \"0x\",\n    \"created\": 0,\n    \"domain\": \"\",\n    \"schema\": \"0x0000000000000000000000000000000000000000000000000000000000000000\",\n    \"contractAddress\": null,\n    \"data\": null\n}\n</code></pre>"},{"location":"reference/types/state/#field-descriptions","title":"Field Descriptions","text":"Field Name Description Type <code>id</code> The ID of the state, which is generated from the content per the rules of the domain, and is unique within the contract <code>HexBytes</code> <code>created</code> Server-generated creation timestamp for this state (query only) <code>Timestamp</code> <code>domain</code> The name of the domain this state is managed by <code>string</code> <code>schema</code> The ID of the schema for this state, which defines what fields it has and which are indexed for query <code>Bytes32</code> <code>contractAddress</code> The address of the contract that manages this state within the domain <code>EthAddress</code> <code>data</code> The JSON formatted data for this state <code>RawJSON</code> <code>confirmed</code> The confirmation record, if this an on-chain confirmation has been indexed from the base ledger for this state <code>StateConfirmRecord</code> <code>read</code> Read record, only returned when querying within an in-memory domain context to represent read-lock on a state from a transaction in that domain context <code>StateReadRecord</code> <code>spent</code> The spend record, if this an on-chain spend has been indexed from the base ledger for this state <code>StateSpendRecord</code> <code>locks</code> When querying states within a domain context running ahead of the blockchain assembling transactions for submission, this provides detail on locks applied to the state <code>StateLock[]</code> <code>nullifier</code> Only set if nullifiers are being used in the domain, and a nullifier has been generated that is available for spending this state <code>StateNullifier</code>"},{"location":"reference/types/state/#statereadrecord","title":"StateReadRecord","text":""},{"location":"reference/types/state/#statenullifier","title":"StateNullifier","text":""},{"location":"reference/types/stateconfirm/","title":"StateConfirm","text":""},{"location":"reference/types/stateconfirm/#example","title":"Example","text":"<pre><code>{\n    \"transaction\": \"00000000-0000-0000-0000-000000000000\"\n}\n</code></pre>"},{"location":"reference/types/stateconfirm/#field-descriptions","title":"Field Descriptions","text":"Field Name Description Type <code>transaction</code> The ID of the Paladin transaction where this state was confirmed <code>UUID</code>"},{"location":"reference/types/stateconfirmrecord/","title":"StateConfirmRecord","text":""},{"location":"reference/types/stateconfirmrecord/#example","title":"Example","text":"<pre><code>{\n    \"transaction\": \"00000000-0000-0000-0000-000000000000\"\n}\n</code></pre>"},{"location":"reference/types/stateconfirmrecord/#field-descriptions","title":"Field Descriptions","text":"Field Name Description Type <code>transaction</code> The ID of the Paladin transaction where this state was confirmed <code>UUID</code>"},{"location":"reference/types/statelock/","title":"StateLock","text":""},{"location":"reference/types/statelock/#example","title":"Example","text":"<pre><code>{\n    \"transaction\": \"00000000-0000-0000-0000-000000000000\",\n    \"type\": \"\"\n}\n</code></pre>"},{"location":"reference/types/statelock/#field-descriptions","title":"Field Descriptions","text":"Field Name Description Type <code>transaction</code> The ID of the Paladin transaction being assembled that is responsible for this lock <code>UUID</code> <code>type</code> Whether this lock is for create, read or spend <code>\"create\", \"read\", \"spend\"</code>"},{"location":"reference/types/statespend/","title":"StateSpend","text":""},{"location":"reference/types/statespend/#example","title":"Example","text":"<pre><code>{\n    \"transaction\": \"00000000-0000-0000-0000-000000000000\"\n}\n</code></pre>"},{"location":"reference/types/statespend/#field-descriptions","title":"Field Descriptions","text":"Field Name Description Type <code>transaction</code> The ID of the Paladin transaction where this state was spent <code>UUID</code>"},{"location":"reference/types/statespendrecord/","title":"StateSpendRecord","text":""},{"location":"reference/types/statespendrecord/#example","title":"Example","text":"<pre><code>{\n    \"transaction\": \"00000000-0000-0000-0000-000000000000\"\n}\n</code></pre>"},{"location":"reference/types/statespendrecord/#field-descriptions","title":"Field Descriptions","text":"Field Name Description Type <code>transaction</code> The ID of the Paladin transaction where this state was spent <code>UUID</code>"},{"location":"reference/types/statestatusqualifier/","title":"StateStatusQualifier","text":"<p>The following qualifiers can be used in queries to the state store:</p> <ul> <li><code>available</code> - states that have been confirmed by a blockchain transaction, and not yet been spent in a subsequent transaction</li> <li><code>unconfirmed</code> - states where no transaction has yet been processed from the blockchain to confirm the state</li> <li><code>confirmed</code> - states that have not been marked spent as a result of indexing a blockchain transaction</li> <li><code>spent</code> - states that have not been marked spent as a result of indexing a blockchain transaction</li> <li><code>all</code> - all states stored in this node, regardless of status</li> <li><code>[uuid]</code> - any other value is parsed as the UUID, and if there is an in-memory domain context active for that UUID the query is executed within that domain context</li> </ul>"},{"location":"reference/types/statestatusqualifier/#example","title":"Example","text":"<pre><code>\"\"\n</code></pre>"},{"location":"reference/types/storedabi/","title":"StoredABI","text":""},{"location":"reference/types/storedabi/#example","title":"Example","text":"<pre><code>{\n    \"hash\": \"0x0000000000000000000000000000000000000000000000000000000000000000\",\n    \"abi\": [\n        {\n            \"type\": \"function\",\n            \"name\": \"name\",\n            \"stateMutability\": \"pure\",\n            \"inputs\": null,\n            \"outputs\": null\n        }\n    ]\n}\n</code></pre>"},{"location":"reference/types/storedabi/#field-descriptions","title":"Field Descriptions","text":"Field Name Description Type <code>hash</code> The unique hash of the ABI <code>Bytes32</code> <code>abi</code> The Application Binary Interface (ABI) definition <code>Entry[]</code>"},{"location":"reference/types/transaction/","title":"Transaction","text":""},{"location":"reference/types/transaction/#example","title":"Example","text":"<pre><code>{}\n</code></pre>"},{"location":"reference/types/transaction/#field-descriptions","title":"Field Descriptions","text":"Field Name Description Type <code>id</code> Server-generated UUID for this transaction (query only) <code>UUID</code> <code>created</code> Server-generated creation timestamp for this transaction (query only) <code>Timestamp</code> <code>submitMode</code> Whether the submission of the transaction to the base ledger is to be performed automatically by the node or coordinated externally (query only) <code>\"auto\", \"external\", \"call\"</code> <code>idempotencyKey</code> Externally supplied unique identifier for this transaction. 409 Conflict will be returned on attempt to re-submit <code>string</code> <code>type</code> Type of transaction (public or private) <code>\"private\", \"public\"</code> <code>domain</code> Name of a domain - only required on input for private deploy transactions <code>string</code> <code>function</code> Function signature - inferred from definition if not supplied <code>string</code> <code>abiReference</code> Calculated ABI reference - required with ABI on input if not constructor <code>Bytes32</code> <code>from</code> Locator for a local signing identity to use for submission of this transaction. May be a key identifier, or an eth address prefixed with 'eth_address:'. <code>string</code> <code>to</code> Target contract address, or null for a deploy <code>EthAddress</code> <code>data</code> Pre-encoded array with/without function selector, array, or object input <code>RawJSON</code> <code>gas</code> The gas limit for the transaction (optional) <code>HexUint64</code> <code>value</code> The value transferred in the transaction (optional) <code>HexUint256</code> <code>maxPriorityFeePerGas</code> The maximum priority fee per gas (optional) <code>HexUint256</code> <code>maxFeePerGas</code> The maximum fee per gas (optional) <code>HexUint256</code> <code>gasPrice</code> The gas price (optional) <code>HexUint256</code>"},{"location":"reference/types/transactioncall/","title":"TransactionCall","text":""},{"location":"reference/types/transactioncall/#example","title":"Example","text":"<pre><code>{\n    \"dataFormat\": \"\"\n}\n</code></pre>"},{"location":"reference/types/transactioncall/#field-descriptions","title":"Field Descriptions","text":"Field Name Description Type <code>idempotencyKey</code> Externally supplied unique identifier for this transaction. 409 Conflict will be returned on attempt to re-submit <code>string</code> <code>type</code> Type of transaction (public or private) <code>\"private\", \"public\"</code> <code>domain</code> Name of a domain - only required on input for private deploy transactions <code>string</code> <code>function</code> Function signature - inferred from definition if not supplied <code>string</code> <code>abiReference</code> Calculated ABI reference - required with ABI on input if not constructor <code>Bytes32</code> <code>from</code> Locator for a local signing identity to use for submission of this transaction. May be a key identifier, or an eth address prefixed with 'eth_address:'. <code>string</code> <code>to</code> Target contract address, or null for a deploy <code>EthAddress</code> <code>data</code> Pre-encoded array with/without function selector, array, or object input <code>RawJSON</code> <code>gas</code> The gas limit for the transaction (optional) <code>HexUint64</code> <code>value</code> The value transferred in the transaction (optional) <code>HexUint256</code> <code>maxPriorityFeePerGas</code> The maximum priority fee per gas (optional) <code>HexUint256</code> <code>maxFeePerGas</code> The maximum fee per gas (optional) <code>HexUint256</code> <code>gasPrice</code> The gas price (optional) <code>HexUint256</code> <code>dependsOn</code> Transactions that must be mined on the blockchain successfully before this transaction submits <code>UUID[]</code> <code>abi</code> Application Binary Interface (ABI) definition - required if abiReference not supplied <code>Entry[]</code> <code>bytecode</code> Bytecode prepended to encoded data inputs for deploy transactions <code>HexBytes</code> <code>block</code> The block number or 'latest' when calling a public smart contract (optional) <code>HexUint64OrString</code> <code>dataFormat</code> How call data should be serialized into JSON once decoded using the ABI function definition <code>JSONFormatOptions</code>"},{"location":"reference/types/transactionfull/","title":"TransactionFull","text":""},{"location":"reference/types/transactionfull/#example","title":"Example","text":"<pre><code>{\n    \"receipt\": null,\n    \"public\": null\n}\n</code></pre>"},{"location":"reference/types/transactionfull/#field-descriptions","title":"Field Descriptions","text":"Field Name Description Type <code>id</code> Server-generated UUID for this transaction (query only) <code>UUID</code> <code>created</code> Server-generated creation timestamp for this transaction (query only) <code>Timestamp</code> <code>submitMode</code> Whether the submission of the transaction to the base ledger is to be performed automatically by the node or coordinated externally (query only) <code>\"auto\", \"external\", \"call\"</code> <code>idempotencyKey</code> Externally supplied unique identifier for this transaction. 409 Conflict will be returned on attempt to re-submit <code>string</code> <code>type</code> Type of transaction (public or private) <code>\"private\", \"public\"</code> <code>domain</code> Name of a domain - only required on input for private deploy transactions <code>string</code> <code>function</code> Function signature - inferred from definition if not supplied <code>string</code> <code>abiReference</code> Calculated ABI reference - required with ABI on input if not constructor <code>Bytes32</code> <code>from</code> Locator for a local signing identity to use for submission of this transaction. May be a key identifier, or an eth address prefixed with 'eth_address:'. <code>string</code> <code>to</code> Target contract address, or null for a deploy <code>EthAddress</code> <code>data</code> Pre-encoded array with/without function selector, array, or object input <code>RawJSON</code> <code>gas</code> The gas limit for the transaction (optional) <code>HexUint64</code> <code>value</code> The value transferred in the transaction (optional) <code>HexUint256</code> <code>maxPriorityFeePerGas</code> The maximum priority fee per gas (optional) <code>HexUint256</code> <code>maxFeePerGas</code> The maximum fee per gas (optional) <code>HexUint256</code> <code>gasPrice</code> The gas price (optional) <code>HexUint256</code> <code>dependsOn</code> Transactions registered as dependencies when the transaction was created <code>UUID[]</code> <code>receipt</code> Transaction receipt data - available if the transaction has reached a final state <code>TransactionReceiptData</code> <code>public</code> List of public transactions associated with this transaction <code>PublicTx[]</code> <code>history</code> List of values that have previously been provided for this transaction <code>TransactionHistory[]</code>"},{"location":"reference/types/transactionfull/#transactionreceiptdata","title":"TransactionReceiptData","text":"Field Name Description Type <code>indexed</code> The time when this receipt was indexed by the node, providing a relative order of transaction receipts within this node (might be significantly after the timestamp of the block) <code>Timestamp</code> <code>sequence</code> A local order of this receipt compared to other receipts on the node, used for ordering of receipts when delivering to receipt listeners <code>uint64</code> <code>domain</code> The domain that executed the transaction, for private transactions only <code>string</code> <code>success</code> Transaction success status <code>bool</code> <code>transactionHash</code> Transaction hash <code>Bytes32</code> <code>blockNumber</code> Block number <code>int64</code> <code>transactionIndex</code> Transaction index <code>int64</code> <code>logIndex</code> Log index <code>int64</code> <code>source</code> Event source <code>EthAddress</code> <code>failureMessage</code> Failure message - set if transaction reverted <code>string</code> <code>revertData</code> Encoded revert data - if available <code>HexBytes</code> <code>contractAddress</code> New contract address - to be used in the 'To' field for subsequent invoke transactions <code>EthAddress</code>"},{"location":"reference/types/transactionfull/#transactionhistory","title":"TransactionHistory","text":""},{"location":"reference/types/transactioninput/","title":"TransactionInput","text":""},{"location":"reference/types/transactioninput/#example","title":"Example","text":"<pre><code>{}\n</code></pre>"},{"location":"reference/types/transactioninput/#field-descriptions","title":"Field Descriptions","text":"Field Name Description Type <code>idempotencyKey</code> Externally supplied unique identifier for this transaction. 409 Conflict will be returned on attempt to re-submit <code>string</code> <code>type</code> Type of transaction (public or private) <code>\"private\", \"public\"</code> <code>domain</code> Name of a domain - only required on input for private deploy transactions <code>string</code> <code>function</code> Function signature - inferred from definition if not supplied <code>string</code> <code>abiReference</code> Calculated ABI reference - required with ABI on input if not constructor <code>Bytes32</code> <code>from</code> Locator for a local signing identity to use for submission of this transaction. May be a key identifier, or an eth address prefixed with 'eth_address:'. <code>string</code> <code>to</code> Target contract address, or null for a deploy <code>EthAddress</code> <code>data</code> Pre-encoded array with/without function selector, array, or object input <code>RawJSON</code> <code>gas</code> The gas limit for the transaction (optional) <code>HexUint64</code> <code>value</code> The value transferred in the transaction (optional) <code>HexUint256</code> <code>maxPriorityFeePerGas</code> The maximum priority fee per gas (optional) <code>HexUint256</code> <code>maxFeePerGas</code> The maximum fee per gas (optional) <code>HexUint256</code> <code>gasPrice</code> The gas price (optional) <code>HexUint256</code> <code>dependsOn</code> Transactions that must be mined on the blockchain successfully before this transaction submits <code>UUID[]</code> <code>abi</code> Application Binary Interface (ABI) definition - required if abiReference not supplied <code>Entry[]</code> <code>bytecode</code> Bytecode prepended to encoded data inputs for deploy transactions <code>HexBytes</code>"},{"location":"reference/types/transactioninput/#entry","title":"Entry","text":""},{"location":"reference/types/transactionreceipt/","title":"TransactionReceipt","text":""},{"location":"reference/types/transactionreceipt/#example","title":"Example","text":"<pre><code>{\n    \"id\": \"00000000-0000-0000-0000-000000000000\",\n    \"sequence\": 0\n}\n</code></pre>"},{"location":"reference/types/transactionreceipt/#field-descriptions","title":"Field Descriptions","text":"Field Name Description Type <code>id</code> Transaction ID <code>UUID</code> <code>indexed</code> The time when this receipt was indexed by the node, providing a relative order of transaction receipts within this node (might be significantly after the timestamp of the block) <code>Timestamp</code> <code>sequence</code> A local order of this receipt compared to other receipts on the node, used for ordering of receipts when delivering to receipt listeners <code>uint64</code> <code>domain</code> The domain that executed the transaction, for private transactions only <code>string</code> <code>success</code> Transaction success status <code>bool</code> <code>transactionHash</code> Transaction hash <code>Bytes32</code> <code>blockNumber</code> Block number <code>int64</code> <code>transactionIndex</code> Transaction index <code>int64</code> <code>logIndex</code> Log index <code>int64</code> <code>source</code> Event source <code>EthAddress</code> <code>failureMessage</code> Failure message - set if transaction reverted <code>string</code> <code>revertData</code> Encoded revert data - if available <code>HexBytes</code> <code>contractAddress</code> New contract address - to be used in the 'To' field for subsequent invoke transactions <code>EthAddress</code>"},{"location":"reference/types/transactionreceiptfilters/","title":"TransactionReceiptFilters","text":""},{"location":"reference/types/transactionreceiptfilters/#example","title":"Example","text":"<pre><code>{}\n</code></pre>"},{"location":"reference/types/transactionreceiptfilters/#field-descriptions","title":"Field Descriptions","text":"Field Name Description Type <code>sequenceAbove</code> Only deliver receipts above a certain sequence (rather than from the beginning of indexing of the chain) <code>uint64</code> <code>type</code> Only deliver receipts for one transaction type (public/private) <code>Enum[github.com/kaleido-io/paladin/sdk/go/pkg/pldapi.TransactionType]</code> <code>domain</code> Only deliver receipts for an individual domain (only valid with type=private) <code>string</code>"},{"location":"reference/types/transactionreceiptfull/","title":"TransactionReceiptFull","text":""},{"location":"reference/types/transactionreceiptfull/#example","title":"Example","text":"<pre><code>{}\n</code></pre>"},{"location":"reference/types/transactionreceiptfull/#field-descriptions","title":"Field Descriptions","text":"Field Name Description Type <code>id</code> Transaction ID <code>UUID</code> <code>indexed</code> The time when this receipt was indexed by the node, providing a relative order of transaction receipts within this node (might be significantly after the timestamp of the block) <code>Timestamp</code> <code>sequence</code> A local order of this receipt compared to other receipts on the node, used for ordering of receipts when delivering to receipt listeners <code>uint64</code> <code>domain</code> The domain that executed the transaction, for private transactions only <code>string</code> <code>success</code> Transaction success status <code>bool</code> <code>transactionHash</code> Transaction hash <code>Bytes32</code> <code>blockNumber</code> Block number <code>int64</code> <code>transactionIndex</code> Transaction index <code>int64</code> <code>logIndex</code> Log index <code>int64</code> <code>source</code> Event source <code>EthAddress</code> <code>failureMessage</code> Failure message - set if transaction reverted <code>string</code> <code>revertData</code> Encoded revert data - if available <code>HexBytes</code> <code>contractAddress</code> New contract address - to be used in the 'To' field for subsequent invoke transactions <code>EthAddress</code> <code>states</code> The state receipt for the transaction (private transactions only) <code>TransactionStates</code> <code>domainReceipt</code> The domain receipt for the transaction (private transaction only) <code>RawJSON</code> <code>domainReceiptError</code> Contains the error if it was not possible to obtain the domain receipt for a private transaction <code>string</code>"},{"location":"reference/types/transactionreceiptlistener/","title":"TransactionReceiptListener","text":""},{"location":"reference/types/transactionreceiptlistener/#create-receipt-listener","title":"Create receipt listener","text":"<pre><code>{\n    \"jsonrpc\": \"2.0\",\n    \"id\": 1,\n    \"method\": \"ptx_createReceiptListener\",\n    \"params\": [{\n        \"name\":\"listener1\",\n        \"filters\": {\n            \"sequenceAbove\": null,\n            \"type\": \"private\",\n            \"domain\": \"pente\"\n        },\n        \"options\": {\n            \"incompleteStateReceiptBehavior\": \"block_contract\",\n            \"domainReceipts\": true\n        }\n    }]\n}\n</code></pre> <p>Note the ability to filter on particular receipt types, and most importantly the ability to block delivery on a given contract address while a \"gap\" exists in the available states.</p>"},{"location":"reference/types/transactionreceiptlistener/#subscribe-websockets-only","title":"Subscribe (WebSockets only)","text":"<pre><code>{\n    \"jsonrpc\": \"2.0\",\n    \"id\": 1,\n    \"method\": \"ptx_subscribe\",\n    \"params\": [\"receipts\", \"listener1\"]\n}\n</code></pre>"},{"location":"reference/types/transactionreceiptlistener/#ack","title":"Ack","text":"<p>Confirms receipt of the last batch for this subscription ID (which changes on each ptx_subscribe), so the next batch is delivered.</p> <pre><code>{\n    \"jsonrpc\": \"2.0\",\n    \"id\": 1,\n    \"method\": \"ptx_ack\",\n    \"params\": [\"5b3e0816-32e2-4aa8-80e6-6d2e41e046cb\"]\n}\n</code></pre> <p>No reply is sent to <code>ptx_ack</code> - only the next batch</p>"},{"location":"reference/types/transactionreceiptlistener/#nack","title":"Nack","text":"<p>Drives redelivery for the last batch.</p> <pre><code>{\n    \"jsonrpc\": \"2.0\",\n    \"id\": 1,\n    \"method\": \"ptx_nack\",\n    \"params\": [\"5b3e0816-32e2-4aa8-80e6-6d2e41e046cb\"]\n}\n</code></pre> <p>No reply is sent to <code>ptx_ack</code> - only the redelivery batch</p>"},{"location":"reference/types/transactionreceiptlistener/#unsubscribe","title":"Unsubscribe","text":"<pre><code>{\n    \"jsonrpc\": \"2.0\",\n    \"id\": 1,\n    \"method\": \"ptx_unsubscribe\",\n    \"params\": [\"5b3e0816-32e2-4aa8-80e6-6d2e41e046cb\"]\n}\n</code></pre>"},{"location":"reference/types/transactionreceiptlistener/#delete-receipt-listener","title":"Delete receipt listener","text":"<pre><code>{\n    \"jsonrpc\": \"2.0\",\n    \"id\": 1,\n    \"method\": \"ptx_deleteReceiptListener\",\n    \"params\": [\"listener1\"]\n}\n</code></pre>"},{"location":"reference/types/transactionreceiptlistener/#example","title":"Example","text":"<pre><code>{\n    \"name\": \"\",\n    \"created\": 0,\n    \"started\": null,\n    \"filters\": {},\n    \"options\": {\n        \"domainReceipts\": false\n    }\n}\n</code></pre>"},{"location":"reference/types/transactionreceiptlistener/#field-descriptions","title":"Field Descriptions","text":"Field Name Description Type <code>name</code> Unique name for the receipt listener <code>string</code> <code>created</code> Time the listener was created <code>Timestamp</code> <code>started</code> If the listener is started - can be set to false to disable delivery server-side <code>bool</code> <code>filters</code> Filters to apply to receipts <code>TransactionReceiptFilters</code> <code>options</code> Options for the receipt listener <code>TransactionReceiptListenerOptions</code>"},{"location":"reference/types/transactionreceiptlisteneroptions/","title":"TransactionReceiptListenerOptions","text":""},{"location":"reference/types/transactionreceiptlisteneroptions/#example","title":"Example","text":"<pre><code>{\n    \"domainReceipts\": false\n}\n</code></pre>"},{"location":"reference/types/transactionreceiptlisteneroptions/#field-descriptions","title":"Field Descriptions","text":"Field Name Description Type <code>domainReceipts</code> When true, a full domain receipt will be generated for each event with complete state data <code>bool</code> <code>incompleteStateReceiptBehavior</code> When set to 'block_contract', if a transaction with incomplete state data is detected then delivery of all receipts on that individual smart contract address will pause until the missing state arrives. Receipts for other contract addresses continue to be delivered <code>\"block_contract\", \"process\"</code>"},{"location":"reference/types/transactionstates/","title":"TransactionStates","text":""},{"location":"reference/types/transactionstates/#example","title":"Example","text":"<pre><code>{}\n</code></pre>"},{"location":"reference/types/transactionstates/#field-descriptions","title":"Field Descriptions","text":"Field Name Description Type <code>none</code> No state reference records have been indexed for this transaction. Either the transaction has not been indexed, or it did not reference any states <code>bool</code> <code>spent</code> Private state data for input states that were spent in this transaction <code>StateBase[]</code> <code>read</code> Private state data for states that were unspent and used during execution of this transaction, but were not spent by it <code>StateBase[]</code> <code>confirmed</code> Private state data for new states that were confirmed as new unspent states during this transaction <code>StateBase[]</code> <code>info</code> Private state data for states that were recorded as part of this transaction, and existed only as reference data during its execution. They were not validated as unspent during execution, or recorded as new unspent states <code>StateBase[]</code> <code>unavailable</code> If present, this contains information about states recorded as used by this transactions when indexing, but for which the private data is unavailable on this node <code>UnavailableStates</code>"},{"location":"reference/types/transactionstates/#statebase","title":"StateBase","text":"Field Name Description Type <code>id</code> The ID of the state, which is generated from the content per the rules of the domain, and is unique within the contract <code>HexBytes</code> <code>created</code> Server-generated creation timestamp for this state (query only) <code>Timestamp</code> <code>domain</code> The name of the domain this state is managed by <code>string</code> <code>schema</code> The ID of the schema for this state, which defines what fields it has and which are indexed for query <code>Bytes32</code> <code>contractAddress</code> The address of the contract that manages this state within the domain <code>EthAddress</code> <code>data</code> The JSON formatted data for this state <code>RawJSON</code>"},{"location":"reference/types/transactionstates/#unavailablestates","title":"UnavailableStates","text":"Field Name Description Type <code>confirmed</code> The IDs of confirmed states created by this transaction, for which the private data is unavailable <code>HexBytes[]</code> <code>read</code> The IDs of read states used by this transaction, for which the private data is unavailable <code>HexBytes[]</code> <code>spent</code> The IDs of spent states consumed by this transaction, for which the private data is unavailable <code>HexBytes[]</code> <code>info</code> The IDs of info states referenced in this transaction, for which the private data is unavailable <code>HexBytes[]</code>"},{"location":"tutorials/","title":"Introduction","text":""},{"location":"tutorials/#prerequisites","title":"Prerequisites","text":"<ul> <li>Git </li> <li>Node.js 20.x or newer   Follow the official Node.js documentation for your platform to install the appropriate version.</li> </ul> <p>To access the tutorial code, clone the most recent release tag of the Paladin repository:</p> <pre><code>REPO=https://github.com/LF-Decentralized-Trust-labs/paladin.git &amp;&amp; \\\ngit clone $REPO --single-branch --branch \\\n$(git ls-remote --tags $REPO | cut -d/ -f3 | sort -V | tail -n1)\n</code></pre>"},{"location":"tutorials/#next-steps","title":"Next Steps","text":"<p>The tutorials on this page provide an introduction to building on the Paladin platform. If you haven\u2019t already, visit the Getting Started guide to familiarize yourself with running Paladin before proceeding with any of the tutorials below.</p> <ul> <li> <p>Hello World </p> <p>Begin with a simple \u201cHello World\u201d example to get familiar with some of the basics.</p> </li> <li> <p>Public Smart Contract </p> <p>Explore fundamental SDK functionality for deploying and interacting with a publicly visible contract.</p> </li> <li> <p>Private  Smart Contract </p> <p>Discover how to use Privacy Groups and keep contract data confidential among authorized members.</p> </li> <li> <p>Notarized Tokens </p> <p>Learn how to issue, mint, and transfer tokens using Paladin\u2019s Notarized Tokens domain.</p> </li> <li> <p>Wholesale CBDC </p> <p>Implement a wholesale CBDC with zero-knowledge proof features for enhanced privacy and regulatory compliance.</p> </li> <li> <p>Private Stablecoin with KYC </p> <p>Deploy a private stablecoin with KYC compliance combining deposit/withdraw functionality with zero-knowledge proof privacy and nullifier protection.</p> </li> <li> <p>Bond Issuance </p> <p>Understand how Notarized Tokens and Privacy Groups work together to model and manage a bond issuance process.</p> </li> </ul>"},{"location":"tutorials/atomic-swap/","title":"Atomic Swap","text":"<p>The code for this tutorial can be found in example/swap.</p> <p>This example demonstrates an atomic swap scenario on Paladin, showing how to perform secure exchanges between different types of privacy-preserving tokens. It illustrates the power of combining multiple Paladin domains (Zeto, Noto, and Pente) to create complex privacy-preserving operations with guaranteed atomicity on a single ledger.</p>"},{"location":"tutorials/atomic-swap/#running-the-example","title":"Running the example","text":"<p>Follow the Getting Started instructions to set up a Paladin environment, and then follow the example README to run the code.</p>"},{"location":"tutorials/atomic-swap/#overview","title":"Overview","text":"<p>The atomic swap demonstrates an exchange between:</p> <ul> <li>Cash tokens - Implemented using Zeto with zero-knowledge privacy</li> <li>Asset tokens - Implemented using Noto with private hooks via Pente</li> </ul>"},{"location":"tutorials/atomic-swap/#key-features","title":"Key Features","text":"<ul> <li>Atomic execution - Either both transfers complete successfully, or neither does</li> <li>Cross-domain compatibility - Seamlessly swap between Zeto and Noto tokens</li> <li>Privacy preservation - All token operations maintain privacy appropriate to their domains</li> <li>Smart contract hooks - Asset tokens use private EVM logic for enhanced control</li> </ul>"},{"location":"tutorials/atomic-swap/#participants","title":"Participants","text":"<ul> <li>Cash Issuer (Node 1) - Issues Zeto cash tokens and deploys infrastructure</li> <li>Asset Issuer (Node 1) - Issues Noto asset tokens with private tracking</li> <li>Investor 1 (Node 2) - Holds assets and wants to trade them for cash</li> <li>Investor 2 (Node 3) - Holds cash and wants to acquire assets</li> </ul>"},{"location":"tutorials/atomic-swap/#explanation","title":"Explanation","text":"<p>Below is a walkthrough of each step in the example, with an explanation of what it does.</p>"},{"location":"tutorials/atomic-swap/#scenario-setup","title":"Scenario Setup","text":""},{"location":"tutorials/atomic-swap/#deploy-atom-factory","title":"Deploy atom factory","text":"<pre><code>const atomFactory = await newAtomFactory(paladin1, cashIssuer);\n</code></pre> <p>The Atom Factory is a utility contract on the base ledger. It creates atomic transaction containers that can execute multiple operations as a single unit. While it is not a part of any Paladin domain, it is useful for coordinating operations from multiple domains.</p>"},{"location":"tutorials/atomic-swap/#deploy-zeto-cash-token","title":"Deploy Zeto cash token","text":"<pre><code>const zetoFactory = new ZetoFactory(paladin1, \"zeto\");\nconst zetoCash = await zetoFactory\n  .newZeto(cashIssuer, {\n    tokenName: \"Zeto_Anon\",\n  })\n  .waitForDeploy();\n</code></pre> <p>This creates a Zeto cash token using the Zeto_Anon contract.</p>"},{"location":"tutorials/atomic-swap/#create-asset-issuer-privacy-group","title":"Create asset issuer privacy group","text":"<pre><code>const penteFactory = new PenteFactory(paladin1, \"pente\");\nconst issuerGroup = await penteFactory\n  .newPrivacyGroup({\n    members: [assetIssuer],\n    evmVersion: \"shanghai\",\n    externalCallsEnabled: true,\n  })\n  .waitForDeploy();\n</code></pre> <p>This creates a single-member privacy group for the asset issuer. Even with one member, this provides:</p> <ul> <li>Private tracking of Noto assets in an EVM-native representation</li> <li>External call capabilities to interact with base ledger contracts</li> <li>Custom business logic via private smart contracts</li> </ul>"},{"location":"tutorials/atomic-swap/#deploy-private-asset-tracker","title":"Deploy private asset tracker","text":"<pre><code>const tracker = await newERC20Tracker(issuerGroup, assetIssuer, {\n  name: \"ASSET\",\n  symbol: \"ASSET\",\n});\n</code></pre> <p>The private asset tracker is an ERC-20 contract deployed within the privacy group. This hook logic will be invoked for every operation on the Noto token, which allows the private ERC-20 to perfectly mirror the current state and ownership of Noto balances, as well as providing a way for the asset issuer to set custom rules and policies on Noto operations.</p>"},{"location":"tutorials/atomic-swap/#deploy-noto-asset-token","title":"Deploy Noto asset token","text":"<pre><code>const notoFactory = new NotoFactory(paladin1, \"noto\");\nconst notoAsset = await notoFactory\n  .newNoto(assetIssuer, {\n    notary: assetIssuer,\n    notaryMode: \"hooks\",\n    options: {\n      hooks: {\n        privateGroup: issuerGroup,\n        publicAddress: issuerGroup.address,\n        privateAddress: tracker.address,\n      },\n    },\n  })\n  .waitForDeploy();\n</code></pre> <p>This creates a Noto token that uses the private tracker as hooks.</p>"},{"location":"tutorials/atomic-swap/#token-issuance","title":"Token Issuance","text":""},{"location":"tutorials/atomic-swap/#issue-asset-to-investor1","title":"Issue asset to investor1","text":"<pre><code>let receipt = await notoAsset\n  .mint(assetIssuer, {\n    to: investor1,\n    amount: 1000,\n    data: \"0x\",\n  })\n  .waitForReceipt();\n</code></pre> <p>The asset issuer mints asset tokens to investor1. This triggers both: - Noto token creation on the base ledger - Private tracker updates within the privacy group</p>"},{"location":"tutorials/atomic-swap/#issue-cash-to-investor2","title":"Issue cash to investor2","text":"<pre><code>receipt = await zetoCash\n  .mint(cashIssuer, {\n    mints: [\n      {\n        to: investor2,\n        amount: 10000,\n        data: \"0x\",\n      },\n    ],\n  })\n  .waitForReceipt();\n</code></pre> <p>The cash issuer mints Zeto cash tokens to investor2.</p>"},{"location":"tutorials/atomic-swap/#swap-preparation","title":"Swap Preparation","text":""},{"location":"tutorials/atomic-swap/#lock-asset-for-swap","title":"Lock asset for swap","text":"<pre><code>receipt = await notoAsset\n  .using(paladin2)\n  .lock(investor1, {\n    amount: 100,\n    data: \"0x\",\n  })\n  .waitForReceipt();\n</code></pre> <p>Investor1 locks 100 asset tokens, making them unavailable for other operations until the lock is released or the swap completes.</p>"},{"location":"tutorials/atomic-swap/#prepare-asset-unlock","title":"Prepare asset unlock","text":"<pre><code>receipt = await notoAsset\n  .using(paladin2)\n  .prepareUnlock(investor1, {\n    lockId,\n    from: investor1,\n    recipients: [{ to: investor2, amount: 100 }],\n    data: \"0x\",\n  })\n  .waitForReceipt();\n</code></pre> <p>This prepares the asset transfer without executing it, creating a transaction that can be delegated to the atomic swap contract.</p>"},{"location":"tutorials/atomic-swap/#lock-and-prepare-cash-transfer","title":"Lock and prepare cash transfer","text":"<pre><code>receipt = await zetoCash\n  .using(paladin3)\n  .lock(investor2, {\n    amount: 10,\n    delegate: investor2Address,\n  })\n  .waitForReceipt();\n\nconst txID = await zetoCash.using(paladin3).prepareTransferLocked(investor2, {\n  lockedInputs: [lockedStateId],\n  delegate: investor2.lookup,\n  transfers: [\n    {\n      to: investor1,\n      amount: 10,\n      data: \"0x\",\n    },\n  ],\n}).id;\n</code></pre> <p>Similarly, investor2 locks and prepares the cash transfer. This creates the Zeto side of the swap, ready for atomic execution.</p>"},{"location":"tutorials/atomic-swap/#atomic-execution","title":"Atomic Execution","text":""},{"location":"tutorials/atomic-swap/#create-atom","title":"Create atom","text":"<pre><code>const atom = await atomFactory.create(cashIssuer, [\n  {\n    contractAddress: notoAsset.address,\n    callData: assetUnlockCall,\n  },\n  {\n    contractAddress: zetoCash.address,\n    callData: encodedCashTransfer,\n  },\n]);\n</code></pre> <p>The Atom contract combines both prepared transactions into a single atomic unit. This ensures that: - Both transfers succeed together, or - Both transfers fail together - No partial execution is possible</p>"},{"location":"tutorials/atomic-swap/#approve-delegations","title":"Approve delegations","text":"<pre><code>// Approve asset unlock operation\nreceipt = await notoAsset\n  .using(paladin2)\n  .delegateLock(investor1, {\n    lockId,\n    unlock: assetUnlockParams,\n    delegate: atom.address,\n    data: \"0x\",\n  })\n  .waitForReceipt();\n\n// Approve cash transfer operation\nreceipt = await zetoCash\n  .using(paladin3)\n  .delegateLock(investor2, {\n    utxos: [lockedStateId],\n    delegate: atom.address,\n  })\n  .waitForReceipt();\n</code></pre> <p>Both investors delegate authority to the Atom contract, allowing it to execute their prepared transactions.</p>"},{"location":"tutorials/atomic-swap/#execute-the-swap","title":"Execute the swap","text":"<pre><code>await atom.using(paladin3).execute(investor2);\n</code></pre> <p>Finally, the atomic swap executes: 1. Asset transfer: 100 asset tokens transfer from investor1 to investor2 2. Cash transfer: 10 cash tokens transfer from investor2 to investor1 3. Atomic guarantee: Both transfers complete successfully together</p>"},{"location":"tutorials/atomic-swap/#key-concepts-demonstrated","title":"Key Concepts Demonstrated","text":""},{"location":"tutorials/atomic-swap/#atomic-transactions","title":"Atomic Transactions","text":"<p>The swap showcases Paladin's ability to create atomic transactions across different privacy domains. The Atom contract ensures that complex multi-step operations complete entirely or not at all.</p>"},{"location":"tutorials/atomic-swap/#cross-domain-interoperability","title":"Cross-Domain Interoperability","text":"<p>The example demonstrates seamless integration between: - Zeto for private cash transfers using zero-knowledge proofs - Noto for notarized asset transfers with custom business logic - Pente for private smart contract execution and state management</p>"},{"location":"tutorials/atomic-swap/#lock-and-prepare-pattern","title":"Lock-and-Prepare Pattern","text":"<p>The lock-and-prepare pattern enables secure multi-party transactions: 1. Lock tokens to prevent double-spending 2. Prepare transactions without executing them 3. Delegate execution authority to atomic contracts 4. Execute all operations atomically</p>"},{"location":"tutorials/atomic-swap/#privacy-preservation","title":"Privacy Preservation","text":"<p>Each domain maintains its privacy characteristics: - Zeto transfers remain anonymous through zero-knowledge proofs - Noto operations benefit from notary oversight and private hooks - Pente contracts keep business logic private within the group</p>"},{"location":"tutorials/atomic-swap/#next-steps","title":"Next Steps","text":"<p>Explore how these atomic transaction patterns can be extended to more complex scenarios like bond issuance, where multiple parties and privacy groups coordinate sophisticated financial workflows.</p> <p>Continue to the Bond Issuance Tutorial \u2192</p>"},{"location":"tutorials/bond-issuance/","title":"Bond Issuance","text":"<p>The code for this tutorial can be found in example/bond.</p> <p>This shows how to leverage the Noto and Pente domains together in order to build a bond issuance process, illustrating multiple aspects of Paladin's privacy capabilities.</p> <p></p>"},{"location":"tutorials/bond-issuance/#running-the-example","title":"Running the example","text":"<p>Follow the Getting Started instructions to set up a Paladin environment, and then follow the example README to run the code.</p>"},{"location":"tutorials/bond-issuance/#explanation","title":"Explanation","text":"<p>Below is a walkthrough of each step in the example, with an explanation of what it does.</p>"},{"location":"tutorials/bond-issuance/#cash-setup","title":"Cash setup","text":""},{"location":"tutorials/bond-issuance/#deploy-cash-token","title":"Deploy cash token","text":"<pre><code>const notoFactory = new NotoFactory(paladin1, \"noto\");\nconst notoCash = await notoFactory\n  .newNoto(cashIssuer, {\n    notary: cashIssuer,\n    notaryMode: \"basic\",\n  })\n  .waitForDeploy();\n</code></pre> <p>This creates a new instance of the Noto domain, which will translate to a new cloned contract on the base ledger, with a new unique address. This Noto token will be used to represent tokenized cash.</p> <p>The token will be notarized by the cash issuer party, meaning that all transactions will be sent to this party for endorsement. The Noto domain code at the notary will automatically verify that each transaction is valid - no custom policies will be applied.</p> <p>Minting is restricted to be requested only by the notary.</p>"},{"location":"tutorials/bond-issuance/#issue-cash","title":"Issue cash","text":"<pre><code>await notoCash\n  .mint(cashIssuer, {\n    to: investor,\n    amount: 100000,\n    data: \"0x\",\n  })\n  .waitForReceipt();\n</code></pre> <p>The cash issuer mints cash to the investor party. As the notary of the cash token, they are allowed to do this.</p>"},{"location":"tutorials/bond-issuance/#bond-setup","title":"Bond setup","text":""},{"location":"tutorials/bond-issuance/#create-issuercustodian-private-group","title":"Create issuer+custodian private group","text":"<pre><code>const penteFactory = new PenteFactory(paladin1, \"pente\");\nconst issuerCustodianGroup = await penteFactory\n  .newPrivacyGroup({\n    members: [bondIssuer, bondCustodian],\n    evmVersion: \"shanghai\",\n    externalCallsEnabled: true,\n  })\n  .waitForDeploy();\n</code></pre> <p>This creates a new instance of the Pente domain, which will be a private EVM group shared by the bond issuer and bond custodian. Each transaction proposed in this private EVM will need to be endorsed by both participants, and then the new state of the private EVM can be hashed and recorded on the base ledger contract.</p> <p>As will be shown in future steps, any EVM logic can be deployed into this private EVM group.</p>"},{"location":"tutorials/bond-issuance/#create-public-bond-tracker","title":"Create public bond tracker","text":"<pre><code>await paladin1.sendTransaction({\n  type: TransactionType.PUBLIC,\n  abi: bondTrackerPublicJson.abi,\n  bytecode: bondTrackerPublicJson.bytecode,\n  function: \"\",\n  from: bondIssuer.lookup,\n  data: {\n    owner: issuerCustodianGroup.address,\n    issueDate_: issueDate,\n    maturityDate_: maturityDate,\n    currencyToken_: notoCash.address,\n    faceValue_: 1,\n  },\n});\n</code></pre> <p>This sends a public EVM transaction to deploy the public bond tracker. This is equivalent to performing a deploy directly on the base ledger, without any special handling for privacy.</p> <p>The public bond tracker is used to advertise public information about our bond, such as its face value, issue date, and maturity date. It will also be updated with publically-visible events throughout the bond's lifetime.</p>"},{"location":"tutorials/bond-issuance/#create-private-bond-tracker","title":"Create private bond tracker","text":"<pre><code>const bondTracker = await newBondTracker(issuerCustodianGroup, bondIssuer, {\n  name: \"BOND\",\n  symbol: \"BOND\",\n  custodian: await bondCustodian.address(),\n  publicTracker: bondTrackerPublicAddress,\n});\n</code></pre> <p>The private bond tracker is an ERC-20 token, and implements the INotoHooks interface.</p> <p>Noto supports using a Pente private smart contract to define \"hooks\" which are executed inline with every mint/transfer. This provides a flexible (and EVM-native) means of writing custom policies that are enforced by the notary. In this case, the notary tracks the bond value as an ERC-20. Every mint and transfer of the Noto token will be reflected on this private ERC-20, and anything that causes the ERC-20 to revert will cause the Noto operation to revert. This private tracker is only visible to the bond issuer and custodian, but will be atomically linked to the Noto token in the next step.</p>"},{"location":"tutorials/bond-issuance/#deploy-bond-token","title":"Deploy bond token","text":"<pre><code>const notoBond = await notoFactory\n  .newNoto(bondIssuer, {\n    notary: bondCustodian,\n    notaryMode: \"hooks\",\n    options: {\n      hooks: {\n        privateGroup: issuerCustodianGroup,\n        publicAddress: issuerCustodianGroup.address,\n        privateAddress: bondTracker.address,\n      },\n    },\n  })\n  .waitForDeploy();\n</code></pre> <p>Now that the public and private tracking contracts have been deployed, the actual Noto token for the bond can be created. The \"hooks\" configuration points it to the private hooks contract that was deployed in the previous step.</p> <p>For this token, \"restrictMint\" is disabled, because the hooks can enforce more flexible rules on both mint and transfer.</p>"},{"location":"tutorials/bond-issuance/#create-factory-for-atomic-transactions","title":"Create factory for atomic transactions","text":"<pre><code>await paladin1.sendTransaction({\n  type: TransactionType.PUBLIC,\n  abi: atomFactoryJson.abi,\n  bytecode: atomFactoryJson.bytecode,\n  function: \"\",\n  from: bondIssuer.lookup,\n  data: {},\n});\n</code></pre> <p>Many programming patterns in Paladin will require a contract on the shared ledger that can prepare and execute atomic transactions. This is provided by the Atom and AtomFactory contracts.</p> <p>At least one instance of <code>AtomFactory</code> must be deployed to run this example. Once in place, note that this same factory contract can be reused for atomic transactions of any composition.</p>"},{"location":"tutorials/bond-issuance/#bond-issuance_1","title":"Bond issuance","text":""},{"location":"tutorials/bond-issuance/#issue-bond-to-custodian","title":"Issue bond to custodian","text":"<pre><code>await notoBond\n  .mint(bondIssuer, {\n    to: bondCustodian,\n    amount: 1000,\n    data: \"0x\",\n  })\n  .waitForReceipt();\n</code></pre> <p>This issues the bond to the bond custodian.</p> <p>The Noto \"mint\" request will be prepared and encoded within a call to the \"onMint\" hook in the private bond tracker contract. The logic in that contract will validate that the mint is allowed, and then will trigger two external calls on the base ledger: 1) to perform the Noto mint, and 2) to notify the public bond tracker that issuance has started.</p>"},{"location":"tutorials/bond-issuance/#begin-distribution-of-bond","title":"Begin distribution of bond","text":"<pre><code>await bondTracker\n  .using(paladin2)\n  .beginDistribution(bondCustodian, {\n    discountPrice: 1,\n    minimumDenomination: 1,\n  })\n  .waitForReceipt();\nconst investorList = await bondTracker.investorList(bondIssuer);\nawait investorList\n  .using(paladin2)\n  .addInvestor(bondCustodian, { addr: await investor.address() })\n  .waitForReceipt();\n</code></pre> <p>This allows the bond custodian to begin distributing the bond to potential investors. Each investor must be added to the allow list before they will be allowed to subscribe to the bond.</p> <p>Both the bond tracker and the investor registry are private contracts, visible only within the privacy group between the issuer and custodian.</p>"},{"location":"tutorials/bond-issuance/#bond-subscription","title":"Bond subscription","text":""},{"location":"tutorials/bond-issuance/#create-investorcustodian-private-group","title":"Create investor+custodian private group","text":"<pre><code>const investorCustodianGroup = await penteFactory\n  .using(paladin3)\n  .newPrivacyGroup({\n    members: [investor, bondCustodian],\n    evmVersion: \"shanghai\",\n    externalCallsEnabled: true,\n  })\n  .waitForDeploy();\n</code></pre> <p>This creates another instance of the Pente domain, scoped to only the investor and the custodian.</p>"},{"location":"tutorials/bond-issuance/#create-private-bond-subscription","title":"Create private bond subscription","text":"<pre><code>const bondSubscription = await newBondSubscription(\n  investorCustodianGroup,\n  investor,\n  {\n    bondAddress_: notoBond.address,\n    units_: 100,\n    custodian_: await bondCustodian.address(),\n    atomFactory_: atomFactoryAddress,\n  }\n);\n</code></pre> <p>An investor may request to subscribe to the bond by creating a private subscription contract in their private EVM with the bond custodian.</p>"},{"location":"tutorials/bond-issuance/#prepare-cash-transfer","title":"Prepare cash transfer","text":"<pre><code>receipt = await notoCash\n  .using(paladin3)\n  .lock(investor, {\n    amount: 100,\n    data: \"0x\",\n  })\n  .waitForReceipt();\n\nreceipt = await paladin3.getTransactionReceipt(receipt.id, true);\nlet domainReceipt = receipt?.domainReceipt as INotoDomainReceipt | undefined;\nconst cashLockId = domainReceipt?.lockInfo?.lockId;\n\nreceipt = await notoCash\n  .using(paladin3)\n  .prepareUnlock(investor, {\n    lockId: cashLockId,\n    from: investor,\n    recipients: [{ to: bondCustodian, amount: 100 }],\n    data: \"0x\",\n  })\n  .waitForReceipt(5000, true);\n\ndomainReceipt = receipt?.domainReceipt as INotoDomainReceipt | undefined;\nconst cashUnlockParams = domainReceipt?.lockInfo?.unlockParams;\nconst cashUnlockCall = domainReceipt?.lockInfo?.unlockCall;\n</code></pre> <p>The investor prepares a cash payment by calling \"lock\" and then \"prepareUnlock\". This will set aside some amount of value in the form of locked UTXOs (which will be temporarily removed from the sender's spending pool) and then prepare (but not execute) an unlock operation. The unlock transaction can be delegated to another party or contract to allow them to execute the payment transfer.</p>"},{"location":"tutorials/bond-issuance/#prepare-bond-transfer","title":"Prepare bond transfer","text":"<pre><code>receipt = await notoBond\n  .using(paladin2)\n  .lock(bondCustodian, {\n    amount: 100,\n    data: \"0x\",\n  })\n  .waitForReceipt(5000, true);\n\nreceipt = await paladin2.getTransactionReceipt(receipt.id, true);\ndomainReceipt = receipt?.domainReceipt as INotoDomainReceipt | undefined;\nconst bondLockId = domainReceipt?.lockInfo?.lockId;\n\nreceipt = await notoBond\n  .using(paladin2)\n  .prepareUnlock(bondCustodian, {\n    lockId: bondLockId,\n    from: bondCustodian,\n    recipients: [{ to: investor, amount: 100 }],\n    data: \"0x\",\n  })\n  .waitForReceipt(5000, true);\n\ndomainReceipt = receipt?.domainReceipt as INotoDomainReceipt | undefined;\nconst assetUnlockParams = domainReceipt?.lockInfo?.unlockParams;\nconst assetUnlockCall = domainReceipt?.lockInfo?.unlockCall;\n</code></pre> <p>The bond custodian prepares a similar transaction for the bond, using the same \"lock\" and \"prepareUnlock\" pattern to prepare a bond transfer to the investor.</p>"},{"location":"tutorials/bond-issuance/#share-the-prepared-transactions-with-the-private-contract","title":"Share the prepared transactions with the private contract","text":"<pre><code>await bondSubscription\n  .using(paladin3)\n  .preparePayment(investor, {\n    to: notoCash.address,\n    encodedCall: cashUnlockCall,\n  })\n  .waitForReceipt();\n\nawait bondSubscription\n  .using(paladin2)\n  .prepareBond(bondCustodian, {\n    to: notoBond.address,\n    encodedCall: assetUnlockCall,\n  })\n  .waitForReceipt();\n</code></pre> <p>The <code>preparePayment</code> and <code>prepareBond</code> methods on the bond subscription contract allow the respective parties to encode their prepared transactions, in preparation for triggering an atomic DvP (delivery vs. payment).</p>"},{"location":"tutorials/bond-issuance/#prepare-the-atomic-transaction-for-the-swap","title":"Prepare the atomic transaction for the swap","text":"<pre><code>await bondSubscription\n  .using(paladin2)\n  .distribute(bondCustodian)\n  .waitForReceipt();\n</code></pre> <p>When both parties have prepared their individual transactions, they can be combined into a single base ledger transaction. The <code>distribute()</code> method below is a private method on the <code>BondSubscription</code> contract, but it triggers creation of a new <code>Atom</code> contract on the base ledger which contains the encoded transactions prepared above.</p> <p>Once an <code>Atom</code> is deployed, it can be used to execute all or none of the transactions it contains. It can never be changed, executed partially, or executed more than once.</p>"},{"location":"tutorials/bond-issuance/#approve-delegation-via-the-private-contract","title":"Approve delegation via the private contract","text":"<pre><code>await notoCash\n  .using(paladin3)\n  .delegateLock(investor, {\n    lockId: cashLockId,\n    unlock: cashUnlockParams,\n    delegate: atomAddress,\n    data: \"0x\",\n  })\n  .waitForReceipt();\n\nawait notoBond\n  .using(paladin2)\n  .delegateLock(bondCustodian, {\n    lockId: bondLockId,\n    unlock: assetUnlockParams,\n    delegate: atomAddress,\n    data: \"0x\",\n  })\n  .waitForReceipt();\n</code></pre> <p>Once the <code>Atom</code> is deployed, it must be designated as the approved delegate for both the payment transfer and the bond transfer. Because this binds a specific set of atomic operations to a unique contract address, both parties can be assured that by approving this address as a delegate, the only transaction that can take place is the agreed swap.</p> <p>In the case of the payment, we use the <code>approveTransfer</code> method of Noto. For the bond, which uses Pente custom logic to wrap the Noto token, we use the <code>approveTransition</code> method of Pente.</p>"},{"location":"tutorials/bond-issuance/#distribute-the-bond-units-by-performing-swap","title":"Distribute the bond units by performing swap","text":"<pre><code>await paladin2.sendTransaction({\n  type: TransactionType.PUBLIC,\n  abi: atomJson.abi,\n  function: \"execute\",\n  from: bondCustodian.lookup,\n  to: atomAddress,\n  data: {},\n});\n</code></pre> <p>Finally, the custodian executes the <code>Atom</code> to trigger the exchange of the bond and payment.</p> <p>This will trigger the previously-prepared transactions for the cash transfer and the bond transfer, and it will also trigger an external call to the public bond tracker to decrease the advertised available supply of the bond.</p>"},{"location":"tutorials/bond-issuance/#conclusion","title":"Conclusion","text":"<p>This scenario shows how to work with the following concepts:</p> <ul> <li>Basic Noto tokens</li> <li>Noto tokens with custom hooks via Pente</li> <li>Multiple Pente privacy groups used for sharing private data</li> <li>Pente private smart contracts that trigger external calls to contracts on the base ledger</li> </ul> <p>By using these features together, it's possible to build a robust issuance process that tracks all state on the base EVM ledger, while still keeping all private data scoped to only the proper parties.</p>"},{"location":"tutorials/hello-world/","title":"Hello World with Paladin","text":"<p>This tutorial walks you through deploying and interacting with a simple <code>HelloWorld</code> smart contract using the Paladin SDK. The example demonstrates how to:</p> <ol> <li>Deploy the contract,</li> <li>Interact with it by calling its <code>sayHello</code> function,</li> <li>Retrieve and verify the emitted event.</li> </ol> <p>This tutorial demonstrates how traditional, non-private Ethereum smart contract interactions can be achieved via a Paladin node and its transaction manager. Later tutorials will demonstrate how to make use of more advanced features of the Paladin APIs.</p>"},{"location":"tutorials/hello-world/#running-the-example","title":"Running the Example","text":"<p>The example code can be found in the Paladin example repository.</p> <p>The HelloWorld solidity contract can be found here.</p> <p>Follow the Getting Started instructions to set up a Paladin environment. Then, follow the example README to run the code.</p>"},{"location":"tutorials/hello-world/#overview","title":"Overview","text":"<p>We have a <code>HelloWorld</code> smart contract, which:</p> <ul> <li>Emits a \"welcome\" message as an event when its <code>sayHello</code> function is called.</li> </ul>"},{"location":"tutorials/hello-world/#key-artifacts","title":"Key Artifacts","text":"<p>To deploy and interact with the contract, we use:</p> <ol> <li>ABI: Describes the contract's interface, including its functions and events.</li> <li>Bytecode: The compiled contract code.</li> </ol> <p>These are pre-compiled and provided in the <code>helloWorldJson</code> object.</p> <p>To address the PR comment and clarify the differences between contract deployment and function invocation, here\u2019s a revised version of the tutorial with an explicit callout:</p>"},{"location":"tutorials/hello-world/#step-1-deploy-the-contract","title":"Step 1: Deploy the Contract","text":"<pre><code>const deploymentTxID = await paladin.ptx.sendTransaction({\n  type: TransactionType.PUBLIC,\n  abi: helloWorldJson.abi,\n  bytecode: helloWorldJson.bytecode,\n  from: owner.lookup,\n  data: {},\n});\n</code></pre>"},{"location":"tutorials/hello-world/#key-differences-vs-calling-a-contract-function","title":"Key Differences (vs. calling a contract function)","text":"<ul> <li>Deployment requires <code>bytecode</code>, as it is creating a new contract on the blockchain.</li> <li>No <code>to</code> address is specified, since a contract does not yet exist at this stage.</li> <li>No specific function is called, since this is an initial deployment.</li> </ul>"},{"location":"tutorials/hello-world/#what-happens","title":"What happens:","text":"<ul> <li>The <code>sendTransaction</code> method sends a deployment transaction to the blockchain via Paladin.</li> <li>The function returns a <code>deploymentTxID</code> that uniquely identifies the transaction.</li> </ul>"},{"location":"tutorials/hello-world/#step-2-confirm-the-deployment","title":"Step 2: Confirm the Deployment","text":"<pre><code>const deploymentReceipt = await paladin.pollForReceipt(\n  deploymentTxID,\n  10000,\n  true\n);\nif (!deploymentReceipt?.contractAddress) {\n  logger.error(\"Deployment failed!\");\n  return false;\n}\nlogger.log(\n  \"Contract deployed successfully at address:\",\n  deploymentReceipt.contractAddress\n);\n</code></pre>"},{"location":"tutorials/hello-world/#what-happens_1","title":"What happens:","text":"<ul> <li>We use <code>pollForReceipt</code> to wait for the deployment transaction to be confirmed.</li> <li>If successful, the receipt includes the new <code>contractAddress</code>, which we will use in the next step.</li> </ul>"},{"location":"tutorials/hello-world/#step-3-call-the-sayhello-function","title":"Step 3: Call the <code>sayHello</code> Function","text":"<pre><code>const name = \"Paladin User\"; // Example name for the greeting\n\nconst sayHelloTxID = await paladin.ptx.sendTransaction({\n  type: TransactionType.PUBLIC,\n  abi: helloWorldJson.abi,\n  function: \"sayHello\",\n  from: owner.lookup,\n  to: deploymentReceipt.contractAddress,\n  data: { name: name },\n});\n</code></pre>"},{"location":"tutorials/hello-world/#key-differences-vs-contract-deployment","title":"Key Differences (vs. contract deployment)","text":"<ul> <li>Function calls require a <code>to</code> address, since the contract already exists.</li> <li>No <code>bytecode</code> is needed, as we are invoking an existing contract, not creating one.</li> <li>A specific function (<code>sayHello</code>) is provided, along with its arguments in <code>data</code>.</li> </ul>"},{"location":"tutorials/hello-world/#what-happens_2","title":"What happens:","text":"<ul> <li>The <code>sendTransaction</code> method sends a transaction to call the <code>sayHello</code> function of the deployed contract.</li> <li>The <code>data</code> object includes the function arguments\u2014in this case, the <code>name</code> of the person being greeted.</li> </ul>"},{"location":"tutorials/hello-world/#step-4-confirm-the-function-call","title":"Step 4: Confirm the Function Call","text":"<pre><code>const functionReceipt = await paladin.pollForReceipt(sayHelloTxID, 10000, true);\nif (!functionReceipt?.transactionHash) {\n  logger.error(\"Receipt retrieval failed!\");\n  return false;\n}\nlogger.log(\"sayHello function executed successfully!\");\n</code></pre> <ul> <li>What happens:</li> <li>Similar to the deployment step, we wait for confirmation of the <code>sayHello</code> function call using <code>pollForReceipt</code>.</li> </ul>"},{"location":"tutorials/hello-world/#step-5-retrieve-the-emitted-event","title":"Step 5: Retrieve the Emitted Event","text":"<pre><code>const events = await paladin.bidx.decodeTransactionEvents(\n  functionReceipt.transactionHash,\n  helloWorldJson.abi,\n  \"pretty=true\"\n);\n\nlogger.log(events[0].data[\"message\"]);\n</code></pre> <ul> <li>What happens:</li> <li>We use <code>decodeTransactionEvents</code> to extract event data from the <code>sayHello</code> transaction.</li> </ul>"},{"location":"tutorials/hello-world/#conclusion","title":"Conclusion","text":"<p>Congratulations! You've successfully:</p> <ol> <li>Deployed the <code>HelloWorld</code> contract,</li> <li>Called its <code>sayHello</code> function,</li> <li>Retrieved and validated the emitted event.</li> </ol> <p>This simple example demonstrates how to interact with smart contracts using the Paladin SDK.</p>"},{"location":"tutorials/hello-world/#next-steps","title":"Next Steps","text":"<p>Now that you\u2019ve deployed and interacted with the <code>HelloWorld</code> contract, you\u2019re ready to explore more complex interactions with smart contracts. In the next tutorial, we will introduce you to a Storage contract where you will write and read from from the blockchain!</p> <p>Continue to the Storage Contract Tutorial \u2192</p>"},{"location":"tutorials/notarized-tokens/","title":"Notarized Tokens","text":"<p>In this tutorial, you\u2019ll learn how to create and manage Notarized Tokens (Noto) within Paladin. Unlike simple private storage, Notarized Tokens allow secure, private exchanges while maintaining verifiability.</p>"},{"location":"tutorials/notarized-tokens/#why-use-notarized-tokens","title":"Why Use Notarized Tokens?","text":"<ul> <li>Privacy-Preserving Transfers \u2013 Transactions remain private, visible only to relevant parties.</li> <li>Notary-Controlled Oversight \u2013 A designated notary approves and submits every transaction, ensuring compliance and control.</li> <li>Selective Disclosure \u2013 Owners can prove token ownership by selectively revealing transaction details when needed.</li> </ul> <p>This tutorial will guide you through issuing, transferring, and verifying tokens using Paladin\u2019s notarization model.</p>"},{"location":"tutorials/notarized-tokens/#prerequisites","title":"Prerequisites","text":"<p>Before starting, ensure you have:</p> <ol> <li>Completed the Private Smart Contract Tutorial.</li> <li>A running Paladin network with at least three nodes (Node1, Node2, and Node3).</li> </ol>"},{"location":"tutorials/notarized-tokens/#overview","title":"Overview","text":"<p>This tutorial will cover:</p> <ol> <li>Deploying a Noto Token \u2013 Creating a \u201ccash token\u201d with a designated notary.</li> <li>Minting Tokens \u2013 Issuing new tokens into circulation.</li> <li>Transferring Tokens \u2013 Simulating payments by moving tokens between nodes.</li> </ol> <p>\ud83d\udca1 The complete example code is available in the Paladin example repository.</p>"},{"location":"tutorials/notarized-tokens/#step-1-deploy-a-noto-token","title":"Step 1: Deploy a Noto Token","text":"<p>First, create a Noto Factory instance and deploy a new token. Node1 will act as the notary, responsible for approving and submitting all transactions related to this token. Additionally, Node1 will be the initial recipient of the minted tokens.</p> <pre><code>logger.log(\"Step 1: Deploying a Noto cash token...\");\nconst notoFactory = new NotoFactory(paladinClientNode1, \"noto\");\nconst cashToken = await notoFactory\n  .newNoto(verifierNode1, {\n    notary: verifierNode1,\n    notaryMode: \"basic\",\n  })\n  .waitForDeploy();\nif (!cashToken) {\n  logger.error(\"Failed to deploy the Noto cash token!\");\n  return false;\n}\nlogger.log(\"Noto cash token deployed successfully!\");\n</code></pre>"},{"location":"tutorials/notarized-tokens/#why-the-notary-role-matters","title":"Why the Notary Role Matters","text":"<p>The notary is more than just a minting authority\u2014it plays a fundamental role in the Noto token model:</p> <ul> <li>Approves and submits all token transactions to the network.</li> <li>Maintains full visibility over all token movements.</li> <li>Ensures transaction integrity and compliance with predefined rules.</li> </ul> <p>By designating a notary, every transaction must be verified and approved, ensuring controlled and auditable token transfers.</p>"},{"location":"tutorials/notarized-tokens/#step-2-mint-tokens","title":"Step 2: Mint Tokens","text":"<p>With the token contract deployed, let\u2019s mint an initial supply of tokens for Node1. This simulates creating new \u201ccash\u201d in the system.</p> <pre><code>logger.log(\"Step 2: Minting 2000 units of cash to Node1...\");\nconst mintReceipt = await cashToken\n  .mint(verifierNode1, {\n    to: verifierNode1,\n    amount: 2000,\n    data: \"0x\",\n  })\n  .waitForReceipt();\nif (!mintReceipt) {\n  logger.error(\"Failed to mint cash tokens!\");\n  return false;\n}\nlogger.log(\"Successfully minted 2000 units of cash to Node1!\");\n</code></pre>"},{"location":"tutorials/notarized-tokens/#what-happens-here","title":"What Happens Here?","text":"<ol> <li>Node1 submits a minting request to the notary (in this case, node1 is the notary so it will be receiving and validating it's own request).</li> <li>The notary reviews and approves the request.</li> <li>Tokens are minted and assigned to the recipient.</li> <li>The <code>data</code> field is recorded in the transaction receipt for auditability.</li> </ol>"},{"location":"tutorials/notarized-tokens/#key-parameters","title":"Key Parameters","text":"<ul> <li><code>amount</code> \u2013 Number of tokens to create.</li> <li><code>to</code> \u2013 Recipient of the newly minted tokens.</li> <li><code>data</code> \u2013 (Optional) Can include metadata or extra information about the transaction.</li> </ul> <p>\ud83d\udca1 The data field is stored in the transaction receipt, making it useful for audits or tracking purposes.</p>"},{"location":"tutorials/notarized-tokens/#step-3-transfer-tokens-to-node2","title":"Step 3: Transfer Tokens to Node2","text":"<p>Now that Node1 has tokens, let\u2019s transfer some to Node2. This works similarly to a bank transfer.</p> <pre><code>logger.log(\"Step 3: Transferring 1000 units of cash from Node1 to Node2...\");\nconst transferToNode2 = await cashToken\n  .transfer(verifierNode1, {\n    to: verifierNode2,\n    amount: 1000,\n    data: \"0x\",\n  })\n  .waitForReceipt();\nif (!transferToNode2) {\n  logger.error(\"Failed to transfer cash to Node2!\");\n  return false;\n}\nlogger.log(\"Successfully transferred 1000 units of cash to Node2!\");\n</code></pre>"},{"location":"tutorials/notarized-tokens/#step-4-transfer-tokens-to-node3","title":"Step 4: Transfer Tokens to Node3","text":"<p>Now let\u2019s see how Node2 transfers tokens to Node3. Since Node2 is initiating the transaction, we call <code>.using(paladinClientNode2)</code> to ensure Node2 signs the transaction instead of Node1.</p> <pre><code>logger.log(\"Step 4: Transferring 800 units of cash from Node2 to Node3...\");\nconst transferToNode3 = await cashToken\n  .using(paladinClientNode2)\n  .transfer(verifierNode2, {\n    to: verifierNode3,\n    amount: 800,\n    data: \"0x\",\n  })\n  .waitForReceipt();\nif (!transferToNode3) {\n  logger.error(\"Failed to transfer cash to Node3!\");\n  return false;\n}\nlogger.log(\"Successfully transferred 800 units of cash to Node3!\");\n</code></pre>"},{"location":"tutorials/notarized-tokens/#transaction-privacy-in-paladin","title":"Transaction Privacy in Paladin","text":"<p>Unlike traditional blockchains, Paladin\u2019s notarized token model ensures that not all participants see every transaction:</p> <ul> <li>The notary has full visibility over all token transfers.</li> <li>Node2 and Node3 only see transactions they were involved in.</li> <li>Other nodes have no visibility into the transfer.</li> </ul>"},{"location":"tutorials/notarized-tokens/#conclusion","title":"Conclusion","text":"<p>Congratulations! You have successfully:</p> <ol> <li>Deployed a Noto token to represent cash within the Paladin network.</li> <li>Minted tokens under a notary\u2019s supervision.</li> <li>Transferred tokens between nodes while maintaining privacy and control.</li> </ol> <p>At this point, you understand how to issue, manage, and transfer notarized tokens within Paladin.</p>"},{"location":"tutorials/notarized-tokens/#next-steps","title":"Next Steps","text":"<p>Now that you\u2019ve explored Notarized Tokens, you\u2019re ready to delve into Zeto, Paladin\u2019s zero-knowledge domain for enhanced privacy. In the next tutorial, you\u2019ll learn how to build a privacy-preserving cash payment system using advanced techniques such as private minting and selective disclosure.</p> <p>Continue to the Zero-Knowledge Proof Tutorial \u2192</p>"},{"location":"tutorials/private-stablecoin/","title":"Private Stablecoin with KYC and Deposit/Withdraw","text":"<p>The code for this tutorial can be found in example/private-stablecoin.</p> <p>This example demonstrates a private stablecoin with KYC compliance that exists as both a public ERC20 token and a private Zeto token, showcasing deposit/withdraw functionality using Paladin's Zeto domain. It illustrates how financial institutions can manage regulatory compliance while enabling users to seamlessly move between public and private representations of the same asset for enhanced privacy preservation.</p>"},{"location":"tutorials/private-stablecoin/#running-the-example","title":"Running the example","text":"<p>Follow the Getting Started instructions to set up a Paladin environment, and then follow the example README to run the code.</p>"},{"location":"tutorials/private-stablecoin/#key-features","title":"Key Features","text":"<p>This tutorial demonstrates:</p> <ul> <li>Dual Token System \u2013 Same asset exists as both public ERC20 and private Zeto tokens</li> <li>KYC Compliance \u2013 Financial institution manages client registration for regulatory compliance</li> <li>Seamless Deposit \u2013 Convert public ERC20 tokens to private Zeto tokens</li> <li>Private Transfers \u2013 Zero-knowledge proof-based transfers with KYC verification and complete privacy</li> <li>Seamless Withdraw \u2013 Convert private Zeto tokens back to public ERC20 tokens, optionally to a different account owned by the depositor</li> <li>Flexible Liquidity \u2013 Users can choose between public transparency and private anonymity while maintaining compliance</li> </ul>"},{"location":"tutorials/private-stablecoin/#scenario-overview","title":"Scenario Overview","text":"<ul> <li>Financial Institution (Node 1) \u2013 Deploys contracts, manages KYC registration, and issues stablecoins</li> <li>Client A (Node 2) \u2013 Enterprise client receiving and transacting with stablecoins</li> <li>Client B (Node 3) \u2013 Enterprise client receiving private transfers and withdrawing tokens</li> </ul> <p>The financial institution manages the entire lifecycle from contract deployment through KYC registration to token issuance and oversight.</p>"},{"location":"tutorials/private-stablecoin/#step-by-step-walkthrough","title":"Step-by-Step Walkthrough","text":""},{"location":"tutorials/private-stablecoin/#1-deploy-contract-infrastructure","title":"1. Deploy Contract Infrastructure","text":"<p>The example begins by deploying both the public ERC20 and private Zeto contracts:</p> <pre><code>// Deploy private stablecoin using Zeto_AnonNullifierKyc\nconst zetoFactory = new ZetoFactory(paladin1, \"zeto\");\nconst privateStablecoin = await zetoFactory\n  .newZeto(financialInstitution, {\n    tokenName: \"Zeto_AnonNullifierKyc\",\n  })\n  .waitForDeploy();\n\n// Deploy public ERC20 stablecoin\nconst publicStablecoinAddress = await deployERC20(paladin1, financialInstitution);\n\n// Connect the ERC20 to the Zeto contract for deposit/withdraw\nawait privateStablecoin\n  .setERC20(financialInstitution, {\n    erc20: publicStablecoinAddress,\n  })\n  .waitForReceipt();\n</code></pre> <p>The <code>Zeto_AnonNullifierKyc</code> contract provides:</p> <ul> <li>Anonymous transfers with zero-knowledge proofs</li> <li>Nullifier protection against double-spending</li> <li>KYC compliance verification for all participants</li> <li>Deposit/withdraw functionality for ERC20 integration</li> </ul>"},{"location":"tutorials/private-stablecoin/#2-kyc-registration-process","title":"2. KYC Registration Process","text":"<p>Before any stablecoin operations, the financial institution registers all participants for KYC compliance:</p> <pre><code>// Financial institution registers itself\nconst bankPublicKey = await getBabyjubPublicKey(financialInstitution);\nlet kycTxId = await paladin1.ptx.sendTransaction({\n  type: TransactionType.PUBLIC,\n  from: financialInstitution.lookup,\n  to: privateStablecoin.address,\n  data: {\n    publicKey: bankPublicKey,\n    data: \"0x\", // KYC compliance data could go here\n  },\n  function: \"register\",\n  abi: kycAbi.abi,\n});\n\n// Register Client A and Client B similarly...\n</code></pre> <p>KYC Benefits:</p> <ul> <li>Regulatory compliance \u2013 All participants verified before token operations</li> <li>Privacy-preserving verification \u2013 Uses BabyJubJub keys compatible with zero-knowledge proofs</li> <li>Financial institution control \u2013 Centralized KYC management by the issuing institution</li> <li>Cryptographic identity binding \u2013 Links identity verification to cryptographic keys</li> </ul>"},{"location":"tutorials/private-stablecoin/#3-mint-public-stablecoins","title":"3. Mint Public Stablecoins","text":"<p>The financial institution mints public ERC20 stablecoins to clients:</p> <pre><code>// Mint public stablecoins to Client A\nawait mintERC20(paladin1, financialInstitution, clientA, publicStablecoinAddress, 100000);\n\n// Mint public stablecoins to Client B  \nawait mintERC20(paladin1, financialInstitution, clientB, publicStablecoinAddress, 50000);\n</code></pre> <p>Public Token Benefits:</p> <ul> <li>Transparent balances \u2013 All ERC20 balances are publicly visible</li> <li>Standard compatibility \u2013 Works with existing DeFi protocols</li> <li>Regulatory compliance \u2013 Full transaction transparency for oversight</li> <li>Familiar interface \u2013 Standard ERC20 functionality</li> </ul>"},{"location":"tutorials/private-stablecoin/#4-deposit-public-to-private","title":"4. Deposit: Public to Private","text":"<p>Client A decides to deposit some public tokens for privacy:</p> <pre><code>// Client A approves Zeto contract to spend their ERC20 tokens\nawait approveERC20(\n  paladin2,\n  clientA,\n  privateStablecoin.address,\n  publicStablecoinAddress,\n  75000\n);\n\n// Client A deposits ERC20 tokens to get private Zeto tokens\nconst depositReceipt = await privateStablecoin\n  .using(paladin2)\n  .deposit(clientA, {\n    amount: 75000,\n  })\n  .waitForReceipt();\n</code></pre> <p>Privacy Benefits:</p> <ul> <li>Token amounts become private \u2013 No longer visible on public ledger</li> <li>Identity protection \u2013 Client's balance and activity become anonymous</li> <li>Zero-knowledge security \u2013 Cryptographic proofs ensure validity with KYC compliance</li> <li>Reversible process \u2013 Can withdraw back to public tokens anytime</li> </ul>"},{"location":"tutorials/private-stablecoin/#5-private-transfers-with-kyc-verification","title":"5. Private Transfers with KYC Verification","text":"<p>Client A makes a private transfer to Client B, with automatic KYC verification:</p> <pre><code>const transferReceipt = await privateStablecoin\n  .using(paladin2)\n  .transfer(clientA, {\n    transfers: [\n      {\n        to: clientB,\n        amount: 25000, // Transfer 25,000 private tokens\n        data: \"0x\",\n      },\n    ],\n  })\n  .waitForReceipt();\n</code></pre> <p>KYC-Verified Privacy Features:</p> <ul> <li>Automated compliance \u2013 Transfer only succeeds if both parties are KYC-verified</li> <li>Zero-knowledge verification \u2013 KYC status verified without revealing identity details</li> <li>Private amounts \u2013 Transfer amounts remain completely private</li> <li>Regulatory confidence \u2013 Financial institution maintains oversight capability</li> </ul>"},{"location":"tutorials/private-stablecoin/#6-withdraw-private-to-public","title":"6. Withdraw: Private to Public","text":"<p>Client B withdraws some private tokens back to public ERC20:</p> <pre><code>const withdrawReceipt = await privateStablecoin\n  .using(paladin3)\n  .withdraw(clientB, {\n    amount: 15000, // Withdraw 15,000 tokens\n  })\n  .waitForReceipt();\n</code></pre> <p>Withdrawal Benefits:</p> <ul> <li>Seamless conversion \u2013 Private tokens automatically converted to public ERC20</li> <li>Preserved compliance \u2013 KYC verification carries through to public domain</li> <li>Full interoperability \u2013 Withdrawn tokens work with any ERC20-compatible system</li> <li>Transparent balances \u2013 Public tokens provide transparency when needed</li> </ul>"},{"location":"tutorials/private-stablecoin/#privacy-and-compliance-integration","title":"Privacy and Compliance Integration","text":""},{"location":"tutorials/private-stablecoin/#how-kyc-works-with-zero-knowledge-proofs","title":"How KYC Works with Zero-Knowledge Proofs","text":"<p>This example demonstrates a powerful combination of privacy and compliance:</p> <ul> <li>Registration Phase \u2013 Financial institution registers client identities with their cryptographic keys</li> <li>Proof Generation \u2013 During transfers, zero-knowledge proofs verify KYC status without revealing identity</li> <li>Compliance Assurance \u2013 All private transactions are automatically verified against the KYC registry</li> <li>Privacy Preservation \u2013 Transaction amounts and participant identities remain private to external observers</li> </ul>"},{"location":"tutorials/private-stablecoin/#use-cases","title":"Use Cases","text":"<p>This private stablecoin with KYC pattern is suitable for:</p> <ul> <li>Regulated DeFi protocols \u2013 Privacy-preserving DeFi with built-in compliance</li> <li>Corporate treasury management \u2013 Enterprise payments with regulatory oversight</li> <li>Cross-border remittances \u2013 Private transfers with KYC compliance</li> <li>Wholesale CBDC implementations \u2013 Central bank digital currencies with privacy features</li> <li>Supply chain finance \u2013 Private B2B payments with verified participants</li> </ul>"},{"location":"tutorials/private-stablecoin/#conclusion","title":"Conclusion","text":"<p>The Private Stablecoin with KYC example demonstrates how Paladin enables:</p> <ul> <li>Regulatory compliance through automated KYC verification using zero-knowledge proofs</li> <li>Transaction privacy while maintaining compliance assurance</li> <li>Seamless public-private interoperability through deposit/withdraw functionality</li> <li>Financial institution control over customer onboarding and compliance</li> <li>Enterprise-grade security through nullifier-based double-spend protection</li> </ul> <p>This showcases Paladin's unique capability to balance privacy preservation with regulatory compliance, enabling financial institutions to offer innovative privacy-preserving services while meeting their compliance obligations.</p>"},{"location":"tutorials/private-stablecoin/#next-steps","title":"Next Steps","text":"<p>Explore how Notarized Tokens and ZKP Tokens can be used together in an atomic swap scenario.</p> <p>Continue to the Atomic Swap Tutorial \u2192</p>"},{"location":"tutorials/private-storage/","title":"Private Smart Contract (SimpleStorage)","text":"<p>In this tutorial, you'll learn how to deploy and interact with a private storage contract using Paladin\u2019s privacy groups. Unlike the public storage contract, where data is visible to everyone, private storage ensures that only authorized members of a privacy group can interact with the contract.</p> <p>If you're new to Pente privacy groups or want to dive deeper into their architecture, check out the Pente documentation for more information.</p>"},{"location":"tutorials/private-storage/#prerequisites","title":"Prerequisites","text":"<p>Before starting, make sure you have:</p> <ol> <li>Completed the Public Smart Contract Tutorial and are familiar with:</li> <li>Deploying and interacting with smart contracts.</li> <li>Using the Paladin SDK for blockchain transactions.</li> <li>A running Paladin network with at least three nodes (Node1, Node2, Node3).</li> </ol>"},{"location":"tutorials/private-storage/#overview","title":"Overview","text":"<p>This tutorial will guide you through:</p> <ol> <li>Creating a privacy group \u2013 Define a private transaction group that includes selected members.</li> <li>Deploying a private contract \u2013 Deploy a Storage contract that only privacy group members can interact with.</li> <li>Interacting with the contract \u2013 Members will store and retrieve values securely.</li> <li>Testing unauthorized access \u2013 A non-member (Node3) will attempt to retrieve data, demonstrating privacy enforcement.</li> </ol> <p>There is a second example (<code>update.js</code>) in the privacy storage example folder which does the following:</p> <ol> <li>Attaches to an existing privacy group and private storage smart contract</li> <li>Reads the value of the existing smart contract, then adds a new random number to it</li> <li>Writes the newly update value to the smart contract</li> </ol> <p>You can use this second example to learn about using resuming use of existing privacy groups and contracts.</p> <p>The full example code is available in the Paladin example repository.</p>"},{"location":"tutorials/private-storage/#step-1-create-a-privacy-group","title":"Step 1: Create a Privacy Group","text":"<p>To restrict contract access to specific members, you first need to create a privacy group.</p> <pre><code>logger.log(\"Creating a privacy group for Node1 and Node2...\");\nconst penteFactory = new PenteFactory(paladinNode1, \"pente\");\nconst memberPrivacyGroup = await penteFactory.newPrivacyGroup({\n  members: [verifierNode1, verifierNode2],\n  evmVersion: \"shanghai\",\n  externalCallsEnabled: true,\n}).waitForDeploy();\n</code></pre>"},{"location":"tutorials/private-storage/#key-points","title":"Key Points:","text":"<ol> <li>The privacy group consists of Node1 and Node2.</li> <li>Transactions within this group will only be visible to these members.</li> <li>Node3 is excluded, meaning it won\u2019t have access to private transactions.</li> </ol>"},{"location":"tutorials/private-storage/#step-2-deploy-the-contract-in-the-privacy-group","title":"Step 2: Deploy the Contract in the Privacy Group","text":"<p>Now that the privacy group is established, deploy the <code>Storage</code> contract inside this group.</p> <pre><code>logger.log(\"Deploying a smart contract to the privacy group...\");\nconst contractAddress = await memberPrivacyGroup.deploy({\n  abi: storageJson.abi,\n  bytecode: storageJson.bytecode,\n  from: verifierNode1.lookup,\n}).waitForDeploy();\n</code></pre>"},{"location":"tutorials/private-storage/#key-points_1","title":"Key Points","text":"<ol> <li>The contract is deployed inside the privacy group, meaning only group members can interact with it.</li> <li>Transactions involving this contract are private and only visible to Node1 &amp; Node2.</li> </ol>"},{"location":"tutorials/private-storage/#step-3-store-and-retrieve-values-as-group-members","title":"Step 3: Store and Retrieve Values as Group Members","text":""},{"location":"tutorials/private-storage/#storing-a-value","title":"Storing a Value","text":"<p>Now that the contract is deployed, Node1 can store a value.</p> <pre><code>const privateStorageContract = new PrivateStorage(\n  memberPrivacyGroup,\n  contractAddress\n);\n\nconst valueToStore = 125; // Example value to store\nlogger.log(`Storing a value \"${valueToStore}\" in the contract...`);\nconst storeReceipt = await privateStorageContract.sendTransaction({\n  from: verifierNode1.lookup,\n  function: \"store\",\n  data: { num: valueToStore },\n}).waitForReceipt();\nlogger.log(\n  \"Value stored successfully! Transaction hash:\",\n  storeReceipt?.transactionHash\n);\n</code></pre>"},{"location":"tutorials/private-storage/#retrieving-the-stored-value","title":"Retrieving the Stored Value","text":"<p>Group members Node1 &amp; Node2 can now retrieve the stored value.</p> <pre><code>// Retrieve the value as Node1\nlogger.log(\"Node1 retrieving the value from the contract...\");\nconst retrievedValueNode1 = await privateStorageContract.call({\n  from: verifierNode1.lookup,\n  function: \"retrieve\",\n});\nlogger.log(\n  \"Node1 retrieved the value successfully:\",\n  retrievedValueNode1[\"value\"]\n);\n\n// Retrieve the value as Node2\nlogger.log(\"Node2 retrieving the value from the contract...\");\nconst retrievedValueNode2 = await privateStorageContract\n  .using(paladinNode2)\n  .call({\n    from: verifierNode2.lookup,\n    function: \"retrieve\",\n  });\nlogger.log(\n  \"Node2 retrieved the value successfully:\",\n  retrievedValueNode2[\"value\"]\n);\n</code></pre>"},{"location":"tutorials/private-storage/#step-4-verify-privacy-by-testing-unauthorized-access","title":"Step 4: Verify Privacy by Testing Unauthorized Access","text":"<p>Now, let\u2019s test if Node3 (an outsider) can access the stored data.</p>"},{"location":"tutorials/private-storage/#what-should-happen","title":"What should happen?","text":"<p>Node3 should NOT be able to retrieve the stored value because it wasn\u2019t part of the privacy group.</p> <pre><code>try {\n  logger.log(\"Node3 (outsider) attempting to retrieve the value...\");\n  await privateStorageContract.using(paladinNode3).call({\n    from: verifierNode3.lookup,\n    function: \"retrieve\",\n  });\n  logger.error(\n    \"Node3 (outsider) should not have access to the private Storage contract!\"\n  );\n  return false;\n} catch (error) {\n  logger.info(\n    \"Expected error - Node3 (outsider) cannot retrieve the data. Access denied.\"\n  );\n}\n</code></pre>"},{"location":"tutorials/private-storage/#why-privacy-groups-work","title":"Why Privacy Groups Work","text":"<ul> <li>Private State Isolation \u2013 Transactions within a privacy group are only visible to its members.</li> <li>No Global State Sharing \u2013 Outsiders (e.g., Node3) never receive the transaction history, making it impossible for them to infer contract data.</li> <li>Selective State Distribution \u2013 Only group members can access and verify the shared state.</li> </ul> <p>By design, Node3 does not just \u201clack permission\u201d to call the contract\u2014it lacks any knowledge of its state, history, or data, making unauthorized access fundamentally impossible.</p>"},{"location":"tutorials/private-storage/#conclusion","title":"Conclusion","text":"<p>Congratulations! You\u2019ve successfully:</p> <ol> <li>Created a privacy group with selected members.</li> <li>Deployed a <code>Storage</code> contract in the privacy group.</li> <li>Ensured secure interactions with the contract for group members.</li> <li>Verified that unauthorized access is blocked.</li> </ol>"},{"location":"tutorials/private-storage/#next-steps","title":"Next Steps","text":"<p>After exploring private smart contracts and learning how to keep contract data confidential within a privacy group, you\u2019re ready to explore other Paladin domains. In the next tutorial, you\u2019ll learn about Notarized Tokens (Noto) - a way to create, mint, and transfer tokens on the Paladin network. This will introduce concepts like notaries, restricted minting, and token transfers among multiple nodes.</p> <p>Continue to the Notarized Tokens Tutorial \u2192</p>"},{"location":"tutorials/public-storage/","title":"Public Smart Contract (SimpleStorage)","text":"<p>In the previous tutorial, we deployed and interacted with a HelloWorld contract that emitted an event. Now, we will go a step further and deploy a Storage contract that:</p> <ol> <li>Stores values on the blockchain</li> <li>Retrieves stored values on demand</li> </ol> <p>This tutorial will guide you through deploying, storing, and retrieving data using the Paladin SDK.</p> <p>Like the previous tutorial this one demonstrates traditional, non-private Ethereum activity using the Paladin APIs to drive the Paladin transaction manager.</p>"},{"location":"tutorials/public-storage/#prerequisites","title":"Prerequisites","text":"<p>Before you begin, ensure that you:  </p> <ul> <li>Completed the HelloWorld Tutorial, where you learned:  </li> <li>How to deploy contracts using the Paladin SDK</li> <li>How to send transactions and retrieve receipts</li> <li>Have access to a Paladin network to deploy and interact with smart contracts</li> </ul>"},{"location":"tutorials/public-storage/#overview","title":"Overview","text":"<p>The <code>Storage</code> contract provides two primary functions:  </p> <ul> <li><code>store(uint256 num)</code> \u2013 Stores a value in the contract</li> <li><code>retrieve()</code> \u2013 Retrieves the last stored value</li> </ul>"},{"location":"tutorials/public-storage/#paladin-api-ethereum-similarities","title":"Paladin API &amp; Ethereum Similarities","text":"<p>Paladin\u2019s API design follows Ethereum JSON-RPC patterns, making it familiar to developers who have used standard Ethereum APIs: - Transactions (<code>sendTransaction</code>) \u2192 Similar to <code>eth_sendTransaction</code>, used for modifying on-chain state - Calls (<code>call</code>) \u2192 Similar to <code>eth_call</code>, used for reading blockchain state without modifying it</p> <p>\ud83d\udca1 Numbers in Paladin are passed as strings by default, consistent with JSON-RPC standards</p>"},{"location":"tutorials/public-storage/#where-to-find-the-code","title":"Where to Find the Code?","text":"<p>\ud83d\udd39 Example implementation: Paladin example repository \ud83d\udd39 Solidity contract: Storage.sol </p>"},{"location":"tutorials/public-storage/#step-1-deploy-the-contract","title":"Step 1: Deploy the Contract","text":"<p>The first step is to deploy the <code>Storage</code> contract to the blockchain</p> <pre><code>const deploymentTxID = await paladin.ptx.sendTransaction({\n  type: TransactionType.PUBLIC,\n  abi: storageJson.abi,\n  bytecode: storageJson.bytecode,\n  from: owner.lookup,\n  data: {},\n});\n\n// Wait for deployment confirmation\nconst deploymentReceipt = await paladin.pollForReceipt(deploymentTxID, 10000);\nif (!deploymentReceipt?.contractAddress) {\n  logger.error(\"Deployment failed!\");\n  return false;\n}\nlogger.log(`Step 1: Storage contract deployed successfully at address: ${deploymentReceipt.contractAddress}`);\n</code></pre>"},{"location":"tutorials/public-storage/#what-happens-here","title":"What Happens Here?","text":"<ol> <li>The <code>sendTransaction</code> function creates a contract deployment transaction (similar to <code>eth_sendTransaction</code>)</li> <li>The <code>pollForReceipt</code> function waits for confirmation that the contract has been deployed</li> <li>If successful, the contract address is returned in the receipt</li> </ol>"},{"location":"tutorials/public-storage/#step-2-store-a-value","title":"Step 2: Store a Value","text":"<p>Now that the contract is deployed, you can store a value in it using the <code>store</code> function.</p> <pre><code>const valueToStore = 125; // Example value to store\nlogger.log(`Step 2: Storing value \"${valueToStore}\" in the contract...`);\n\nconst storeTxID = await paladin.ptx.sendTransaction({\n  type: TransactionType.PUBLIC,\n  abi: storageJson.abi,\n  function: \"store\",\n  from: owner.lookup,\n  to: deploymentReceipt.contractAddress,\n  data: { num: valueToStore },\n});\n\n// Wait for transaction confirmation\nconst storeReceipt = await paladin.pollForReceipt(storeTxID, 10000);\nif (!storeReceipt?.transactionHash) {\n  logger.error(\"Failed to store value in the contract!\");\n  return false;\n}\nlogger.log(`Step 2: Value stored successfully in the contract.`);\n</code></pre>"},{"location":"tutorials/public-storage/#what-happens-here_1","title":"What Happens Here?","text":"<ol> <li>The <code>sendTransaction</code> function calls the <code>store</code> function with the value <code>125</code></li> <li>The <code>pollForReceipt</code> function waits for confirmation that the value has been stored</li> </ol>"},{"location":"tutorials/public-storage/#step-3-retrieve-the-stored-value","title":"Step 3: Retrieve the Stored Value","text":"<p>Now, retrieve the stored value using the <code>retrieve</code> function</p> <pre><code>logger.log(\"Step 3: Retrieving the stored value...\");\n\nconst retrieveResult = await paladin.ptx.call({\n  type: TransactionType.PUBLIC,\n  abi: storageJson.abi,\n  function: \"retrieve\",\n  from: owner.lookup,\n  to: deploymentReceipt.contractAddress,\n  data: {},\n});\n\nconst retrievedValue = retrieveResult[\"value\"];\nif (retrievedValue !== valueToStore.toString()) {\n  logger.error(`Retrieved value \"${retrievedValue}\" does not match stored value \"${valueToStore}\"!`);\n  return false;\n}\nlogger.log(`Step 3: Value retrieved successfully: \"${retrievedValue}\"`);\n</code></pre>"},{"location":"tutorials/public-storage/#what-happens-here_2","title":"What Happens Here?","text":"<ol> <li>The <code>call</code> function reads the stored value from the contract (similar to <code>eth_call</code>)</li> <li>The retrieved value is compared to the original stored value to ensure correctness</li> </ol> <p>\ud83d\udca1 Transactions (<code>sendTransaction</code>) vs. Calls (<code>call</code>) - <code>sendTransaction</code>: Writes data to the blockchain (requires a transaction) - <code>call</code>: Reads data from the blockchain (does not modify state)</p> <p>\ud83d\udca1 Why is the number returned as a string? Paladin follows JSON-RPC conventions, where numbers are typically passed as strings to avoid precision loss in JavaScript</p>"},{"location":"tutorials/public-storage/#conclusion","title":"Conclusion","text":"<p>\ud83c\udf89 Congratulations! You\u2019ve successfully:</p> <ol> <li>Deployed the <code>Storage</code> contract</li> <li>Stored a value in the contract</li> <li>Retrieved the stored value and validated its correctness</li> </ol> <p>You now understand how to deploy and interact with a smart contract using the Paladin SDK, including JSON-RPC number handling and Ethereum transaction conventions</p>"},{"location":"tutorials/public-storage/#next-steps","title":"Next Steps","text":"<p>Now that you've learned how to deploy a public storage contract, it's time to take things to the next level!  </p> <p>\ud83d\udd12 In the next tutorial, you\u2019ll explore Storage with Privacy, where you will restrict access to stored values using privacy groups</p> <p>Continue to the Private Smart Contract Tutorial \u2192</p>"},{"location":"tutorials/zkp-cbdc/","title":"Cash Tokens based on Zeto","text":"<p>The code for this tutorial can be found in example/zeto.</p> <p>This shows how to leverage Zeto tokens in order to build a cash payment solution, for instance wholesale CBDC or a payment rail with commercial bank money, with privacy, illustrating multiple aspects of Paladin's privacy capabilities.</p>"},{"location":"tutorials/zkp-cbdc/#running-the-example","title":"Running the example","text":"<p>Follow the Getting Started instructions to set up a Paladin environment, and then follow the example README to run the code.</p>"},{"location":"tutorials/zkp-cbdc/#scenario-1-cash-solution-with-private-minting","title":"Scenario #1: cash solution with private minting","text":"<p>In this scenario, the Zeto tokens are directly minted by the authority in the Zeto contract, making the mint amounts private. This also means the total supply of the Zeto tokens is unknown to the participants. Only the authority performing the minting operations is aware of the total supply.</p> <p>Below is a walkthrough of each step in the example, with an explanation of what it does.</p>"},{"location":"tutorials/zkp-cbdc/#create-cbdc-token","title":"Create CBDC token","text":"<pre><code>const zetoFactory = new ZetoFactory(paladin3, 'zeto');\nconst zetoCBDC1 = await zetoFactory\n  .newZeto(cbdcIssuer, {\n    tokenName: 'Zeto_AnonNullifier',\n  })\n  .waitForDeploy();\n</code></pre> <p>This creates a new instance of the Zeto domain, using the Zeto_AnonNullifier contract. This results in a new cloned contract on the base ledger, with a new unique address. This Zeto token contract will be used to represent tokenized cash/CBDC.</p> <p>The token will be minted by the central bank/CBDC issuer party. Minting is restricted to be requested only by the central bank, the deployer account of the contract.</p>"},{"location":"tutorials/zkp-cbdc/#issue-cash","title":"Issue cash","text":"<pre><code>let receipt = await zetoCBDC1\n  .mint(cbdcIssuer, {\n    mints: [\n      {\n        to: bank1,\n        amount: 100000,\n        data: \"0x\",\n      },\n      {\n        to: bank2,\n        amount: 100000,\n        data: \"0x\",\n      },\n    ],\n  })\n  .waitForReceipt();\n</code></pre> <p>The cash issuer mints cash to the commercial banks, <code>bank1</code> and <code>bank2</code>.</p>"},{"location":"tutorials/zkp-cbdc/#bank1-transfers-tokens-to-bank2-as-payment","title":"Bank1 transfers tokens to bank2 as payment","text":"<pre><code>receipt = await zetoCBDC1\n  .using(paladin1)\n  .transfer(bank1, {\n    transfers: [\n      {\n        to: bank2,\n        amount: 1000,\n        data: \"0x\",\n      },\n    ],\n  })\n  .waitForReceipt();\n</code></pre> <p>Bank1 can call the <code>transfer</code> function to transfer zeto tokens to multiple parties, up to 10. Note that the identity <code>bank1</code> exists on the <code>paladin1</code> instance, therefore it must use that instance to send the transfer transction (<code>.using(paladin1)</code>).</p>"},{"location":"tutorials/zkp-cbdc/#scenario-2-cash-solution-with-public-minting","title":"Scenario #2: cash solution with public minting","text":"<p>This scenario supports the requirement to make the total supply of the cash tokens public. This is achieved by making the authority perform the minting operations in an ERC20 contract. The participants can then exchange their ERC20 balances for Zeto tokens, by calling <code>deposit</code>, and exchange back to their ERC20 balances by calling <code>withdraw</code>.</p> <p>Below is a walkthrough of each step in the example, with an explanation of what it does.</p>"},{"location":"tutorials/zkp-cbdc/#create-cbdc-token_1","title":"Create CBDC token","text":"<pre><code>const zetoCBDC2 = await zetoFactory\n  .newZeto(cbdcIssuer, {\n    tokenName: 'Zeto_AnonNullifier',\n  })\n  .waitForDeploy();\n</code></pre> <p>This creates a new instance of the Zeto domain, using the Zeto_AnonNullifier contract. This results in a new cloned contract on the base ledger, with a new unique address. This Zeto token contract will be used to represent tokenized cash/CBDC.</p>"},{"location":"tutorials/zkp-cbdc/#create-public-supply-token-erc20","title":"Create public supply token (ERC20)","text":"<pre><code>const erc20Address = await deployERC20(paladin3, cbdcIssuer);\n</code></pre> <p>This deploys the ERC20 token which will be used by the authority to regulate the CBDC supply, with transparency to the paricipants.</p>"},{"location":"tutorials/zkp-cbdc/#configure-the-zeto-token-contract-to-accept-deposits-and-withdraws-from-the-erc20","title":"Configure the Zeto token contract to accept deposits and withdraws from the ERC20","text":"<pre><code>const result2 = await zetoCBDC2\n  .setERC20(cbdcIssuer, {\n    erc20: erc20Address as string,\n  })\n  .waitForReceipt();\n</code></pre> <p>When the <code>deposit</code> function is called on the Zeto contract, this ERC20 contract will be called to draw the requested funds from the depositor's account. Conversely, when the <code>withdraw</code> function is called, this ERC20 contract will be called to transfer back the ERC20 balance to the withdrawer's account.</p>"},{"location":"tutorials/zkp-cbdc/#mint-erc20-tokens-to-publicly-regulate-cbdc-supplies","title":"Mint ERC20 tokens to publicly regulate CBDC supplies","text":"<pre><code>await mintERC20(paladin3, cbdcIssuer, bank1, erc20Address!, 100000);\n</code></pre> <p>Because the ERC20 implementation provides full transparency of the token operations, minting in the ERC20 allows all blockchain network participants to be aware of the overall supply of the CBDC tokens.</p>"},{"location":"tutorials/zkp-cbdc/#banks-exchange-erc20-balances-for-zeto-tokens-deposit","title":"Banks exchange ERC20 balances for Zeto tokens - deposit","text":"<pre><code>const result4 = await zetoCBDC2\n  .using(paladin1)\n  .deposit(bank1, {\n    amount: 10000,\n  })\n  .waitForReceipt();\n</code></pre> <p>After having been minted ERC20 balances, a partcipant like <code>bank1</code> can call <code>deposit</code> on the Paladin Zeto domain to exchange for Zeto tokens. Behind the scenes, the ERC20 balance is transferred to the Zeto contract which will hold until <code>withdraw</code> is called later.</p>"},{"location":"tutorials/zkp-cbdc/#bank1-transfers-tokens-to-bank2-as-payment_1","title":"Bank1 transfers tokens to bank2 as payment","text":"<pre><code>receipt = await zetoCBDC2\n  .using(paladin1)\n  .transfer(bank1, {\n    transfers: [\n      {\n        to: bank2,\n        amount: 1000,\n        data: \"0x\",\n      },\n    ],\n  })\n  .waitForReceipt();\n</code></pre> <p>Bank1 can call the <code>transfer</code> function to transfer zeto tokens to multiple parties, up to 10. Note that the identity <code>bank1</code> exists on the <code>paladin1</code> instance, therefore it must use that instance to send the transfer transction (<code>.using(paladin1)</code>).</p>"},{"location":"tutorials/zkp-cbdc/#bank1-exchanges-zeto-tokens-for-erc20-balances-withdraw","title":"Bank1 exchanges Zeto tokens for ERC20 balances - withdraw","text":"<pre><code>const result5 = await zetoCBDC2\n  .using(paladin1)\n  .withdraw(bank1, {\n    amount: 1000,\n  })\n  .waitForReceipt();\n</code></pre> <p>A participant like <code>bank1</code> who has unspent Zeto tokens can call <code>withdraw</code> on the Paladin Zeto domain to exchange them for ERC20 balances. Behind the scenes, the requested amount are \"burnt\" in the Zeto contract, and the corresponding ERC20 amount are released by the Zeto contract, by transferring to the requesting account.</p>"},{"location":"tutorials/zkp-cbdc/#next-steps","title":"Next Steps","text":"<p>Next, explore Zeto tokens further to understand how compliant KYC processes can be integrated with zero-knowledge proof-backed tokens.</p> <p>Continue to the Private Stablecoin Tutorial \u2192</p>"}]}